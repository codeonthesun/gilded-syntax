<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gilded Syntax</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&family=Cinzel:wght@400;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            cursor: none !important; /* Hide system cursor globally for custom cursors */
        }
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Prevents double-tap zoom on mobile */
            caret-color: transparent; /* Hides the blinking text caret */
        }
        .font-cinzel {
            font-family: 'Cinzel', serif;
        }
        .chat-log::-webkit-scrollbar {
            display: none;
        }
        .chat-log {
            scrollbar-width: none;
        }
        .chat-log.collapsed > div:not(:last-child) {
            display: none;
        }
        .chat-log.collapsed {
            height: 4rem;
        }
        .boss-timer-bar {
            transition: width 0.1s linear;
        }
        .tooltip {
            position: relative;
        }
        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(4px);
            background: #1f2937;
            color: #f9fafb;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            line-height: 1.4;
            white-space: normal;
            word-break: break-word;
            text-align: left;
            min-width: 200px;
            max-width: 400px;
            max-height: 200px;
            overflow-y: auto;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 2000;
            border: 2px solid #374151;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .tooltip:hover::after {
            opacity: 1;
        }
        .tooltip.above::after {
            bottom: 100%;
            top: auto;
            transform: translateX(-50%) translateY(4px);
        }
        .tooltip.below::after {
            top: 100%;
            left: 100%;
            bottom: auto;
            transform: translateX(0) translateY(0);
        }
        .tooltip.left::after {
            top: 50%;
            left: 0;
            bottom: auto;
            transform: translateX(-120%) translateY(-50%);
        }
        .tooltip.right::after {
            top: 50%;
            left: 100%;
            bottom: auto;
            transform: translateX(40px) translateY(10px);
        }
        #zoneObjectivesContainer, #bankContainer {
            transition: order 0.5s ease-in-out;
        }
        .glow {
            animation: faintGlow 1.5s infinite ease-in-out;
            position: relative;
        }
        .glow::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 0;
            height: 2px;
            background: currentColor;
            box-shadow: 0 0 8px currentColor;
            animation: trace 0.6s ease forwards;
        }
        .glow-static {
            animation: faintGlow 1.5s infinite ease-in-out;
        }
        @keyframes faintGlow {
            0%, 100% { text-shadow: 0 0 8px currentColor; }
            50% { text-shadow: 0 0 15px currentColor; }
        }
        @keyframes trace {
            0% { width: 0; }
            100% { width: 100%; }
        }

        /* --- Generic Button Styles --- */
        .btn {
            cursor: pointer;
            border: none;
            background: none;
            padding: 0;
            font-family: 'MedievalSharp', cursive;
            color: white;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
            transition: all 0.1s ease-in-out;
            position: relative;
            -webkit-tap-highlight-color: transparent; /* Removes blue highlight on mobile tap */
        }

        /* Fixed size for action buttons */
        .action-btn {
            width: 160px;
            height: 128px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .action-btn .content {
            display: none;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            justify-content: center;
            align-items: center;
        }

        .action-btn.gather-mode .gather-content { display: flex; }
        .action-btn.gather-mode { width: 128px; height: 128px; }
        .action-btn.boss-mode .boss-content { display: flex; }
        .action-btn.boss-mode .boss-content { display: flex; }
        .action-btn.boss-mode { width: 160px; height: 80px; }
        .action-btn.attack-mode .attack-content { display: flex; }
        .action-btn.attack-mode { height: 80px; }
        .action-btn.store-mode .store-content { display: flex; }

        .btn:focus {
            outline: none;
        }

        /* --- Style 2: Boss Button --- */
        .boss-btn {
            background:
                /* Main red gradient - much more red */
                linear-gradient(135deg, #7f1d1d 0%, #991b1b 15%, #b91c1c 30%, #dc2626 50%, #ef4444 75%, #f87171 100%),
                /* Dark red undertones for depth */
                radial-gradient(circle at 30% 70%, rgba(127, 29, 29, 0.9) 0%, transparent 60%),
                /* Base dark red */
                linear-gradient(135deg, #450a0a, #7f1d1d);
            border: 3px solid #450a0a;
            border-radius: 12px;
            font-size: 22px;
            height: 72px;
            /* Enhanced shadows with red glow */
            box-shadow:
                /* Inner shadow for depth */
                inset 0 0 15px rgba(0, 0, 0, 0.5),
                inset 0 0 25px rgba(139, 27, 27, 0.3),
                /* Main drop shadow */
                0 6px 0 #450a0a,
                0 10px 20px rgba(0, 0, 0, 0.6),
                0 15px 25px rgba(127, 29, 29, 0.4),
                /* Red glow */
                0 0 20px rgba(185, 28, 28, 0.5),
                0 0 40px rgba(220, 38, 38, 0.3),
                0 0 60px rgba(239, 68, 68, 0.2);
            overflow: hidden;
            position: relative;
            transition: all 0.3s ease-in-out;
        }

        /* --- Attack Scale Button (copy of Dragon Scale) --- */
        .attack-scale-btn {
            background:
                /* Main red gradient - much more red */
                linear-gradient(135deg, #7f1d1d 0%, #991b1b 15%, #b91c1c 30%, #dc2626 50%, #ef4444 75%, #f87171 100%),
                /* Dark red undertones for depth */
                radial-gradient(circle at 30% 70%, rgba(127, 29, 29, 0.9) 0%, transparent 60%),
                /* Base dark red */
                linear-gradient(135deg, #450a0a, #7f1d1d);
            border: 3px solid #450a0a;
            border-radius: 12px;
            font-size: 22px;
            height: 72px;
            /* Enhanced shadows with red glow */
            box-shadow:
                /* Inner shadow for depth */
                inset 0 0 15px rgba(0, 0, 0, 0.5),
                inset 0 0 25px rgba(139, 27, 27, 0.3),
                /* Main drop shadow */
                0 6px 0 #450a0a,
                0 10px 20px rgba(0, 0, 0, 0.6),
                0 15px 25px rgba(127, 29, 29, 0.4),
                /* Red glow */
                0 0 20px rgba(185, 28, 28, 0.5),
                0 0 40px rgba(220, 38, 38, 0.3),
                0 0 60px rgba(239, 68, 68, 0.2);
            overflow: hidden;
            position: relative;
            transition: all 0.3s ease-in-out;
        }

        .boss-btn::before { /* Subtle texture overlay */
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                /* Simple texture pattern */
                radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.1) 3px, transparent 3.5px),
                radial-gradient(circle at 80% 80%, rgba(0, 0, 0, 0.1) 2px, transparent 2.5px),
                radial-gradient(circle at 60% 40%, rgba(255, 255, 255, 0.05) 1px, transparent 1.5px);
            background-size: 15px 15px, 12px 12px, 8px 8px;
            z-index: 1;
        }

        .attack-scale-btn::before { /* Subtle texture overlay */
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-image:
                /* Simple texture pattern */
                radial-gradient(circle at 20% 20%, rgba(255, 255, 255, 0.1) 3px, transparent 3.5px),
                radial-gradient(circle at 80% 80%, rgba(0, 0, 0, 0.1) 2px, transparent 2.5px),
                radial-gradient(circle at 60% 40%, rgba(255, 255, 255, 0.05) 1px, transparent 1.5px);
            background-size: 15px 15px, 12px 12px, 8px 8px;
            z-index: 1;
        }

        .boss-btn::after { /* Fire sweep effect */
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(251, 146, 60, 0.3) 20%,
                rgba(239, 68, 68, 0.5) 40%,
                rgba(220, 38, 38, 0.7) 60%,
                rgba(251, 146, 60, 0.3) 80%,
                transparent 100%);
            animation: fireSweep 3s ease-in-out infinite;
            z-index: 1; /* Behind text but above texture */
        }

        .attack-scale-btn::after { /* Fire sweep effect */
            content: "";
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg,
                transparent 0%,
                rgba(251, 146, 60, 0.3) 20%,
                rgba(239, 68, 68, 0.5) 40%,
                rgba(220, 38, 38, 0.7) 60%,
                rgba(251, 146, 60, 0.3) 80%,
                transparent 100%);
            animation: fireSweep 3s ease-in-out infinite;
            z-index: 1; /* Behind text but above texture */
        }

        /* Ensure text content appears above all effects */
        .boss-btn {
            position: relative;
        }

        .boss-btn::after {
            pointer-events: none; /* Allow clicks to pass through */
        }

        /* Force text content to be above effects */
        .boss-btn {
            z-index: 0; /* Reset */
        }

        .boss-btn::before,
        .boss-btn::after {
            z-index: -1; /* Put effects behind everything */
        }

        /* Ensure text content appears above all effects */
        .attack-scale-btn {
            position: relative;
        }

        .attack-scale-btn::after {
            pointer-events: none; /* Allow clicks to pass through */
        }

        /* Force text content to be above effects */
        .attack-scale-btn {
            z-index: 0; /* Reset */
        }

        .attack-scale-btn::before,
        .attack-scale-btn::after {
            z-index: -1; /* Put effects behind everything */
        }

        /* Disable only animations when button is disabled - keep visual styling */
        .boss-btn.disabled::before {
            animation-play-state: paused !important;
            /* Keep opacity but make texture more subtle */
            opacity: 0.5 !important;
        }

        .boss-btn.disabled::after {
            animation-play-state: paused !important;
            opacity: 0 !important; /* Hide the sweeping effect only */
        }

        .boss-btn.disabled {
            filter: grayscale(30%) brightness(0.9) !important; /* Subtle disabled look */
            /* Keep all the visual styling - no background override */
        }

        /* Also target action-btn disabled state specifically */
        .action-btn.disabled .boss-btn::before {
            animation-play-state: paused !important;
        }

        .action-btn.disabled .boss-btn::after {
            animation-play-state: paused !important;
            opacity: 0 !important;
        }

        /* Disable only animations when button is disabled - keep visual styling */
        .attack-scale-btn.disabled::before {
            animation-play-state: paused !important;
            /* Keep opacity but make texture more subtle */
            opacity: 0.5 !important;
        }

        .attack-scale-btn.disabled::after {
            animation-play-state: paused !important;
            opacity: 0 !important; /* Hide the sweeping effect only */
        }

        .attack-scale-btn.disabled {
            filter: grayscale(30%) brightness(0.9) !important; /* Subtle disabled look */
            /* Keep all the visual styling - no background override */
        }

        /* Also target action-btn disabled state specifically */
        .action-btn.disabled .attack-scale-btn::before {
            animation-play-state: paused !important;
        }

        .action-btn.disabled .attack-scale-btn::after {
            animation-play-state: paused !important;
            opacity: 0 !important;
        }

        .boss-btn:hover {
            transform: translateY(-2px) scale(1.02);
            background:
                /* Brighter red hover gradient - no pink/white */
                linear-gradient(135deg, #991b1b 0%, #b91c1c 15%, #dc2626 35%, #ef4444 60%, #f87171 85%, #fca5a5 100%),
                /* Enhanced red undertones */
                radial-gradient(circle at 25% 75%, rgba(127, 29, 29, 0.9) 0%, transparent 65%),
                /* Base hover color */
                linear-gradient(135deg, #7f1d1d, #b91c1c);
            /* Enhanced hover shadows - reduced bright glow */
            box-shadow:
                /* Inner shadow */
                inset 0 0 20px rgba(0, 0, 0, 0.4),
                inset 0 0 30px rgba(185, 28, 28, 0.3),
                /* Main drop shadow */
                0 8px 0 #450a0a,
                0 14px 28px rgba(0, 0, 0, 0.6),
                0 20px 35px rgba(127, 29, 29, 0.4),
                /* Reduced red glow - no bright white */
                0 0 25px rgba(185, 28, 28, 0.5),
                0 0 45px rgba(220, 38, 38, 0.3),
                0 0 65px rgba(239, 68, 68, 0.2);
            filter: brightness(1.1) contrast(1.1);
        }

        .attack-scale-btn:hover {
            transform: translateY(-2px) scale(1.02);
            background:
                /* Brighter red hover gradient - no pink/white */
                linear-gradient(135deg, #991b1b 0%, #b91c1c 15%, #dc2626 35%, #ef4444 60%, #f87171 85%, #fca5a5 100%),
                /* Enhanced red undertones */
                radial-gradient(circle at 25% 75%, rgba(127, 29, 29, 0.9) 0%, transparent 65%),
                /* Base hover color */
                linear-gradient(135deg, #7f1d1d, #b91c1c);
            /* Enhanced hover shadows - reduced bright glow */
            box-shadow:
                /* Inner shadow */
                inset 0 0 20px rgba(0, 0, 0, 0.4),
                inset 0 0 30px rgba(185, 28, 28, 0.3),
                /* Main drop shadow */
                0 8px 0 #450a0a,
                0 14px 28px rgba(0, 0, 0, 0.6),
                0 20px 35px rgba(127, 29, 29, 0.4),
                /* Reduced red glow - no bright white */
                0 0 25px rgba(185, 28, 28, 0.5),
                0 0 45px rgba(220, 38, 38, 0.3),
                0 0 65px rgba(239, 68, 68, 0.2);
            filter: brightness(1.1) contrast(1.1);
        }

        .boss-btn:active {
            transform: translateY(4px) scale(0.98);
            background:
                /* Pressed state gradient - darker reds */
                linear-gradient(135deg, #450a0a 0%, #7f1d1d 20%, #991b1b 40%, #b91c1c 70%, #dc2626 100%),
                /* Dimmed undertones */
                radial-gradient(circle at 35% 65%, rgba(69, 10, 10, 0.8) 0%, transparent 55%),
                /* Base pressed color */
                linear-gradient(135deg, #450a0a, #7f1d1d);
            /* Pressed shadows */
            box-shadow:
                /* Heavy inset for pressed effect */
                inset 0 0 20px rgba(0, 0, 0, 0.7),
                inset 0 0 40px rgba(127, 29, 29, 0.3),
                /* Reduced external shadows */
                0 3px 0 #450a0a,
                0 6px 12px rgba(0, 0, 0, 0.6),
                0 9px 15px rgba(69, 10, 10, 0.4),
                /* Dimmed red glow */
                0 0 15px rgba(153, 27, 27, 0.4),
                0 0 30px rgba(127, 29, 29, 0.3);
            filter: brightness(0.85) contrast(0.9);
        }

        .attack-scale-btn:active {
            transform: translateY(4px) scale(0.98);
            background:
                /* Pressed state gradient - darker reds */
                linear-gradient(135deg, #450a0a 0%, #7f1d1d 20%, #991b1b 40%, #b91c1c 70%, #dc2626 100%),
                /* Dimmed undertones */
                radial-gradient(circle at 35% 65%, rgba(69, 10, 10, 0.8) 0%, transparent 55%),
                /* Base pressed color */
                linear-gradient(135deg, #450a0a, #7f1d1d);
            /* Pressed shadows */
            box-shadow:
                /* Heavy inset for pressed effect */
                inset 0 0 20px rgba(0, 0, 0, 0.7),
                inset 0 0 40px rgba(127, 29, 29, 0.3),
                /* Reduced external shadows */
                0 3px 0 #450a0a,
                0 6px 12px rgba(0, 0, 0, 0.6),
                0 9px 15px rgba(69, 10, 10, 0.4),
                /* Dimmed red glow */
                0 0 15px rgba(153, 27, 27, 0.4),
                0 0 30px rgba(127, 29, 29, 0.3);
            filter: brightness(0.85) contrast(0.9);
        }

        @keyframes fireSweep {
            0% {
                transform: translateX(-100%) skewX(-15deg);
                opacity: 0;
            }
            10% {
                opacity: 1;
            }
            90% {
                opacity: 1;
            }
            100% {
                transform: translateX(100%) skewX(-15deg);
                opacity: 0;
            }
        }

        /* --- Style 3: Gold Coin Pile Button --- */
        .coin-pile-btn {
            position: relative;
            filter: drop-shadow(0 10px 20px rgba(0, 0, 0, 0.3));
        }
        .coin-pile-btn .coin {
            position: absolute;
            width: 90px;
            height: 90px;
            background:
                /* Main coin face with enhanced depth */
                linear-gradient(135deg, #ffd700 0%, #f0c36b 25%, #d4a24a 50%, #b8860b 75%, #8b6914 100%),
                /* Highlight for raised edge */
                radial-gradient(circle at 30% 20%, rgba(255, 215, 0, 0.8) 0%, rgba(255, 215, 0, 0.4) 30%, transparent 50%),
                /* Rim highlight */
                radial-gradient(circle at 25% 25%, rgba(255, 255, 255, 0.6) 0%, rgba(255, 255, 255, 0.2) 35%, transparent 45%),
                /* Base metallic color */
                radial-gradient(circle, #f0c36b 0%, #d4a24a 60%, #a97f33 100%);
            border-radius: 50%;
            /* Enhanced shadows for depth */
            box-shadow:
                /* Inner shadow for concave effect */
                inset 0 0 15px rgba(0, 0, 0, 0.3),
                inset 0 0 30px rgba(255, 215, 0, 0.1),
                /* Main drop shadow */
                0 6px 0 #6d5220,
                0 10px 15px rgba(0, 0, 0, 0.4),
                0 15px 25px rgba(139, 69, 19, 0.2),
                /* Outer glow */
                0 0 20px rgba(255, 215, 0, 0.3);
            transition: all 0.15s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            display: flex;
            align-items: center;
            justify-content: center;
            left: 50%;
            border: 2px solid rgba(139, 69, 19, 0.3);
        }
        .coin-pile-btn .top-coin {
            font-size: 22px;
            color: #4d3817;
            text-shadow: 1px 1px 1px rgba(255, 230, 179, 0.5), 2px 2px 3px rgba(0, 0, 0, 0.3);
            z-index: 5;
            transform: translateX(-50%);
            top: 15px;
            background:
                /* Top coin with maximum highlight */
                linear-gradient(135deg, #ffed4e 0%, #ffd700 25%, #f0c36b 50%, #d4a24a 75%, #b8860b 100%),
                /* Bright face highlight */
                radial-gradient(circle at 20% 15%, rgba(255, 255, 255, 0.9) 0%, rgba(255, 255, 255, 0.3) 25%, transparent 40%),
                /* Edge definition */
                radial-gradient(circle at 30% 30%, rgba(255, 215, 0, 0.7) 0%, rgba(255, 215, 0, 0.2) 40%, transparent 60%),
                /* Base metallic */
                radial-gradient(circle, #ffd700 0%, #f0c36b 60%, #d4a24a 100%);
            /* Enhanced shadows for top coin */
            box-shadow:
                inset 0 0 20px rgba(0, 0, 0, 0.2),
                inset 0 0 40px rgba(255, 215, 0, 0.2),
                0 8px 0 #8b6914,
                0 12px 20px rgba(0, 0, 0, 0.5),
                0 20px 30px rgba(139, 69, 19, 0.3),
                0 0 25px rgba(255, 215, 0, 0.4);
        }
        .coin-pile-btn .mid-coin {
            z-index: 4;
            transform: translateX(calc(-50% - 10px)) rotate(-10deg);
            top: 20px;
            background:
                /* Middle coin with angled lighting */
                linear-gradient(120deg, #f0c36b 0%, #d4a24a 25%, #a97f33 50%, #8b6914 75%, #6d5220 100%),
                /* Side highlight */
                radial-gradient(circle at 15% 20%, rgba(255, 255, 255, 0.5) 0%, rgba(255, 255, 255, 0.1) 30%, transparent 50%),
                /* Edge glow */
                radial-gradient(circle at 25% 25%, rgba(255, 215, 0, 0.4) 0%, rgba(255, 215, 0, 0.1) 35%, transparent 55%),
                /* Base color */
                radial-gradient(circle, #d4a24a 0%, #a97f33 60%, #8b662b 100%);
            /* Medium depth shadows */
            box-shadow:
                inset 0 0 15px rgba(0, 0, 0, 0.3),
                inset 0 0 25px rgba(255, 215, 0, 0.1),
                0 6px 0 #6d5220,
                0 10px 15px rgba(0, 0, 0, 0.4),
                0 15px 20px rgba(139, 69, 19, 0.2),
                0 0 15px rgba(255, 215, 0, 0.2);
        }
        .coin-pile-btn .bottom-coin {
            z-index: 3;
            transform: translateX(calc(-50% + 10px)) rotate(15deg);
            top: 25px;
            background:
                /* Bottom coin with deeper tones */
                linear-gradient(150deg, #d4a24a 0%, #a97f33 25%, #8b6914 50%, #6d5220 75%, #4d3817 100%),
                /* Subtle highlight */
                radial-gradient(circle at 35% 15%, rgba(255, 255, 255, 0.3) 0%, rgba(255, 255, 255, 0.05) 25%, transparent 45%),
                /* Minimal edge glow */
                radial-gradient(circle at 40% 20%, rgba(255, 215, 0, 0.2) 0%, rgba(255, 215, 0, 0.05) 30%, transparent 50%),
                /* Base color */
                radial-gradient(circle, #c89b3c 0%, #a97f33 60%, #6d5220 100%);
            /* Deeper shadows for bottom coin */
            box-shadow:
                inset 0 0 18px rgba(0, 0, 0, 0.4),
                inset 0 0 30px rgba(255, 215, 0, 0.05),
                0 5px 0 #4d3817,
                0 8px 12px rgba(0, 0, 0, 0.5),
                0 12px 18px rgba(139, 69, 19, 0.3),
                0 0 10px rgba(255, 215, 0, 0.1);
        }
        .coin-pile-btn .left-coin {
            z-index: 2;
            transform: translateX(calc(-50% - 35px)) rotate(-20deg);
            top: 30px;
            background:
                /* Left coin with side lighting */
                linear-gradient(90deg, #a97f33 0%, #8b6914 25%, #6d5220 50%, #4d3817 75%, #2f2f2f 100%),
                /* Left side highlight */
                radial-gradient(circle at 10% 25%, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.1) 20%, transparent 40%),
                /* Minimal edge */
                radial-gradient(circle at 20% 30%, rgba(255, 215, 0, 0.15) 0%, transparent 25%),
                /* Base color */
                radial-gradient(circle, #a97f33 0%, #8b662b 60%, #4d3817 100%);
            /* Side shadows */
            box-shadow:
                inset 0 0 20px rgba(0, 0, 0, 0.5),
                inset 0 0 25px rgba(255, 215, 0, 0.05),
                0 4px 0 #2f2f2f,
                0 6px 10px rgba(0, 0, 0, 0.6),
                0 8px 15px rgba(139, 69, 19, 0.4),
                0 0 8px rgba(255, 215, 0, 0.1);
        }
        .coin-pile-btn .right-coin {
            z-index: 1;
            transform: translateX(calc(-50% + 35px)) rotate(20deg);
            top: 35px;
            background:
                /* Right coin with opposite side lighting */
                linear-gradient(270deg, #a97f33 0%, #8b6914 25%, #6d5220 50%, #4d3817 75%, #2f2f2f 100%),
                /* Right side highlight */
                radial-gradient(circle at 90% 25%, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.1) 20%, transparent 40%),
                /* Minimal edge */
                radial-gradient(circle at 80% 30%, rgba(255, 215, 0, 0.15) 0%, transparent 25%),
                /* Base color */
                radial-gradient(circle, #a97f33 0%, #8b662b 60%, #4d3817 100%);
            /* Side shadows */
            box-shadow:
                inset 0 0 20px rgba(0, 0, 0, 0.5),
                inset 0 0 25px rgba(255, 215, 0, 0.05),
                0 4px 0 #2f2f2f,
                0 6px 10px rgba(0, 0, 0, 0.6),
                0 8px 15px rgba(139, 69, 19, 0.4),
                0 0 8px rgba(255, 215, 0, 0.1);
        }
        .coin-pile-btn:hover .top-coin {
            transform: translateX(-50%) translateY(-6px) scale(1.05);
            background:
                /* Enhanced top coin hover */
                linear-gradient(135deg, #ffffe0 0%, #ffed4e 25%, #ffd700 50%, #f0c36b 75%, #d4a24a 100%),
                /* Bright hover highlight */
                radial-gradient(circle at 15% 10%, rgba(255, 255, 255, 1) 0%, rgba(255, 255, 255, 0.4) 20%, transparent 35%),
                /* Enhanced edge glow */
                radial-gradient(circle at 25% 25%, rgba(255, 215, 0, 0.9) 0%, rgba(255, 215, 0, 0.3) 35%, transparent 50%),
                /* Base hover color */
                radial-gradient(circle, #ffed4e 0%, #ffd700 60%, #f0c36b 100%);
            /* Enhanced hover shadows */
            box-shadow:
                inset 0 0 25px rgba(0, 0, 0, 0.15),
                inset 0 0 50px rgba(255, 215, 0, 0.3),
                0 10px 0 #8b6914,
                0 15px 25px rgba(0, 0, 0, 0.4),
                0 25px 35px rgba(139, 69, 19, 0.25),
                0 0 30px rgba(255, 215, 0, 0.6),
                0 0 50px rgba(255, 215, 0, 0.3);
        }
        .coin-pile-btn:hover .mid-coin {
            transform: translateX(calc(-50% - 12px)) translateY(-2px) rotate(-12deg) scale(1.02);
            background:
                /* Enhanced middle coin hover */
                linear-gradient(120deg, #f0c36b 0%, #e6b800 25%, #d4a24a 50%, #b8860b 75%, #8b6914 100%),
                /* Brighter side highlight */
                radial-gradient(circle at 10% 15%, rgba(255, 255, 255, 0.7) 0%, rgba(255, 255, 255, 0.2) 25%, transparent 45%),
                /* Enhanced edge glow */
                radial-gradient(circle at 20% 20%, rgba(255, 215, 0, 0.6) 0%, rgba(255, 215, 0, 0.2) 30%, transparent 50%),
                /* Base hover color */
                radial-gradient(circle, #e6b800 0%, #d4a24a 60%, #a97f33 100%);
            /* Enhanced hover shadows */
            box-shadow:
                inset 0 0 20px rgba(0, 0, 0, 0.25),
                inset 0 0 35px rgba(255, 215, 0, 0.15),
                0 8px 0 #6d5220,
                0 12px 20px rgba(0, 0, 0, 0.35),
                0 18px 25px rgba(139, 69, 19, 0.2),
                0 0 20px rgba(255, 215, 0, 0.3);
        }
        .coin-pile-btn:hover .bottom-coin {
            transform: translateX(calc(-50% + 12px)) translateY(-2px) rotate(17deg) scale(1.02);
            background:
                /* Enhanced bottom coin hover */
                linear-gradient(150deg, #d4a24a 0%, #c89b3c 25%, #a97f33 50%, #8b6914 75%, #6d5220 100%),
                /* Brighter highlight */
                radial-gradient(circle at 30% 10%, rgba(255, 255, 255, 0.5) 0%, rgba(255, 255, 255, 0.1) 20%, transparent 40%),
                /* Enhanced edge glow */
                radial-gradient(circle at 35% 15%, rgba(255, 215, 0, 0.4) 0%, rgba(255, 215, 0, 0.1) 25%, transparent 45%),
                /* Base hover color */
                radial-gradient(circle, #c89b3c 0%, #a97f33 60%, #8b6914 100%);
            /* Enhanced hover shadows */
            box-shadow:
                inset 0 0 22px rgba(0, 0, 0, 0.35),
                inset 0 0 35px rgba(255, 215, 0, 0.1),
                0 7px 0 #4d3817,
                0 10px 15px rgba(0, 0, 0, 0.45),
                0 15px 22px rgba(139, 69, 19, 0.25),
                0 0 15px rgba(255, 215, 0, 0.2);
        }
        .coin-pile-btn:hover .left-coin {
            transform: translateX(calc(-50% - 37px)) translateY(-2px) rotate(-22deg) scale(1.02);
            background:
                /* Enhanced left coin hover */
                linear-gradient(90deg, #b8860b 0%, #a97f33 25%, #8b6914 50%, #6d5220 75%, #4d3817 100%),
                /* Brighter left highlight */
                radial-gradient(circle at 5% 20%, rgba(255, 255, 255, 0.6) 0%, rgba(255, 255, 255, 0.15) 15%, transparent 35%),
                /* Enhanced edge */
                radial-gradient(circle at 15% 25%, rgba(255, 215, 0, 0.3) 0%, rgba(255, 215, 0, 0.05) 20%, transparent 40%),
                /* Base hover color */
                radial-gradient(circle, #a97f33 0%, #8b6914 60%, #6d5220 100%);
            /* Enhanced hover shadows */
            box-shadow:
                inset 0 0 25px rgba(0, 0, 0, 0.4),
                inset 0 0 30px rgba(255, 215, 0, 0.1),
                0 6px 0 #2f2f2f,
                0 8px 12px rgba(0, 0, 0, 0.5),
                0 12px 18px rgba(139, 69, 19, 0.3),
                0 0 12px rgba(255, 215, 0, 0.2);
        }
        .coin-pile-btn:hover .right-coin {
            transform: translateX(calc(-50% + 37px)) translateY(-2px) rotate(22deg) scale(1.02);
            background:
                /* Enhanced right coin hover */
                linear-gradient(270deg, #b8860b 0%, #a97f33 25%, #8b6914 50%, #6d5220 75%, #4d3817 100%),
                /* Brighter right highlight */
                radial-gradient(circle at 95% 20%, rgba(255, 255, 255, 0.6) 0%, rgba(255, 255, 255, 0.15) 15%, transparent 35%),
                /* Enhanced edge */
                radial-gradient(circle at 85% 25%, rgba(255, 215, 0, 0.3) 0%, rgba(255, 215, 0, 0.05) 20%, transparent 40%),
                /* Base hover color */
                radial-gradient(circle, #a97f33 0%, #8b6914 60%, #6d5220 100%);
            /* Enhanced hover shadows */
            box-shadow:
                inset 0 0 25px rgba(0, 0, 0, 0.4),
                inset 0 0 30px rgba(255, 215, 0, 0.1),
                0 6px 0 #2f2f2f,
                0 8px 12px rgba(0, 0, 0, 0.5),
                0 12px 18px rgba(139, 69, 19, 0.3),
                0 0 12px rgba(255, 215, 0, 0.2);
        }
        .coin-pile-btn:active .coin {
            transition: all 0.05s ease-in-out;
        }
        .coin-pile-btn:active .top-coin {
            transform: translateX(-50%) translateY(6px) scale(0.95);
            background:
                /* Pressed top coin with dimmed colors */
                linear-gradient(135deg, #d4a24a 0%, #b8860b 25%, #a97f33 50%, #8b6914 75%, #6d5220 100%),
                /* Dimmed highlight */
                radial-gradient(circle at 35% 25%, rgba(255, 255, 255, 0.2) 0%, rgba(255, 255, 255, 0.05) 30%, transparent 50%),
                /* Reduced edge glow */
                radial-gradient(circle at 40% 30%, rgba(255, 215, 0, 0.1) 0%, transparent 20%),
                /* Base pressed color */
                radial-gradient(circle, #b8860b 0%, #a97f33 60%, #8b6914 100%);
            /* Pressed shadows */
            box-shadow:
                /* Heavy inset for pressed effect */
                inset 0 0 25px rgba(0, 0, 0, 0.6),
                inset 0 0 40px rgba(255, 215, 0, 0.05),
                /* Reduced external shadows */
                0 3px 0 #6d5220,
                0 5px 8px rgba(0, 0, 0, 0.5),
                0 8px 12px rgba(139, 69, 19, 0.2),
                0 0 10px rgba(255, 215, 0, 0.1);
        }
        .coin-pile-btn:active .mid-coin {
            transform: translateX(calc(-50% - 8px)) translateY(3px) rotate(-5deg) scale(0.98);
            background:
                /* Pressed middle coin */
                linear-gradient(120deg, #a97f33 0%, #8b6914 25%, #6d5220 50%, #4d3817 75%, #2f2f2f 100%),
                /* Dimmed highlight */
                radial-gradient(circle at 20% 25%, rgba(255, 255, 255, 0.15) 0%, transparent 30%),
                /* Minimal edge glow */
                radial-gradient(circle at 30% 30%, rgba(255, 215, 0, 0.05) 0%, transparent 15%),
                /* Base pressed color */
                radial-gradient(circle, #8b6914 0%, #6d5220 60%, #4d3817 100%);
            /* Pressed shadows */
            box-shadow:
                inset 0 0 20px rgba(0, 0, 0, 0.5),
                inset 0 0 25px rgba(255, 215, 0, 0.03),
                0 2px 0 #4d3817,
                0 4px 6px rgba(0, 0, 0, 0.4),
                0 6px 10px rgba(139, 69, 19, 0.2),
                0 0 5px rgba(255, 215, 0, 0.05);
        }
        .coin-pile-btn:active .bottom-coin {
            transform: translateX(calc(-50% + 8px)) translateY(5px) rotate(10deg) scale(0.98);
            background:
                /* Pressed bottom coin */
                linear-gradient(150deg, #8b6914 0%, #6d5220 25%, #4d3817 50%, #2f2f2f 75%, #1a1a1a 100%),
                /* Very dim highlight */
                radial-gradient(circle at 40% 20%, rgba(255, 255, 255, 0.1) 0%, transparent 25%),
                /* Minimal edge */
                radial-gradient(circle at 45% 25%, rgba(255, 215, 0, 0.03) 0%, transparent 10%),
                /* Base pressed color */
                radial-gradient(circle, #6d5220 0%, #4d3817 60%, #2f2f2f 100%);
            /* Pressed shadows */
            box-shadow:
                inset 0 0 22px rgba(0, 0, 0, 0.6),
                inset 0 0 25px rgba(255, 215, 0, 0.02),
                0 2px 0 #2f2f2f,
                0 3px 5px rgba(0, 0, 0, 0.5),
                0 5px 8px rgba(139, 69, 19, 0.25),
                0 0 3px rgba(255, 215, 0, 0.03);
        }
        .coin-pile-btn:active .left-coin {
            transform: translateX(calc(-50% - 30px)) translateY(4px) rotate(-15deg) scale(0.98);
            background:
                /* Pressed left coin */
                linear-gradient(90deg, #6d5220 0%, #4d3817 25%, #2f2f2f 50%, #1a1a1a 75%, #000000 100%),
                /* Very dim left highlight */
                radial-gradient(circle at 15% 30%, rgba(255, 255, 255, 0.1) 0%, transparent 20%),
                /* Minimal edge */
                radial-gradient(circle at 25% 35%, rgba(255, 215, 0, 0.02) 0%, transparent 10%),
                /* Base pressed color */
                radial-gradient(circle, #4d3817 0%, #2f2f2f 60%, #1a1a1a 100%);
            /* Pressed shadows */
            box-shadow:
                inset 0 0 25px rgba(0, 0, 0, 0.7),
                inset 0 0 20px rgba(255, 215, 0, 0.02),
                0 1px 0 #1a1a1a,
                0 2px 4px rgba(0, 0, 0, 0.6),
                0 3px 6px rgba(139, 69, 19, 0.3),
                0 0 2px rgba(255, 215, 0, 0.02);
        }
        .coin-pile-btn:active .right-coin {
            transform: translateX(calc(-50% + 30px)) translateY(5px) rotate(15deg) scale(0.98);
            background:
                /* Pressed right coin */
                linear-gradient(270deg, #6d5220 0%, #4d3817 25%, #2f2f2f 50%, #1a1a1a 75%, #000000 100%),
                /* Very dim right highlight */
                radial-gradient(circle at 85% 30%, rgba(255, 255, 255, 0.1) 0%, transparent 20%),
                /* Minimal edge */
                radial-gradient(circle at 75% 35%, rgba(255, 215, 0, 0.02) 0%, transparent 10%),
                /* Base pressed color */
                radial-gradient(circle, #4d3817 0%, #2f2f2f 60%, #1a1a1a 100%);
            /* Pressed shadows */
            box-shadow:
                inset 0 0 25px rgba(0, 0, 0, 0.7),
                inset 0 0 20px rgba(255, 215, 0, 0.02),
                0 1px 0 #1a1a1a,
                0 2px 4px rgba(0, 0, 0, 0.6),
                0 3px 6px rgba(139, 69, 19, 0.3),
                0 0 2px rgba(255, 215, 0, 0.02);
        }


        /* --- Style 4: Arcane Crystal Button --- */
        .crystal-btn-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: float 6s ease-in-out infinite;
        }

        .crystal-btn-wrapper::after {
            content: '';
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 20px;
            background: radial-gradient(ellipse at center, rgba(37, 150, 190, 0.4) 0%, rgba(37, 150, 190, 0.1) 70%, transparent 100%);
            border-radius: 50%;
            animation: shadowFloat 6s ease-in-out infinite;
            z-index: -1;
            pointer-events: none;
        }

        .crystal-btn {
            width: 120px;
            height: 120px;
            background:
                /* Main crystal body with enhanced depth */
                linear-gradient(135deg, #87ceeb 0%, #4fc3f7 25%, #2596be 50%, #1e88e5 75%, #1565c0 100%),
                /* Inner highlight for depth */
                radial-gradient(circle at 30% 20%, rgba(255, 255, 255, 0.4) 0%, transparent 40%),
                /* Facet reflections */
                linear-gradient(45deg, transparent 30%, rgba(255, 255, 255, 0.3) 35%, rgba(255, 255, 255, 0.1) 40%, transparent 45%),
                linear-gradient(-45deg, transparent 55%, rgba(255, 255, 255, 0.2) 60%, rgba(255, 255, 255, 0.05) 65%, transparent 70%),
                /* Base color */
                radial-gradient(circle, #4fc3f7 0%, #2596be 100%);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            font-size: 24px;
            font-weight: bold;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            line-height: 1.1;
            position: relative;
            /* Enhanced glow with multiple layers */
            box-shadow:
                /* Inner shadow for depth */
                inset 0 0 20px rgba(0, 0, 0, 0.3),
                inset 0 0 40px rgba(255, 255, 255, 0.1),
                /* Main glow */
                0 0 20px #2596be,
                0 0 40px #2596be,
                0 0 60px #81d4fa,
                0 0 80px rgba(135, 206, 235, 0.5),
                /* Outer aura */
                0 0 100px rgba(30, 136, 229, 0.3);
            transition: all 0.3s ease-in-out;
        }

        .crystal-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 100px;
            height: 100px;
            background:
                /* Core reflection */
                radial-gradient(ellipse at 25% 25%, rgba(255, 255, 255, 0.6) 0%, rgba(255, 255, 255, 0.2) 30%, transparent 60%),
                /* Secondary reflection */
                radial-gradient(ellipse at 75% 75%, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.1) 20%, transparent 40%);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            z-index: 1;
            pointer-events: none;
        }

        .crystal-btn::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background:
                /* Facet pattern overlay */
                repeating-linear-gradient(
                    45deg,
                    transparent 0px,
                    transparent 15px,
                    rgba(255, 255, 255, 0.05) 15px,
                    rgba(255, 255, 255, 0.05) 16px
                ),
                repeating-linear-gradient(
                    -45deg,
                    transparent 0px,
                    transparent 20px,
                    rgba(255, 255, 255, 0.03) 20px,
                    rgba(255, 255, 255, 0.03) 21px
                );
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            z-index: 2;
            pointer-events: none;
        }


        .crystal-btn:hover {
            transform: scale(1.08);
            background:
                /* Enhanced hover gradients */
                linear-gradient(135deg, #b3d9ff 0%, #66d9ff 25%, #4fc3f7 50%, #29b6f6 75%, #0288d1 100%),
                /* Brighter inner highlight */
                radial-gradient(circle at 25% 15%, rgba(255, 255, 255, 0.7) 0%, transparent 45%),
                /* Enhanced facet reflections */
                linear-gradient(45deg, transparent 25%, rgba(255, 255, 255, 0.5) 30%, rgba(255, 255, 255, 0.2) 35%, transparent 40%),
                linear-gradient(-45deg, transparent 60%, rgba(255, 255, 255, 0.4) 65%, rgba(255, 255, 255, 0.1) 70%, transparent 75%),
                /* Base hover color */
                radial-gradient(circle, #66d9ff 0%, #4fc3f7 100%);
            /* Enhanced hover glow */
            box-shadow:
                /* Inner depth */
                inset 0 0 25px rgba(0, 0, 0, 0.2),
                inset 0 0 50px rgba(255, 255, 255, 0.2),
                /* Main hover glow */
                0 0 30px #4fc3f7,
                0 0 60px #4fc3f7,
                0 0 90px #81d4fa,
                0 0 120px rgba(135, 206, 235, 0.7),
                0 0 150px rgba(30, 136, 229, 0.4),
                /* Pulsing outer aura */
                0 0 200px rgba(79, 195, 247, 0.3);
            animation: crystalPulse 2s ease-in-out infinite;
        }

        .crystal-btn:active {
            transform: scale(0.92);
            background:
                /* Pressed state gradients */
                linear-gradient(135deg, #64b5f6 0%, #42a5f5 25%, #2196f3 50%, #1e88e5 75%, #1976d2 100%),
                /* Dimmed inner highlight */
                radial-gradient(circle at 35% 25%, rgba(255, 255, 255, 0.2) 0%, transparent 35%),
                /* Reduced facet reflections */
                linear-gradient(45deg, transparent 35%, rgba(255, 255, 255, 0.1) 40%, rgba(255, 255, 255, 0.05) 45%, transparent 50%),
                linear-gradient(-45deg, transparent 50%, rgba(255, 255, 255, 0.08) 55%, rgba(255, 255, 255, 0.03) 60%, transparent 65%),
                /* Base pressed color */
                radial-gradient(circle, #42a5f5 0%, #2196f3 100%);
            /* Pressed state glow */
            box-shadow:
                /* Heavy inset shadow for pressed effect */
                inset 0 0 30px rgba(0, 0, 0, 0.5),
                inset 0 0 60px rgba(255, 255, 255, 0.05),
                /* Reduced external glow */
                0 0 15px #4fc3f7,
                0 0 30px #4fc3f7,
                0 0 45px #b3e5fc,
                0 0 60px rgba(135, 206, 235, 0.3);
            transition: all 0.05s ease-in-out;
        }

        @keyframes crystalPulse {
            0%, 100% {
                filter: brightness(1) saturate(1);
            }
            50% {
                filter: brightness(1.1) saturate(1.2);
            }
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        @keyframes shadowFloat {
            0% {
                width: 80px;
                height: 20px;
                opacity: 0.6;
                bottom: -40px;
            }
            50% {
                width: 120px;
                height: 30px;
                opacity: 0.3;
                bottom: -55px;
            }
            100% {
                width: 80px;
                height: 20px;
                opacity: 0.6;
                bottom: -40px;
            }
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%); opacity: 0.7; }
            70% { transform: translate(-50%, -50%); opacity: 0; }
            100% { transform: translate(-50%, -50%); opacity: 0; }
        }

        /* Custom Cursor Styles */
        .custom-cursor {
            position: fixed;
            top: 0;
            left: 0;
            width: 48px;
            height: 48px;
            z-index: 9999;
            pointer-events: none;
            transition: transform 0.05s ease-out;
        }

        .custom-cursor svg {
            width: 100%;
            height: 100%;
            transform-origin: center;
            transition: transform 0.1s ease-out;
            filter: drop-shadow(2px 2px 3px rgba(0,0,0,0.6));
        }

        /* Pulse animation for crystal cursors */
        .custom-cursor[data-shape="fireCrystal"] svg,
        .custom-cursor[data-shape="shadowCrystal"] svg,
        .custom-cursor[data-shape="shardCluster"] svg {
            animation: pulse 3s infinite ease-in-out;
        }

        @keyframes pulse {
            0% { transform: scale(0.95); }
            70% { transform: scale(1.1); }
            100% { transform: scale(0.95); }
        }

        /* Clicking animation */
        .custom-cursor.clicking svg {
            transform: scale(0.85);
        }
        .shake {
            animation: shake 0.7s ease-in-out;
            transform: translate3d(0, 0, 0);
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .objectives-overlay {
            position: absolute;
            top: -0.5rem;
            left: -0.6rem;
            right: -0.6rem;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #f9fafb;
            font-family: 'Cinzel', serif;
            font-size: 1.125rem;
            font-weight: bold;
            z-index: 10;
        }
        /* Global blur effect for visually disabling completed or disabled modules */
        .module-blur {
            filter: blur(2px);
            opacity: 0.7;
        }
        .pressed {
            transform: scale(0.95);
            transition: transform 0.1s ease-out;
        }

        .disabled {
            pointer-events: none;
            opacity: 0.6;
        }

        .disabled:hover {
            transform: none;
        }

        /* Boss Ready Confirmation Square Styling */
        #bossReadyContainer {
            animation: fadeIn 0.5s ease-in-out;
        }

        .ready-confirmation-square {
            width: 48px;
            height: 48px;
            background: linear-gradient(135deg, #374151 0%, #4b5563 50%, #6b7280 100%);
            border: 3px solid #9ca3af;
            border-radius: 8px;
            position: relative;
            cursor: pointer;
            transition: all 0.3s ease-in-out;
            box-shadow:
                inset 0 0 10px rgba(0, 0, 0, 0.5),
                0 4px 0 #374151,
                0 6px 15px rgba(0, 0, 0, 0.4);
        }

        .ready-confirmation-square:hover {
            transform: translateY(-2px);
            box-shadow:
                inset 0 0 15px rgba(0, 0, 0, 0.4),
                0 6px 0 #374151,
                0 8px 20px rgba(0, 0, 0, 0.5);
            border-color: #d1d5db;
        }

        .ready-confirmation-square:active {
            transform: translateY(2px);
            box-shadow:
                inset 0 0 20px rgba(0, 0, 0, 0.6),
                0 2px 0 #374151,
                0 4px 10px rgba(0, 0, 0, 0.4);
        }

        .ready-confirmation-square.active {
            background: linear-gradient(135deg, #065f46 0%, #047857 50%, #059669 100%);
            border-color: #10b981;
            box-shadow:
                inset 0 0 15px rgba(16, 185, 129, 0.3),
                0 4px 0 #047857,
                0 6px 15px rgba(16, 185, 129, 0.4),
                0 0 20px rgba(16, 185, 129, 0.5);
        }

        .ready-checkmark {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 24px;
            height: 24px;
            color: #10b981;
            opacity: 0;
            transition: opacity 0.3s ease-in-out;
        }

        .ready-confirmation-square.active .ready-checkmark {
            opacity: 1;
        }

        #bossReadyContainer:hover .ready-confirmation-square:not(.active) {
            border-color: #fbbf24;
            box-shadow:
                inset 0 0 12px rgba(251, 191, 36, 0.2),
                0 4px 0 #374151,
                0 6px 15px rgba(0, 0, 0, 0.4);
        }

        /* Effect Canvas and Particles */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 99;
        }

        /* Background Particle Canvas */
        #particleCanvas {
            z-index: -1;
            pointer-events: none;
            background-color: #111827;
        }

        /* Rarity Effects */
        :root {
            --common: #808080;
            --uncommon: #2ecc71;
            --rare: #3498db;
            --epic: #8e44ad;
            --legendary: #f39c12;
        }

        .rarity-prefix {
            font-size: 0.9rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            display: inline-block;
            margin-right: 0.75rem;
        }
        .rarity-prefix span {
            position: relative;
            display: inline-block;
            z-index: 1;
        }

        .common { color: var(--common); }
        .bank { color: white; }
        .uncommon {
            color: var(--uncommon);
            animation: uncommon-glow 1000s infinite ease-in-out;
        }
        @keyframes uncommon-glow {
            0%, 100% { text-shadow: 0 0 3px var(--uncommon); }
            50% { text-shadow: 0 0 8px var(--uncommon); }
        }
        .rare {
            color: var(--rare);
            animation: rare-shimmer 1000s infinite alternate;
        }
        @keyframes rare-shimmer {
            from { text-shadow: 0 0 10px var(--rare), 0 0 15px var(--rare); }
            to { text-shadow: 0 0 20px var(--rare), 0 0 30px #a9d6f5; }
        }
        .epic {
            color: var(--epic);
            animation: epic-void 1000s infinite ease-in-out;
        }
        @keyframes epic-void {
            0%, 100% {
                text-shadow: 0 0 5px #000, 0 0 8px var(--epic), 0 0 12px #c39bd3;
                transform: scale(1);
            }
            50% {
                text-shadow: 0 0 8px #000, 0 0 15px var(--epic), 0 0 25px #c39bd3;
                transform: scale(1.03);
            }
        }
        .legendary {
            color: #f7d674;
            animation: legendary-fire 1000s infinite linear;
        }
        .legendary::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 120%;
            height: 140%;
            transform: translate(-50%, -50%);
            border: 3px solid transparent;
            border-radius: 10px;
            animation: legendary-border-glow 2.5s infinite ease-in-out;
        }
        @keyframes legendary-fire {
            0%, 100% {
                text-shadow: 0 0 10px #f39c12, 0 0 20px #e67e22, 0 0 30px #d35400;
            }
            50% {
                text-shadow: 0 0 12px #f1c40f, 0 0 24px #e67e22, 0 0 36px #d35400;
            }
        }
        @keyframes legendary-border-glow {
            0%, 100% {
                border-color: #f39c12;
                box-shadow: 0 0 15px #f39c12;
            }
            50% {
                border-color: #f1c40f;
                box-shadow: 0 0 25px #f1c40f, 0 0 5px #fff inset;
            }
        }

        /* Base label styling */
        .label-container {
            background-color: #6b1a1a;
            border: 1px solid #374151;
            border-radius: 0;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        /* UI Background */
        .ui-bg {
            background-color: #18212f;
        }

        /* --- Idle Effect 5: Infernal Embers --- */
        .effect-embers {
            border-color: rgba(255, 100, 0, 0.3);
            animation: embers-glow 4s infinite ease-in-out;
        }
        .effect-embers .ember {
            position: absolute;
            background-color: #ff4500;
            border-radius: 20% 80% 40% 60% / 60% 30% 70% 40%; /* Irregular shape */
            opacity: 0;
            animation: float-ember 8s infinite linear;
            box-shadow: 0 0 5px #ff8c00, 0 0 10px #ff4500;
        }

        @keyframes embers-glow {
              0%, 100% {
                 box-shadow: 0 0 15px rgba(255, 69, 0, 0.2), 0 0 20px rgba(255, 69, 0, 0.1) inset;
             }
             50% {
                 box-shadow: 0 0 25px rgba(255, 69, 0, 0.4), 0 0 30px rgba(255, 69, 0, 0.2) inset;
             }
        }

        @keyframes float-ember {
            0% { transform: translateY(0) scale(1.2) rotate(0deg); opacity: 0; }
            20%, 80% { opacity: 0.9; }
            100% { transform: translateY(-120px) scale(0.2) rotate(360deg); opacity: 0; }
        }

        /* Bouncing Dots Transition Animation */
        .bouncing-dots-transition {
            display: flex;
            justify-content: space-around;
            align-items: flex-end;
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            z-index: 100;
        }
        .bouncing-dots-transition div {
            width: 25px;
            height: 25px;
            background-color: rgba(240, 195, 107, 0.9);
            border-radius: 50%;
            box-shadow: 0 0 20px rgba(240, 195, 107, 0.8);
            animation: bounceTransition 1.4s infinite ease-in-out both;
        }
        .bouncing-dots-transition .dot1 { animation-delay: -0.32s; }
        .bouncing-dots-transition .dot2 { animation-delay: -0.16s; }
        .bouncing-dots-transition .dot3 { animation-delay: 0s; }
        @keyframes bounceTransition {
            0%, 80%, 100% { transform: scale(0); opacity: 0.3; }
            40% { transform: scale(1.0); opacity: 1; }
        }

    </style>
</head>
<body class="ui-bg text-gray-200 overflow-auto min-h-screen">
    <audio id="backgroundMusic" src="664408__seth_makes_sounds__whimsical-melancholic-song-thing.wav" preload="auto" loop></audio>

    <!-- Loading Screen -->
    <div id="loading-screen" class="fixed inset-0 ui-bg flex items-center justify-center z-50">
        <div class="text-center">
            <img src="logo.png" alt="Gilded Syntax" class="h-16 mx-auto mb-4 object-contain">
            <div class="text-gray-400 animate-pulse">Preparing your adventure</div>
        </div>
    </div>

    <!-- Custom Cursor -->
    <div id="custom-cursor" class="custom-cursor" style="display: none;"></div>
    <!-- Custom Cursor -->
    <div id="custom-cursor" class="custom-cursor" style="display: none;"></div>

    <canvas id="particleCanvas"></canvas>
    <canvas id="effect-canvas"></canvas>

    <!-- SVG Definitions -->
    <div style="display: none;">
        <div id="crystalSVG">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
                <defs>
                    <linearGradient id="crystalGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#ffff00;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#ffd700;stop-opacity:1" />
                    </linearGradient>
                    <filter id="crystalGlow" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur stdDeviation="1.5" result="coloredBlur"/>
                        <feMerge>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                </defs>
                <g filter="url(#crystalGlow)" transform="rotate(135 16 16)">
                    <path d="M16 2 L22 12 L16 30 L10 12 Z" fill="url(#crystalGradient)" stroke="#daa520" stroke-width="1.5"/>
                    <path d="M16 2 L10 12 L16 9 Z" fill="#ffffff" opacity="0.7"/>
                    <path d="M16 2 L22 12 L16 9 Z" fill="#fffacd" opacity="0.7"/>
                </g>
            </svg>
        </div>
    </div>

    <!-- Main Game Container -->
    <div id="main-game-container" class="flex flex-col md:flex-row min-h-screen w-full max-w-7xl mx-auto p-2 md:p-4 gap-4" style="display: none;">

        <!-- Left Panel: Chat/Log and Player Stats -->
        <div class="flex flex-col w-full md:w-1/3 md:h-full gap-4">
            <!-- Game Title and Active Events -->
            <div class="ui-bg rounded-lg p-4 shadow-lg border border-gray-700 relative">
                <button id="musicIconButton" class="absolute top-2 left-2 text-white text-xl btn tooltip right" style="z-index: 2001;" data-tooltip="Toggle background music"></button>
                <div class="text-center mb-4">
                    <img src="logo.png" alt="Gilded Syntax" data-tooltip="Gilded Syntax - Clicker Adventure Game" class="h-12 md:h-16 mx-auto tooltip object-contain">
                    <p class="text-sm text-gray-400">Your journey begins...</p>
                </div>
                <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 flex justify-between items-center">
                    <span class="tooltip" data-tooltip="Active random events">Active Events</span>
                    <span class="text-xs text-gray-500" id="eventFlavorText"></span>
                </h2>
                <div id="activeEventsList" class="space-y-1 text-sm">
                    <!-- Events will be injected here -->
                </div>
            </div>

            <!-- Chat Log -->
            <div class="ui-bg rounded-lg p-4 shadow-lg flex-grow flex flex-col border border-gray-700 h-full">
                <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 flex justify-between items-center">
                    <span class="tooltip" data-tooltip="Game log and messages">Chronicle</span>
                    <button id="chronicleCollapseButton" class="btn text-sm px-2 py-1 bg-gray-700 hover:bg-gray-600 text-white rounded"><span style="font-family: monospace;"></span> Collapse</button>
                </h2>
                <div id="chatLog" class="chat-log h-72 overflow-y-auto pr-2 space-y-2 text-sm">
                    <!-- Messages will be injected here -->
                </div>
            </div>

            <!-- Player Stats -->
            <div class="ui-bg rounded-lg p-4 shadow-lg border border-gray-700">
                <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 tooltip right" data-tooltip="Your current stats and progress">Adventurer</h2>
                <div class="space-y-2 text-sm">
                    <div class="flex justify-between"><span class="tooltip right" data-tooltip="Your current adventurer title">Title:</span> <span id="playerTitle" class="font-bold text-amber-400"></span></div>
                    <div class="flex justify-between"><span class="tooltip right" data-tooltip="Your adventurer level">Level:</span> <span id="playerLevel" class="font-bold text-white"></span></div>
                    <div class="w-full bg-gray-700 rounded-full h-2 tooltip right" data-tooltip="XP progress to next level">
                        <div id="xpBar" class="bg-blue-500 h-full rounded-full transition-all duration-300" style="width: 0%"></div>
                    </div>
                    <div class="text-xs text-gray-400 mt-1" id="xpText">0 / 100</div>
                    <div class="flex justify-between"><span class="tooltip right" data-tooltip="Total essence collected">Essence:</span> <span id="playerEssence" class="font-bold text-cyan-400"></span></div>
                    <div class="flex justify-between"><span class="tooltip right" data-tooltip="Essence gained per click">Essence/Click:</span> <span id="essencePerClick" class="font-bold text-cyan-300"></span></div>
                    <div class="flex justify-between"><span class="tooltip right" data-tooltip="Essence gained passively per second">Passive Essence/sec:</span> <span id="passiveIncome" class="font-bold text-green-400"></span></div>
                    <div class="flex justify-between"><span class="tooltip right" data-tooltip="Damage dealt per attack during boss fights">Attack:</span> <span id="playerAttack" class="font-bold text-red-400"></span></div>
                    <div class="flex justify-between"><span class="tooltip right" data-tooltip="Critical hit chance">Crit Chance:</span> <span id="playerCritChance" class="font-bold text-red-400"></span></div>
                    <div class="flex justify-between"><span class="tooltip right" data-tooltip="Critical hit damage multiplier">Crit Multiplier:</span> <span id="playerCritMult" class="font-bold text-red-300"></span></div>
                    <div class="flex justify-between"><span class="tooltip right" data-tooltip="Daily login streak">Streak:</span> <span id="playerStreak" class="font-bold text-orange-400"></span></div>
                </div>
            </div>

            <!-- Achievements -->
            <div class="ui-bg rounded-lg p-4 shadow-lg border border-gray-700">
                <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 tooltip" data-tooltip="Unlocked achievements and milestones">Achievements</h2>
                <div id="achievementsList" class="space-y-1 text-sm">
                    <!-- Achievements will be injected here -->
                </div>
            </div>

            <!-- Prestige -->
            <div class="ui-bg rounded-lg p-4 shadow-lg border border-gray-700">
                <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 tooltip" data-tooltip="Prestige system for resetting progress and gaining permanent multipliers">Prestige</h2>
                <p class="text-sm text-gray-400 mb-2">Reset your progress for prestige points. Requires Level 50.</p>
                <p class="text-sm">Prestige Points: <span id="prestigePoints" class="font-bold text-purple-400"></span></p>
                <button id="prestigeButton" data-tooltip="Reset progress to gain prestige points for permanent multipliers. Requires level 50." class="bg-purple-700 hover:bg-purple-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip">Prestige</button>
                <button id="exportSaveButton" data-tooltip="Export your save data to clipboard for sharing or backup" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip">Export Save</button>
                <input id="loadSaveInput" type="text" placeholder="Paste save code here" class="bg-gray-600 text-white px-2 py-1 rounded mr-2 mt-2 w-full">
                <button id="loadSaveButton" data-tooltip="Load save data from code" class="bg-blue-700 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip mt-2">Load Save</button>
                <button id="resetProfile" data-tooltip="Reset all progress and start fresh" class="bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip">Reset Profile</button>
                <button id="debugButton" data-tooltip="Debug: Toggle essence between 1M and 0" class="bg-purple-700 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip">Debug</button>
            </div>

            <!-- Unique Viewers Counter -->
            <div class="text-xs text-gray-500 mt-2 text-center" id="viewerCounter">Unique Viewers: 1</div>
            <div class="text-xs text-gray-500 text-center">(Credits)</div>
        </div>

        <!-- Right Panel: Action, Quests, Bank -->
        <div class="flex flex-col w-full md:w-2/3 md:h-full gap-4">

            <!-- Action Area -->
            <div id="actionArea" class="ui-bg rounded-lg p-4 shadow-lg flex-grow flex flex-col justify-center items-center border border-gray-700 relative overflow-hidden min-h-[500px]">
                <div id="fps-counter" class="absolute top-2 right-2 text-white text-sm font-bold bg-black/50 px-2 py-1 rounded">FPS: 0</div>
                <!-- Boss UI will be injected here -->
                <div id="bossContainer" class="absolute inset-0 label-container effect-embers z-10 hidden flex-col justify-center items-center p-4 text-center"></div>

                <h2 id="zoneName" data-tooltip="The zone you are currently exploring" class="font-cinzel text-2xl md:text-3xl font-bold text-white mb-4 tooltip below"></h2>
                <p id="actionPrompt" title="Instructions for gathering essence in this zone" class="text-gray-400 mb-6 text-center"></p>
                <button id="actionButton" class="btn action-btn gather-mode">
                    <div class="content gather-content">
                        <div class="crystal-btn-wrapper">
                            <div class="crystal-btn">Gather</div>
                        </div>
                    </div>
                    <div class="content boss-content boss-btn">BOSS</div>
                    <div class="content attack-content attack-scale-btn">ATTACK</div>
                    <div class="content store-content coin-pile-btn">
                        <div class="coin right-coin"></div>
                        <div class="coin left-coin"></div>
                        <div class="coin bottom-coin"></div>
                        <div class="coin mid-coin"></div>
                        <div class="coin top-coin">Vault</div>
                    </div>
                </button>
                <div id="click-feedback-container" class="absolute top-0 left-0 w-full h-full pointer-events-none"></div>
                <div id="specialMechanicDisplay" class="mt-4 text-center"></div>

                <!-- Boss Ready Confirmation -->
                <div id="bossReadyContainer" class="mt-6 text-center" style="display: none;">
                    <div class="ui-bg rounded-lg p-4 shadow-lg border border-gray-600 inline-block">
                        <div class="flex items-center justify-center gap-3 text-gray-200">
                            <span class="font-cinzel text-xl text-amber-400">Ready?</span>
                            <div class="relative">
                                <button id="bossReadyButton" class="ready-confirmation-square" aria-label="Confirm ready for battle">
                                    <svg id="readyCheckmark" class="ready-checkmark" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
                                        <path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z" fill="currentColor"/>
                                    </svg>
                                </button>
                            </div>
                        </div>
                        <p class="text-sm text-gray-400 mt-2">Click to confirm you're ready for battle.</p>
                    </div>
                </div>
            </div>

            <!-- Quests/Challenges -->
            <div id="zoneObjectivesContainer" class="ui-bg rounded-lg p-4 shadow-lg border border-gray-700 transition-all duration-500 ease-in-out">
                  <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 flex justify-between items-center">
                      <span class="tooltip" data-tooltip="Current zone challenges to complete">Zone Objectives</span>
                      <span class="text-xs text-gray-500 tooltip left" id="zoneFlavorText" data-tooltip="Completed objectives / Total objectives for this zone"></span>
                  </h2>
                  <div id="questList" class="space-y-2 text-sm">
                      <!-- Quests will be injected here -->
                  </div>
            </div>
            
            <!-- Bank Mode -->
            <div id="bankContainer" class="ui-bg rounded-lg p-4 shadow-lg border border-gray-700 transition-all duration-500 ease-in-out">
                <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 flex justify-between items-center">
                    <div class="flex items-center gap-2">
                        <span class="tooltip" data-tooltip="Bank system for storing clicks">Essence Bank</span>
                        <span class="text-xs text-gray-500">Interest: +<span id="interestRate"></span>/sec | Accrued: <span id="accumulatedInterest"></span></span>
                    </div>
                    <label class="inline-flex items-center cursor-pointer tooltip" data-tooltip="Toggle bank mode to store clicks instead of generating essence">
                        <span class="mr-3 text-sm font-medium text-gray-300">Bank Mode</span>
                        <input type="checkbox" id="bankModeToggle" class="sr-only peer">
                        <div class="relative w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-600"></div>
                    </label>
                </h2>
                <p class="text-center text-sm mb-4"><span class="tooltip" data-tooltip="Clicks stored in bank for auto-clicker / Maximum clicks that can be stored">Stored Clicks: <span id="bankedClicks" class="font-bold text-green-400"></span> / <span id="bankSize" class="font-bold text-gray-400"></span></span></p>
                <div class="flex items-center gap-4 text-sm justify-center">
                    <button id="autoClickButton" data-tooltip="Toggle auto-clicker on/off. Costs 1 banked click per second." class="bg-green-700 hover:bg-green-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip">
                        Auto-Clicker: Off
                    </button>
                    <button id="passiveSurgeButton" data-tooltip="Spend 50 banked clicks to double passive essence for 60 seconds" class="bg-blue-700 hover:bg-blue-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip">
                        Passive Surge (50 Clicks)
                    </button>
                    <button id="hireCEOButton" data-tooltip="Spend 100 banked clicks to hire CEO for 2.5 minutes, providing bonus clicks on every manual click" class="bg-purple-700 hover:bg-purple-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip">
                        Hire CEO (100 Clicks)
                    </button>
                    <button id="bankInvestmentButton" data-tooltip="Spend 100 banked clicks on a risky investment: randomly quadruple one stat for 60 seconds or get no effect" class="bg-orange-700 hover:bg-orange-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip">
                        Risky Investment (100 Clicks)
                    </button>
                    <button id="convertClicksButton" data-tooltip="Convert banked clicks to essence (1 click = 2 essence)" class="bg-teal-700 hover:bg-teal-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip">
                        Convert to Essence
                    </button>
                </div>
                 <p class="text-xs text-gray-500 mt-2">Cost: 1 click/second. Generates <span id="autoClickRate"></span> essence/second.</p>
            </div>

            <!-- Upgrades -->
            <div class="ui-bg rounded-lg p-4 shadow-lg border border-gray-700">
                <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 flex justify-between items-center tooltip" data-tooltip="Permanent upgrades to boost your progress">
                    <div class="flex items-center gap-2">
                        <span>Upgrades</span>
                        <span class="text-xs text-gray-500 text-left" id="upgradeFlavor"></span>
                    </div>
                    <span class="text-xs text-gray-500">Essence: <span id="headerEssence"></span></span>
                </h2>
                <div class="space-y-2 text-sm">
                    <div class="flex justify-between items-center">
                        <span id="clickLabel">Click Power (Lv.0)</span>
                        <button id="upgradeClick" data-tooltip="Increases essence gained per click by 10% per level" class="bg-blue-700 hover:bg-blue-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (100)</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span id="passiveLabel">Passive Income (Lv.0)</span>
                        <button id="upgradePassive" data-tooltip="Increases passive essence income by 10% per level" class="bg-purple-700 hover:bg-purple-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (200)</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span id="bankLabel">Bank Capacity (Lv.0)</span>
                        <button id="upgradeBank" data-tooltip="Increases bank capacity by 10% per level" class="bg-green-700 hover:bg-green-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (150)</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span id="autoLabel">Auto-Clicker (Lv.0)</span>
                        <button id="upgradeAutoClick" data-tooltip="Increases auto-click rate by 10% per level" class="bg-red-700 hover:bg-red-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (250)</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span id="critChanceLabel">Critical Chance (Lv.0)</span>
                        <button id="upgradeCritChance" data-tooltip="Increases critical hit chance by 5% per level" class="bg-orange-700 hover:bg-orange-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (300)</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span id="critMultLabel">Critical Multiplier (Lv.0)</span>
                        <button id="upgradeCritMult" data-tooltip="Increases critical hit damage multiplier by 0.5x per level" class="bg-pink-700 hover:bg-pink-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (400)</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span id="luckLabel">Luck (Lv.0)</span>
                        <button id="upgradeLuck" data-tooltip="Increases critical hit chance by 5% per level" class="bg-indigo-700 hover:bg-indigo-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (500)</button>
                    </div>
                    <div class="flex justify-between items-center">
                                <span id="efficiencyLabel">Efficiency (Lv.0)</span>
                                <button id="upgradeEfficiency" data-tooltip="Reduces upgrade costs by 5% per level" class="bg-teal-700 hover:bg-teal-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (600)</button>
                            </div>
                    <div class="flex justify-between items-center">
                        <span id="regenerationLabel">Regeneration (Lv.0)</span>
                        <button id="upgradeRegeneration" data-tooltip="Increases passive essence rate by 10% per level" class="bg-emerald-700 hover:bg-emerald-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (700)</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span id="timeCrystalLabel">Time Crystal (Lv.0)</span>
                        <button id="upgradeTimeCrystal" data-tooltip="Increases offline progress cap by 30 minutes per level" class="bg-cyan-700 hover:bg-cyan-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (1000)</button>
                    </div>
                </div>
            </div>


            <!-- Companions -->
            <div class="ui-bg rounded-lg p-4 shadow-lg border border-gray-700">
                <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 tooltip" data-tooltip="Summon companions for bonuses">
                    <div class="flex items-center gap-2">
                        <span>Companions</span>
                        <span class="text-xs text-gray-500 text-left" id="companionFlavor"></span>
                    </div>
                </h2>
                <div id="companionsList" class="space-y-2 text-sm mb-4">
                    <!-- Companions will be injected here -->
                </div>
                <div class="space-y-2 text-sm">
                    <div class="flex justify-between items-center">
                        <span class="text-gray-500">Fire Sprite (Level: 5) (1000)</span>
                        <button id="summonFireSprite" data-tooltip="Summon Fire Sprite for +10% click power" class="bg-red-700 hover:bg-red-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Summon</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-gray-500">Water Nymph (Level: 10) (2000)</span>
                        <button id="summonWaterNymph" data-tooltip="Summon Water Nymph for +10% passive essence" class="bg-blue-700 hover:bg-blue-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Summon</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-gray-500">Earth Golem (Level: 15) (3000)</span>
                        <button id="summonEarthGolem" data-tooltip="Summon Earth Golem for +10% bank capacity" class="bg-green-700 hover:bg-green-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Summon</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-gray-500">Air Spirit (Level: 20) (4000)</span>
                        <button id="summonAirSpirit" data-tooltip="Summon Air Spirit for +10% auto-click rate" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Summon</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-gray-500">Shadow Imp (Level: 25) (5000)</span>
                        <button id="summonShadowImp" data-tooltip="Summon Shadow Imp for +5% critical chance" class="bg-purple-700 hover:bg-purple-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Summon</button>
                    </div>
                </div>
            </div>

            <!-- Relics -->
            <div class="ui-bg rounded-lg p-4 shadow-lg border border-gray-700">
                <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 tooltip" data-tooltip="Collected relics from boss fights">Relics</h2>
                <div id="relicsList" class="space-y-2 text-sm">
                    <!-- Relics will be injected here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Custom Cursor Logic
        const customCursor = document.getElementById('custom-cursor');

        function setCursor() {
            const svgElement = document.getElementById('crystalSVG');
            const svgContent = svgElement.outerHTML;
            customCursor.innerHTML = svgContent;
            customCursor.dataset.shape = 'crystal';
            customCursor.style.display = 'none'; // Hide until first mouse move
        }

        setCursor();
        // === COMBAT SCALING SYSTEM ===
        // All boss HP values and attack damage are multiplied by 10 behind the scenes
        // to work with clean integers instead of decimals/fractions.
        // This maintains balance while avoiding floating-point precision issues.
        // When adding new bosses: multiply desired HP by 10 (e.g., if you want 500 HP, set hp: 5000)
        // When modifying attack: the getAttackDamage() function handles the scaling automatically
        const ZONES = [
            {
                name: "Whispering Glade",
                actionPrompt: "The air is thick with ancient magic. Gather its essence.",
                challenges: [
                    { id: 'gather_1', description: "Gather 100 Essence", type: 'essence', requirement: 100, completed: false },
                    { id: 'gather_2', description: "Focus your power (Perform 50 clicks)", type: 'clicks', requirement: 50, completed: false }
                ],
                boss: {
                    name: "Ancient Treant",
                    hp: 500,
                    timer: 15,
                    flavorText: "The guardian of the glade awakens, its woody form groaning in protest of your presence. Strike it down before it drains your will!"
                }
            },
            {
                name: "Sunken Grotto",
                actionPrompt: "Luminescent fungi cast an eerie glow. Harvest their potent energy.",
                challenges: [
                    { id: 'gather_3', description: "Gather 1,000 Essence", type: 'essence', requirement: 1000, completed: false },
                    { id: 'gather_4', description: "Unlock deeper power (Perform 500 clicks)", type: 'clicks', requirement: 500, completed: false },
                    { id: 'upgrade_1', description: "Enhance your focus (Reach Level 5)", type: 'level', requirement: 5, completed: false }
                ],
                boss: {
                    name: "Abyssal Lurker",
                    hp: 2500,
                    timer: 20,
                    flavorText: "A creature of shimmering scales and too many eyes emerges from the depths! Its gaze is paralyzing. Act quickly!"
                }
            },
            {
                name: "Volcanic Caldera",
                actionPrompt: "The ground trembles with raw power. Channel the heart of the mountain.",
                challenges: [
                    { id: 'gather_5', description: "Gather 25,000 Essence", type: 'essence', requirement: 25000, completed: false },
                    { id: 'gather_6', description: "Endure the heat (Perform 2,000 clicks)", type: 'clicks', requirement: 2000, completed: false },
                    { id: 'upgrade_2', description: "Master your abilities (Reach Level 10)", type: 'level', requirement: 10, completed: false }
                ],
                boss: {
                    name: "Magma Elemental",
                    hp: 10000,
                    timer: 25,
                    flavorText: "The very heart of the volcano takes form, a roaring inferno of molten rock and fury! Extinguish its rage before you are consumed!"
                }
            },
             {
                name: "Celestial Peak",
                actionPrompt: "Starlight condenses into tangible energy. Weave it into your being.",
                challenges: [
                    { id: 'gather_7', description: "Gather 500,000 Essence", type: 'essence', requirement: 500000, completed: false },
                    { id: 'upgrade_3', description: "Achieve enlightenment (Reach Level 15)", type: 'level', requirement: 15, completed: false },
                    { id: 'passive_1', description: "Harness the stars passively (Gain 10,000 Essence passively)", type: 'passive', requirement: 10000, completed: false }
                ],
                boss: {
                    name: "Aetheric Wyrm",
                    hp: 50000,
                    timer: 30,
                    flavorText: "A serpent of pure starlight descends from the heavens, its form both beautiful and terrifying. Unmake this celestial guardian!"
                }
            },
            {
                name: "Void Abyss",
                actionPrompt: "The emptiness calls. Draw power from the nothingness itself.",
                challenges: [
                    { id: 'gather_8', description: "Gather 2,000,000 Essence", type: 'essence', requirement: 2000000, completed: false },
                    { id: 'gather_9', description: "Conquer the void (Perform 10,000 clicks)", type: 'clicks', requirement: 10000, completed: false },
                    { id: 'upgrade_4', description: "Transcend reality (Reach Level 25)", type: 'level', requirement: 25, completed: false },
                    { id: 'passive_2', description: "Embrace the void passively (Gain 50,000 Essence passively)", type: 'passive', requirement: 50000, completed: false }
                ],
                boss: {
                    name: "Void Devourer",
                    hp: 250000,
                    timer: 35,
                    flavorText: "A swirling vortex of absolute darkness manifests, hungry for existence itself. Defy the inevitable!"
                }
            },
            {
                name: "Eternal Forge",
                actionPrompt: "Flames of creation burn eternal. Shape destiny with molten will.",
                challenges: [
                    { id: 'gather_10', description: "Gather 10,000,000 Essence", type: 'essence', requirement: 10000000, completed: false },
                    { id: 'gather_11', description: "Forge your legend (Perform 50,000 clicks)", type: 'clicks', requirement: 50000, completed: false },
                    { id: 'upgrade_5', description: "Become the smith (Reach Level 35)", type: 'level', requirement: 35, completed: false }
                ],
                boss: {
                    name: "Primordial Smith",
                    hp: 1000000,
                    timer: 40,
                    flavorText: "The first craftsman of the universe wields hammers forged from the bones of dead gods. Prove your worth!"
                }
            },
            {
                name: "Dream Realm",
                actionPrompt: "Reality bends in slumber. Harvest the power of imagination.",
                challenges: [
                    { id: 'gather_12', description: "Gather 50,000,000 Essence", type: 'essence', requirement: 50000000, completed: false },
                    { id: 'gather_13', description: "Dream big (Perform 200,000 clicks)", type: 'clicks', requirement: 200000, completed: false },
                    { id: 'upgrade_6', description: "Master the subconscious (Reach Level 45)", type: 'level', requirement: 45, completed: false }
                ],
                boss: {
                    name: "Nightmare Weaver",
                    hp: 5000000,
                    timer: 45,
                    flavorText: "A being of pure nightmare spins webs of terror and delight. Wake from this dream before it consumes you!"
                }
            },
            {
                name: "Nexus of Power",
                actionPrompt: "All realities converge. Claim the ultimate power.",
                challenges: [
                    { id: 'gather_14', description: "Gather 250,000,000 Essence", type: 'essence', requirement: 250000000, completed: false },
                    { id: 'gather_15', description: "Unite the realms (Perform 1,000,000 clicks)", type: 'clicks', requirement: 1000000, completed: false },
                    { id: 'upgrade_7', description: "Ascend to godhood (Reach Level 55)", type: 'level', requirement: 55, completed: false }
                ],
                boss: {
                    name: "Reality Shatterer",
                    hp: 20000000,
                    timer: 50,
                    flavorText: "The final guardian, a being that exists in all times and places simultaneously. Break the cycle!"
                }
            },
            {
                name: "Etherial Abyss",
                actionPrompt: "Dive into the void between worlds. Harness the raw ether.",
                challenges: [
                    { id: 'gather_16', description: "Gather 1,500,000,000 Essence", type: 'essence', requirement: 1500000000, completed: false },
                    { id: 'gather_17', description: "Pierce the veil (Perform 5,000,000 clicks)", type: 'clicks', requirement: 5000000, completed: false },
                    { id: 'upgrade_8', description: "Become ethereal (Reach Level 65)", type: 'level', requirement: 65, completed: false },
                    { id: 'passive_3', description: "Ether flows passively (Gain 500,000 Essence passively)", type: 'passive', requirement: 500000, completed: false }
                ],
                boss: {
                    name: "Void Weaver",
                    hp: 100000000,
                    timer: 55,
                    flavorText: "A master of nothingness, weaving threads of ether into deadly patterns. Unravel its design!"
                }
            },
            {
                name: "Crystal Spire",
                actionPrompt: "Ascend the towering crystal formations. Channel their perfect geometry.",
                challenges: [
                    { id: 'gather_18', description: "Gather 10,000,000,000 Essence", type: 'essence', requirement: 10000000000, completed: false },
                    { id: 'gather_19', description: "Shape the crystals (Perform 25,000,000 clicks)", type: 'clicks', requirement: 25000000, completed: false },
                    { id: 'upgrade_9', description: "Attune to harmony (Reach Level 75)", type: 'level', requirement: 75, completed: false }
                ],
                boss: {
                    name: "Crystal Guardian",
                    hp: 500000000,
                    timer: 60,
                    flavorText: "A colossal being of living crystal, its facets refracting deadly beams of light. Shatter its form!"
                }
            },
            {
                name: "Storm Citadel",
                actionPrompt: "Weather the eternal tempest. Command the fury of the skies.",
                challenges: [
                    { id: 'gather_20', description: "Gather 75,000,000,000 Essence", type: 'essence', requirement: 75000000000, completed: false },
                    { id: 'gather_21', description: "Ride the lightning (Perform 100,000,000 clicks)", type: 'clicks', requirement: 100000000, completed: false },
                    { id: 'upgrade_10', description: "Harness the storm (Reach Level 85)", type: 'level', requirement: 85, completed: false },
                    { id: 'passive_4', description: "Thunder rumbles passively (Gain 2,500,000 Essence passively)", type: 'passive', requirement: 2500000, completed: false }
                ],
                boss: {
                    name: "Thunder Lord",
                    hp: 2500000000,
                    timer: 65,
                    flavorText: "The embodiment of electrical fury, crackling with power that could level mountains. Ground its wrath!"
                }
            },
            {
                name: "Frostbound Peaks",
                actionPrompt: "Conquer the icy summits. Forge strength from eternal winter.",
                challenges: [
                    { id: 'gather_22', description: "Gather 500,000,000,000 Essence", type: 'essence', requirement: 500000000000, completed: false },
                    { id: 'gather_23', description: "Shatter the ice (Perform 500,000,000 clicks)", type: 'clicks', requirement: 500000000, completed: false },
                    { id: 'upgrade_11', description: "Embrace the cold (Reach Level 95)", type: 'level', requirement: 95, completed: false }
                ],
                boss: {
                    name: "Ice Titan",
                    hp: 10000000000,
                    timer: 70,
                    flavorText: "A giant of frozen fury, its breath can freeze souls. Melt its icy heart!"
                }
            },
            {
                name: "Shadow Realm",
                actionPrompt: "Navigate the darkness. Master the arts of stealth and shadow.",
                challenges: [
                    { id: 'gather_24', description: "Gather 3,000,000,000,000 Essence", type: 'essence', requirement: 3000000000000, completed: false },
                    { id: 'gather_25', description: "Embrace the shadows (Perform 2,500,000,000 clicks)", type: 'clicks', requirement: 2500000000, completed: false },
                    { id: 'upgrade_12', description: "Become one with darkness (Reach Level 105)", type: 'level', requirement: 105, completed: false },
                    { id: 'passive_5', description: "Shadows whisper passively (Gain 10,000,000 Essence passively)", type: 'passive', requirement: 10000000, completed: false }
                ],
                boss: {
                    name: "Shadow Monarch",
                    hp: 50000000000,
                    timer: 75,
                    flavorText: "A ruler of darkness, commanding legions of shadow creatures. Illuminate the void!"
                }
            },
            {
                name: "Radiant Sanctuary",
                actionPrompt: "Bask in holy light. Purify your essence with divine energy.",
                challenges: [
                    { id: 'gather_26', description: "Gather 20,000,000,000,000 Essence", type: 'essence', requirement: 20000000000000, completed: false },
                    { id: 'gather_27', description: "Spread the light (Perform 10,000,000,000 clicks)", type: 'clicks', requirement: 10000000000, completed: false },
                    { id: 'upgrade_13', description: "Achieve radiance (Reach Level 115)", type: 'level', requirement: 115, completed: false }
                ],
                boss: {
                    name: "Light Seraph",
                    hp: 250000000000,
                    timer: 80,
                    flavorText: "A being of pure light, its radiance can blind and burn. Dim its eternal glow!"
                }
            },
            {
                name: "Chaos Nexus",
                actionPrompt: "Enter the heart of disorder. Bend chaos to your will.",
                challenges: [
                    { id: 'gather_28', description: "Gather 150,000,000,000,000 Essence", type: 'essence', requirement: 150000000000000, completed: false },
                    { id: 'gather_29', description: "Master the chaos (Perform 50,000,000,000 clicks)", type: 'clicks', requirement: 50000000000, completed: false },
                    { id: 'upgrade_14', description: "Control the uncontrollable (Reach Level 125)", type: 'level', requirement: 125, completed: false },
                    { id: 'passive_6', description: "Chaos swirls passively (Gain 50,000,000 Essence passively)", type: 'passive', requirement: 50000000, completed: false }
                ],
                boss: {
                    name: "Chaos Bringer",
                    hp: 1000000000000,
                    timer: 85,
                    flavorText: "The source of all disorder, a swirling mass of conflicting energies. Impose order upon chaos!"
                }
            },
            {
                name: "Time's End",
                actionPrompt: "Witness the final moments. Rewrite the flow of time itself.",
                challenges: [
                    { id: 'gather_30', description: "Gather 1,000,000,000,000,000 Essence", type: 'essence', requirement: 1000000000000000, completed: false },
                    { id: 'gather_31', description: "Rewind existence (Perform 250,000,000,000 clicks)", type: 'clicks', requirement: 250000000000, completed: false },
                    { id: 'upgrade_15', description: "Transcend time (Reach Level 135)", type: 'level', requirement: 135, completed: false }
                ],
                boss: {
                    name: "Chronos Prime",
                    hp: 5000000000000,
                    timer: 90,
                    flavorText: "The ultimate timekeeper, bending ages to its whim. Stop the clock forever!"
                }
            },
            {
                name: "Infinite Void",
                actionPrompt: "Step into eternity. Become one with the infinite.",
                challenges: [
                    { id: 'gather_32', description: "Gather 10,000,000,000,000,000 Essence", type: 'essence', requirement: 10000000000000000, completed: false },
                    { id: 'gather_33', description: "Embrace infinity (Perform 1,000,000,000,000 clicks)", type: 'clicks', requirement: 1000000000000, completed: false },
                    { id: 'upgrade_16', description: "Achieve infinity (Reach Level 145)", type: 'level', requirement: 145, completed: false },
                    { id: 'passive_7', description: "Infinity expands passively (Gain 250,000,000 Essence passively)", type: 'passive', requirement: 250000000, completed: false }
                ],
                boss: {
                    name: "Infinity Devourer",
                    hp: 25000000000000,
                    timer: 95,
                    flavorText: "A being that consumes infinities, growing stronger with each devoured universe. End its endless hunger!"
                }
            },
            {
                name: "Ultimate Pinnacle",
                actionPrompt: "Reach the absolute peak. Claim your place among the gods.",
                challenges: [
                    { id: 'gather_34', description: "Gather 100,000,000,000,000,000 Essence", type: 'essence', requirement: 100000000000000000, completed: false },
                    { id: 'gather_35', description: "Ascend to godhood (Perform 5,000,000,000,000 clicks)", type: 'clicks', requirement: 5000000000000, completed: false },
                    { id: 'upgrade_17', description: "Become ultimate (Reach Level 155)", type: 'level', requirement: 155, completed: false }
                ],
                boss: {
                    name: "God Emperor",
                    hp: 100000000000000,
                    timer: 100,
                    flavorText: "The supreme ruler of all existence, wielding power beyond comprehension. Dethrone the emperor!"
                }
            }
        ];

        // Background Particle System Variables
        const particleCanvas = document.getElementById('particleCanvas');
        const particleCtx = particleCanvas.getContext('2d');
        let particlesArray;
        let currentStyle = 'combined'; // Will be set randomly
        let mouse = {
            x: null,
            y: null,
            radius: 150
        };

        // Background Particle Class
        class Particle {
            constructor(x, y, directionX, directionY, size, color) {
                this.x = x;
                this.y = y;
                this.originX = x;
                this.originY = y;
                this.directionX = directionX;
                this.directionY = directionY;
                this.size = size;
                this.color = color;
            }

            draw() {
                particleCtx.beginPath();
                particleCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                particleCtx.fillStyle = this.color;
                particleCtx.fill();
            }

            update() {
                // Repel from mouse
                if (mouse.x !== null) {
                    let dx = mouse.x - this.x;
                    let dy = mouse.y - this.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < mouse.radius + this.size){
                       if(mouse.x < this.x && this.x < particleCanvas.width - this.size * 5) this.x += 3;
                       if(mouse.x > this.x && this.x > this.size * 5) this.x -= 3;
                       if(mouse.y < this.y && this.y < particleCanvas.height - this.size * 5) this.y += 3;
                       if(mouse.y > this.y && this.y > this.size * 5) this.y -= 3;
                    }
                }
                this.x += this.directionX;
                this.y += this.directionY;

                // Boundary check
                if (currentStyle !== 'overlay') { // Falling stars has its own boundary logic
                    if (this.x > particleCanvas.width || this.x < 0) this.directionX = -this.directionX;
                    if (this.y > particleCanvas.height || this.y < 0) this.directionY = -this.directionY;
                } else {
                    // Reset particles that fall off the bottom
                    if (this.y > particleCanvas.height + this.size) {
                        this.y = 0 - this.size;
                        this.x = Math.random() * particleCanvas.width;
                    }
                }

                this.draw();
            }
        }

        // Background Particle System Variables
        const backgroundParticleCanvas = document.getElementById('particleCanvas');
        const backgroundParticleCtx = backgroundParticleCanvas.getContext('2d');
        let backgroundParticlesArray;
        let backgroundCurrentStyle = 'combined'; // Will be set randomly
        let backgroundMouse = {
            x: null,
            y: null,
            radius: 150
        };

        // Background Particle Class
        class BackgroundParticle {
            constructor(x, y, directionX, directionY, size, color) {
                this.x = x;
                this.y = y;
                this.originX = x;
                this.originY = y;
                this.directionX = directionX;
                this.directionY = directionY;
                this.size = size;
                this.color = color;
            }

            draw() {
                backgroundParticleCtx.beginPath();
                backgroundParticleCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                backgroundParticleCtx.fillStyle = this.color;
                backgroundParticleCtx.fill();
            }

            update() {
                // Repel from mouse
                if (backgroundMouse.x !== null) {
                    let dx = backgroundMouse.x - this.x;
                    let dy = backgroundMouse.y - this.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < backgroundMouse.radius + this.size){
                       if(backgroundMouse.x < this.x && this.x < backgroundParticleCanvas.width - this.size * 5) this.x += 3;
                       if(backgroundMouse.x > this.x && this.x > this.size * 5) this.x -= 3;
                       if(backgroundMouse.y < this.y && this.y < backgroundParticleCanvas.height - this.size * 5) this.y += 3;
                       if(backgroundMouse.y > this.y && this.y > this.size * 5) this.y -= 3;
                    }
                }
                this.x += this.directionX;
                this.y += this.directionY;

                // Boundary check
                if (backgroundCurrentStyle !== 'overlay') { // Falling stars has its own boundary logic
                    if (this.x > backgroundParticleCanvas.width || this.x < 0) this.directionX = -this.directionX;
                    if (this.y > backgroundParticleCanvas.height || this.y < 0) this.directionY = -this.directionY;
                } else {
                    // Reset particles that fall off the bottom
                    if (this.y > backgroundParticleCanvas.height + this.size) {
                        this.y = 0 - this.size;
                        this.x = Math.random() * backgroundParticleCanvas.width;
                    }
                }

                this.draw();
            }
        }

        // Background Particle Functions
        function setCanvasSize() {
            backgroundParticleCanvas.width = window.innerWidth;
            backgroundParticleCanvas.height = window.innerHeight;
        }

        function initBackgroundParticles() {
            backgroundParticlesArray = [];
            let numberOfParticles = (backgroundParticleCanvas.height * backgroundParticleCanvas.width) / 9000;

            if (backgroundCurrentStyle === 'combined') {
                  for (let i = 0; i < numberOfParticles; i++) {
                     let size = (Math.random() * 2) + 1;
                     let x = (Math.random() * ((innerWidth - size * 2) - (size * 2)) + size * 2);
                     let y = (Math.random() * ((innerHeight - size * 2) - (size * 2)) + size * 2);
                     let directionX = (Math.random() * .2) - 0.1; // Slower movement
                     let directionY = (Math.random() * .2) - 0.1; // Slower movement
                     let color = 'rgba(255, 255, 255, 0.25)'; // Much more subtle opacity
                     backgroundParticlesArray.push(new BackgroundParticle(x, y, directionX, directionY, size, color));
                 }
            } else if (backgroundCurrentStyle === 'overlay') {
                // "Star Shower" style - more immersive falling stars
                const jewelColors = [
                    'rgba(255, 215, 0,', // gold
                    'rgba(255, 0, 0,', // red
                    'rgba(0, 255, 0,', // green
                    'rgba(0, 0, 255,', // blue
                    'rgba(255, 0, 255,', // magenta
                    'rgba(255, 165, 0,', // orange
                    'rgba(128, 0, 128,', // purple
                    'rgba(255, 255, 0,', // yellow
                    'rgba(0, 255, 255,', // cyan
                    'rgba(255, 255, 255,', // white for realistic stars
                ];
                for (let i = 0; i < numberOfParticles * 2.5; i++) { // Even more particles for denser shower effect
                    let size = (Math.random() * 2.5) + 0.3; // More varied sizes for realistic stars (0.3-2.8)
                    let x = Math.random() * backgroundParticleCanvas.width;
                    let y = Math.random() * backgroundParticleCanvas.height;
                    let directionX = (Math.random() * 0.4) - 0.2; // Gentle horizontal drift (-0.2 to +0.2)
                    let directionY = (Math.random() * 0.15) + 0.03; // Much slower falling speed (0.03-0.18)
                    let baseColor = jewelColors[Math.floor(Math.random() * jewelColors.length)];
                    let color = `${baseColor}${Math.random() * 0.15 + 0.1})`; // Lower opacity to match other effects (0.1-0.25)
                    backgroundParticlesArray.push(new BackgroundParticle(x, y, directionX, directionY, size, color));
                }
            }
            else if (backgroundCurrentStyle === 'style3') {
                // Half nebula particles
                for (let i = 0; i < numberOfParticles / 2; i++) {
                    let size = (Math.random() * 3.5) + 1.5; // Nebula particles are a bit larger in Style 3
                    let x = (Math.random() * ((innerWidth - size * 2) - (size * 2)) + size * 2);
                    let y = (Math.random() * ((innerHeight - size * 2) - (size * 2)) + size * 2);
                    let directionX = (Math.random() * .2) - 0.1; // Slower movement
                    let directionY = (Math.random() * .2) - 0.1; // Slower movement
                    const colors = ['rgba(236, 72, 153, 0.2)', 'rgba(139, 92, 246, 0.2)', 'rgba(59, 130, 246, 0.2)']; // Much more subtle opacity
                    let color = colors[Math.floor(Math.random() * colors.length)];
                    backgroundParticlesArray.push(new BackgroundParticle(x, y, directionX, directionY, size, color));
                }
                // Half starfield particles
                for (let i = 0; i < numberOfParticles / 2; i++) {
                    let size = (Math.random() * 2) + 1;
                    let x = (Math.random() * ((innerWidth - size * 2) - (size * 2)) + size * 2);
                    let y = (Math.random() * ((innerHeight - size * 2) - (size * 2)) + size * 2);
                    let directionX = (Math.random() * .2) - 0.1; // Slower movement
                    let directionY = (Math.random() * .2) - 0.1; // Slower movement
                    let color = `rgba(255, 255, 255, ${Math.random() * 0.15 + 0.05})`; // Much more subtle opacity
                    backgroundParticlesArray.push(new BackgroundParticle(x, y, directionX, directionY, size, color));
                }
            }
        }

        function animateBackgroundParticles() {
            requestAnimationFrame(animateBackgroundParticles);
            backgroundParticleCtx.clearRect(0, 0, innerWidth, innerHeight);

            for (let i = 0; i < backgroundParticlesArray.length; i++) {
                backgroundParticlesArray[i].update();
            }

            connectBackground();
        }

        function connectBackground() {
            let opacityValue = 1;
            let connectDistance = (backgroundParticleCanvas.width / 12) * (backgroundParticleCanvas.height / 12); // Reduced distance for fewer lines

            for (let a = 0; a < backgroundParticlesArray.length; a++) {
                for (let b = a; b < backgroundParticlesArray.length; b++) {
                    let shouldConnect = false;
                    if (backgroundCurrentStyle === 'combined') {
                        shouldConnect = true; // Connect all particles
                    } else if (backgroundCurrentStyle === 'style3') {
                        // Only connect starfield particles, but check for nebula obstructions
                        if (backgroundParticlesArray[a].color.startsWith('rgba(255,') && backgroundParticlesArray[b].color.startsWith('rgba(255,')) {
                            let isBlocked = false;
                            // Check against all other particles to see if they are a nebula particle in the way
                            for (let i = 0; i < backgroundParticlesArray.length; i++) {
                                if (i !== a && i !== b && !backgroundParticlesArray[i].color.startsWith('rgba(255,')) {
                                    if (isNebulaBlocking(backgroundParticlesArray[a], backgroundParticlesArray[b], backgroundParticlesArray[i])) {
                                        isBlocked = true;
                                        break; // Found a blocker, no need to check others
                                    }
                                }
                            }
                            if (!isBlocked) {
                                shouldConnect = true;
                            }
                        }
                    }

                    if (shouldConnect) {
                        let distance = ((backgroundParticlesArray[a].x - backgroundParticlesArray[b].x) * (backgroundParticlesArray[a].x - backgroundParticlesArray[b].x)) +
                                      ((backgroundParticlesArray[a].y - backgroundParticlesArray[b].y) * (backgroundParticlesArray[a].y - backgroundParticlesArray[b].y));

                        if (distance < connectDistance) {
                            opacityValue = 1 - (distance/20000);
                            let lineColor = `rgba(140, 180, 255, ${opacityValue * 0.4})`; // Fainter lines
                            backgroundParticleCtx.strokeStyle = lineColor;
                            backgroundParticleCtx.lineWidth = 0.5; // Thinner lines
                            backgroundParticleCtx.beginPath();
                            backgroundParticleCtx.moveTo(backgroundParticlesArray[a].x, backgroundParticlesArray[a].y);
                            backgroundParticleCtx.lineTo(backgroundParticlesArray[b].x, backgroundParticlesArray[b].y);
                            backgroundParticleCtx.stroke();
                        }
                    }
                }
            }
        }

        /**
         * Checks if a nebula particle is blocking the path between two starfield particles.
         * @param {BackgroundParticle} pA - The first starfield particle.
         * @param {BackgroundParticle} pB - The second starfield particle.
         * @param {BackgroundParticle} nebulaParticle - The potential blocking nebula particle.
         * @returns {boolean} - True if the nebula particle intersects the line segment.
         */
        function isNebulaBlocking(pA, pB, nebulaParticle) {
            const L2 = Math.pow(pB.x - pA.x, 2) + Math.pow(pB.y - pA.y, 2);
            if (L2 == 0.0) return false;

            // Find the projection of the nebula particle's center onto the line segment
            const t = Math.max(0, Math.min(1, ((nebulaParticle.x - pA.x) * (pB.x - pA.x) + (nebulaParticle.y - pA.y) * (pB.y - pA.y)) / L2));

            // Get the coordinates of the closest point on the line segment
            const closestX = pA.x + t * (pB.x - pA.x);
            const closestY = pA.y + t * (pB.y - pA.y);

            // Calculate the distance from this closest point to the nebula's center
            const dx = nebulaParticle.x - closestX;
            const dy = nebulaParticle.y - closestY;
            const distanceSquared = Math.pow(dx, 2) + Math.pow(dy, 2);

            // Check for collision by comparing distance to the nebula particle's radius (size)
            return distanceSquared < Math.pow(nebulaParticle.size, 2);
        }

        const TITLES = [
            { level: 1, name: "Neophyte" },
            { level: 5, name: "Acolyte" },
            { level: 10, name: "Mage" },
            { level: 15, name: "Archmage" },
            { level: 20, name: "Ascendant" },
            { level: 25, name: "Transcendent" },
            { level: 30, name: "Demi-God" },
            { level: 35, name: "Deity" },
            { level: 40, name: "God" },
            { level: 45, name: "Supreme Being" },
            { level: 50, name: "Overlord" },
            { level: 55, name: "Cosmic Entity" },
            { level: 60, name: "Reality Weaver" },
            { level: 70, name: "Omnipotent" },
            { level: 80, name: "Transcendent" },
            { level: 90, name: "Supreme Entity" },
            { level: 100, name: "Cosmic Overlord" },
            { level: 110, name: "Dimensional Master" },
            { level: 120, name: "Reality Bender" },
            { level: 130, name: "Infinite Being" },
            { level: 140, name: "Eternal Sovereign" },
            { level: 150, name: "Ultimate Existence" },
            { level: 160, name: "Absolute Dominator" },
            { level: 170, name: "Primordial Force" },
            { level: 180, name: "Universal Emperor" },
            { level: 190, name: "Multiversal Lord" },
            { level: 200, name: "Omniscient Creator" },
        ];

        const ACHIEVEMENTS = [
            { id: 'first_click', name: 'First Steps', description: 'Perform your first click', condition: () => gameState.totalClicks >= 1 },
            { id: 'thousand_clicks', name: 'Click Master', description: 'Perform 1,000 clicks', condition: () => gameState.totalClicks >= 1000 },
            { id: 'million_essence', name: 'Essence Hoarder', description: 'Gather 1,000,000 Essence', condition: () => gameState.essence >= 1000000 },
            { id: 'level_10', name: 'Rising Star', description: 'Reach Level 10', condition: () => gameState.level >= 10 },
            { id: 'all_zones', name: 'World Conqueror', description: 'Complete all zones', condition: () => gameState.currentZoneIndex >= ZONES.length },
            { id: 'passive_master', name: 'Idle Champion', description: 'Gain 100,000 Essence passively', condition: () => gameState.totalPassiveGained >= 100000 },
            { id: 'level_100', name: 'Century Milestone', description: 'Reach Level 100', condition: () => gameState.level >= 100 },
            { id: 'total_essence_1e12', name: 'Essence Billionaire', description: 'Gather 1,000,000,000,000 Essence', condition: () => gameState.essence >= 1000000000000 },
            { id: 'zone_10', name: 'Etherial Conqueror', description: 'Complete Etherial Abyss', condition: () => gameState.currentZoneIndex >= 9 },
            { id: 'zone_15', name: 'Chaos Master', description: 'Complete Chaos Nexus', condition: () => gameState.currentZoneIndex >= 16 },
            { id: 'zone_20', name: 'Ultimate Victor', description: 'Complete all zones', condition: () => gameState.currentZoneIndex >= 20 },
            { id: 'crit_master', name: 'Critical Expert', description: 'Upgrade Critical Chance to Level 10', condition: () => gameState.critChanceUpgradeLevel >= 10 },
            { id: 'prestige_1', name: 'First Rebirth', description: 'Prestige for the first time', condition: () => gameState.prestigePoints >= 1 },
            { id: 'speed_zone_10', name: 'Speed Conqueror', description: 'Complete Zone 10 in under 1 hour', condition: () => gameState.currentZoneIndex >= 9 && (Date.now() - gameState.startTime) < 3600000 },
            { id: 'relic_master', name: 'Relic Collector', description: 'Collect 5 relics', condition: () => gameState.relics.length >= 5 },
            { id: 'infinite_10', name: 'Infinite Explorer', description: 'Complete 10 infinite zones', condition: () => gameState.infiniteMode && gameState.currentZoneIndex >= ZONES.length + 9 },
            { id: 'streak_7', name: 'Dedicated Player', description: 'Maintain a 7-day login streak', condition: () => gameState.streak >= 7 },
        ];

        const EVENTS = [
            // Common (40% chance, short/weak)
            { id: 'essence_boost', name: 'Essence Boost', description: 'Doubles essence gain from clicks', duration: 30000, effect: 'double_click', type: 'positive', rarity: 'Common' },
            { id: 'click_penalty', name: 'Click Fatigue', description: 'Reduces click power by 25% for 20 seconds', duration: 20000, effect: 'quarter_click', type: 'negative', rarity: 'Common' },
            { id: 'minor_luck', name: 'Minor Luck', description: 'Increases luck by 10% for 30 seconds', duration: 30000, effect: 'luck_boost', type: 'positive', rarity: 'Common' },
            // Uncommon (30% chance, medium)
            { id: 'passive_surge', name: 'Passive Surge', description: 'Triples passive essence', duration: 60000, effect: 'triple_passive', type: 'positive', rarity: 'Uncommon' },
            { id: 'crit_frenzy', name: 'Critical Frenzy', description: '100% critical hit chance', duration: 20000, effect: 'max_crit', type: 'positive', rarity: 'Uncommon' },
            { id: 'essence_drain', name: 'Essence Drain', description: 'Halves passive essence for 30 seconds', duration: 30000, effect: 'half_passive', type: 'negative', rarity: 'Uncommon' },
            { id: 'bank_bonus', name: 'Bank Windfall', description: 'Doubles bank interest rate for 45 seconds', duration: 45000, effect: 'double_bank', type: 'positive', rarity: 'Uncommon' },
            // Rare (20% chance, stronger)
            { id: 'cost_reduction', name: 'Bargain Day', description: 'Halves upgrade costs', duration: 45000, effect: 'half_costs', type: 'positive', rarity: 'Rare' },
            { id: 'mega_passive', name: 'Mega Passive', description: 'Quadruples passive essence', duration: 45000, effect: 'quad_passive', type: 'positive', rarity: 'Rare' },
            { id: 'crit_storm', name: 'Critical Storm', description: '150% critical hit chance and 2x multiplier', duration: 30000, effect: 'super_crit', type: 'positive', rarity: 'Rare' },
            { id: 'essence_storm', name: 'Essence Storm', description: 'Doubles essence gain but attracts a mini-boss in 10 seconds', duration: 30000, effect: 'double_click', type: 'chained', chain: 'mini_boss', rarity: 'Rare' },
            // Epic (7% chance, very strong)
            { id: 'godlike_boost', name: 'Godlike Boost', description: 'Quintuples essence gain from clicks', duration: 60000, effect: 'quintuple_click', type: 'positive', rarity: 'Epic' },
            { id: 'infinite_crit', name: 'Infinite Critical', description: '100% critical hit chance with 3x multiplier', duration: 45000, effect: 'infinite_crit', type: 'positive', rarity: 'Epic' },
            { id: 'epic_passive', name: 'Epic Passive Surge', description: 'Decuples passive essence for 60 seconds', duration: 60000, effect: 'decuple_passive', type: 'positive', rarity: 'Epic' },
            // Legendary (3% chance, game-changing)
            { id: 'legendary_harvest', name: 'Harvest of Legends', description: 'Sextuples essence gain and passive essence', duration: 120000, effect: 'legendary_boost', type: 'positive', rarity: 'Legendary' },
            { id: 'time_warp', name: 'Time Warp', description: 'Freezes time for bosses (no timer) for 30 seconds', duration: 30000, effect: 'freeze_boss', type: 'positive', rarity: 'Legendary' },
            { id: 'ascended_luck', name: 'Ascended Luck', description: 'Guarantees rare+ drops from next boss', duration: 60000, effect: 'guarantee_rare', type: 'positive', rarity: 'Legendary' },
        ];

        const COMPANIONS = [
            { id: 'fire_sprite', name: 'Fire Sprite', description: '+10% click power', cost: 1000, effect: 'click_mult', value: 1.1, unlockReq: { level: 5 } },
            { id: 'water_nymph', name: 'Water Nymph', description: '+10% passive essence', cost: 2000, effect: 'passive_mult', value: 1.1, unlockReq: { level: 10 } },
            { id: 'earth_golem', name: 'Earth Golem', description: '+10% bank capacity', cost: 3000, effect: 'bank_mult', value: 1.1, unlockReq: { level: 15 } },
            { id: 'air_spirit', name: 'Air Spirit', description: '+10% auto-click rate', cost: 4000, effect: 'auto_mult', value: 1.1, unlockReq: { level: 20 } },
            { id: 'shadow_imp', name: 'Shadow Imp', description: '+5% critical chance', cost: 5000, effect: 'crit_chance_add', value: 0.05, unlockReq: { level: 25 } },
        ];

        const RELICS = [
            { id: 'crit_relic', name: 'Crystal of Precision', description: '+5% critical chance', effect: 'crit_chance_add', value: 0.05, rarity: 'Common' },
            { id: 'click_relic', name: 'Orb of Power', description: '+10% click power', effect: 'click_mult', value: 1.1, rarity: 'Common' },
            { id: 'passive_relic', name: 'Amulet of Flow', description: '+10% passive essence', effect: 'passive_mult', value: 1.1, rarity: 'Uncommon' },
            { id: 'luck_relic', name: 'Charm of Fortune', description: '+10% luck', effect: 'luck_mult', value: 1.1, rarity: 'Rare' },
            { id: 'efficiency_relic', name: 'Tome of Thrift', description: '+5% efficiency', effect: 'efficiency_mult', value: 1.05, rarity: 'Epic' },
            // Add more relics for variety
            { id: 'attack_relic', name: 'Blade of Echoes', description: '+15% attack damage', effect: 'attack_mult', value: 1.15, rarity: 'Rare' },
            { id: 'xp_relic', name: 'Tome of Knowledge', description: '+20% XP gain', effect: 'xp_mult', value: 1.2, rarity: 'Legendary' },
        ];

        let gameState = {
            essence: 0,
            level: 1,
            xp: 0,
            xpToNextLevel: 100,
            totalClicks: 0,
            bankedClicks: 0,
            isBankMode: false,
            isAutoClickerActive: false,
            autoClickCostPerSecond: 1,
            currentZoneIndex: 0,
            zones: JSON.parse(JSON.stringify(ZONES)), // Deep copy
            passiveIncomeRate: 0,
            lastUpdateTime: Date.now(),
            clickMultiplier: 1,
            passiveMultiplier: 1,
            totalPassiveGained: 0,
            bankMultiplier: 1,
            autoClickMultiplier: 1,
            achievements: [],
            accumulatedPassive: 0,
            lastPassiveLogTime: Date.now(),
            clickUpgradeLevel: 0,
            passiveUpgradeLevel: 0,
            bankUpgradeLevel: 0,
            autoClickUpgradeLevel: 0,
            critChanceUpgradeLevel: 0,
            critMultUpgradeLevel: 0,
            luckUpgradeLevel: 0,
            efficiencyUpgradeLevel: 0,
            regenerationUpgradeLevel: 0,
            critChance: 0,
            critMultiplier: 2,
            prestigePoints: 0,
            prestigeMultiplier: 1,
            luckMultiplier: 1,
            efficiencyMultiplier: 1,
            regenerationMultiplier: 1,
            xpMultiplier: 1,
            investmentStatBoost: null,
            investmentStatEndTime: 0,
            accumulatedBankInterest: 0,
            lastBankLogTime: Date.now(),
            totalBankInterestEarned: 0,
            totalBankInterestEarned: 0,
            passiveBoostActive: false,
            passiveBoostEndTime: 0,
            ceoActive: false,
            ceoEndTime: 0,
            lastCEOLogTime: Date.now(),
            activeEvents: [],
            companions: [],
            relics: [],
            currentDebuff: null,
            debuffEndTime: 0,
            mana: 0,
            manaMax: 0,
            manaBoostActive: false,
            manaBoostEndTime: 0,
            infiniteMode: false,
            startTime: Date.now(),
            streak: 0,
            lastLoginDate: new Date().toDateString(),
            timeCrystalUpgradeLevel: 0,
            bossFrozen: false,
            guaranteeRareDrop: false,
            fractionalBankInterest: 0,
            musicEnabled: false,
            chronicleCollapsed: false,
        };
        
        // DOM Elements
        const DOMElements = {
            chatLog: document.getElementById('chatLog'),
            playerTitle: document.getElementById('playerTitle'),
            playerLevel: document.getElementById('playerLevel'),
            playerEssence: document.getElementById('playerEssence'),
            essencePerClick: document.getElementById('essencePerClick'),
            playerAttack: document.getElementById('playerAttack'),
            passiveIncome: document.getElementById('passiveIncome'),
            playerCritChance: document.getElementById('playerCritChance'),
            playerCritMult: document.getElementById('playerCritMult'),
            playerStreak: document.getElementById('playerStreak'),
            zoneName: document.getElementById('zoneName'),
            actionPrompt: document.getElementById('actionPrompt'),
            actionButton: document.getElementById('actionButton'),
            actionButtonText: document.getElementById('actionButtonText'),
            questList: document.getElementById('questList'),
            bankModeToggle: document.getElementById('bankModeToggle'),
            bankedClicks: document.getElementById('bankedClicks'),
            bankSize: document.getElementById('bankSize'),
            autoClickButton: document.getElementById('autoClickButton'),
            autoClickCost: document.getElementById('autoClickCost'),
            autoClickRate: document.getElementById('autoClickRate'),
            passiveSurgeButton: document.getElementById('passiveSurgeButton'),
            hireCEOButton: document.getElementById('hireCEOButton'),
            bankInvestmentButton: document.getElementById('bankInvestmentButton'),
            convertClicksButton: document.getElementById('convertClicksButton'),
            bossContainer: document.getElementById('bossContainer'),
            clickFeedbackContainer: document.getElementById('click-feedback-container'),
            upgradeClick: document.getElementById('upgradeClick'),
            upgradePassive: document.getElementById('upgradePassive'),
            upgradeBank: document.getElementById('upgradeBank'),
            upgradeAutoClick: document.getElementById('upgradeAutoClick'),
            upgradeCritChance: document.getElementById('upgradeCritChance'),
            upgradeCritMult: document.getElementById('upgradeCritMult'),
            clickLabel: document.getElementById('clickLabel'),
            passiveLabel: document.getElementById('passiveLabel'),
            bankLabel: document.getElementById('bankLabel'),
            autoLabel: document.getElementById('autoLabel'),
            critChanceLabel: document.getElementById('critChanceLabel'),
            critMultLabel: document.getElementById('critMultLabel'),
            upgradeLuck: document.getElementById('upgradeLuck'),
            upgradeEfficiency: document.getElementById('upgradeEfficiency'),
            upgradeRegeneration: document.getElementById('upgradeRegeneration'),
            upgradeTimeCrystal: document.getElementById('upgradeTimeCrystal'),
            timeCrystalLabel: document.getElementById('timeCrystalLabel'),
            upgradeFlavor: document.getElementById('upgradeFlavor'),
            headerEssence: document.getElementById('headerEssence'),
            luckLabel: document.getElementById('luckLabel'),
            efficiencyLabel: document.getElementById('efficiencyLabel'),
            regenerationLabel: document.getElementById('regenerationLabel'),
            prestigeButton: document.getElementById('prestigeButton'),
            prestigePoints: document.getElementById('prestigePoints'),
            exportSaveButton: document.getElementById('exportSaveButton'),
            loadSaveInput: document.getElementById('loadSaveInput'),
            loadSaveButton: document.getElementById('loadSaveButton'),
            achievementsList: document.getElementById('achievementsList'),
            activeEventsList: document.getElementById('activeEventsList'),
            companionsList: document.getElementById('companionsList'),
            relicsList: document.getElementById('relicsList'),
            summonFireSprite: document.getElementById('summonFireSprite'),
            summonWaterNymph: document.getElementById('summonWaterNymph'),
            summonEarthGolem: document.getElementById('summonEarthGolem'),
            summonAirSpirit: document.getElementById('summonAirSpirit'),
            summonShadowImp: document.getElementById('summonShadowImp'),
            companionFlavor: document.getElementById('companionFlavor'),
            specialMechanicDisplay: document.getElementById('specialMechanicDisplay'),
            musicIconButton: document.getElementById('musicIconButton'),
            chronicleCollapseButton: document.getElementById('chronicleCollapseButton'),
            bossReadyContainer: document.getElementById('bossReadyContainer'),
            bossReadyButton: document.getElementById('bossReadyButton')
        };
        
        let bossState = {
            active: false,
            hp: 0,
            maxHp: 0,
            timer: null,
            timeLeft: 0,
            isMiniBoss: false,
        };

        let showFullEssence = false;
        let showFullBankedClicks = false;
        let previousButtonMode = '';
        let particles = [];
        let ctx;
        let canvas;
        let fps = 0;
        let frameCount = 0;
        let isReset = false;
let isTransitioning = false;

        // Wisp clumping system
        let lastClickTime = 0;
        let consecutiveClicks = 0;
        let mousePosition = { x: 0, y: 0 };

        function animateParticles() {
            if (!ctx) return; // Wait for ctx to be set
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            frameCount++;
            particles.forEach(p => {
                p.update();
                p.draw(ctx);
            });
            particles = particles.filter(p => p.life > 0 && p.x >= 0 && p.x <= canvas.width && p.y - window.scrollY >= 0 && p.y - window.scrollY <= canvas.height);
            requestAnimationFrame(animateParticles);
        }

        function shakeElements(...elements) {
            elements.forEach(el => {
                if (!el.classList.contains('shake')) {
                    el.classList.add('shake');
                    setTimeout(() => el.classList.remove('shake'), 600);
                }
            });
        }

        // --- Core Game Logic ---
        
        function handleActionClick(e) {
            if (bossState.active) {
                handleBossClick();
                bossStrike(e);
                return;
            }

            // Check if boss is ready (only if not in bank mode)
            if (!gameState.isBankMode && gameState.currentZoneIndex < gameState.zones.length) {
                const zone = gameState.zones[gameState.currentZoneIndex];
                const bossReady = zone.challenges.every(c => c.completed);
                if (bossReady) {
                    if (isTransitioning) return;
                    isTransitioning = true;
                    // Show bouncing dots transition before starting boss fight
                    showTransition('bouncing-dots', 2000, () => {
                        startBossFight();
                        isTransitioning = false;
                    });
                    return;
                }
            }

            DOMElements.actionButton.classList.remove('shake');
            void DOMElements.actionButton.offsetWidth; // Trigger reflow
            DOMElements.actionButton.classList.add('shake');

            gameStateManager.addClicks(1, 'action_click');

            if (gameState.isBankMode) {
                if (gameState.bankedClicks < getBankSize()) {
                    gameStateManager.addBankedClicks(1, 'bank_store');
                    showClickFeedback('+1 Click', 'text-white');
                    // Check if bank is now full and update UI immediately
                    if (gameState.bankedClicks >= getBankSize()) {
                        updateUI();
                    }
                } else {
                    logMessage("Your bank is full!", "system-warn");
                }
                forceWave(e);
            } else {
                // Apply special mechanic
                const zone = gameState.zones[gameState.currentZoneIndex];
                if (zone.specialMechanic) {
                    if (zone.specialMechanic.type === 'debuff') {
                        if (Math.random() < zone.specialMechanic.chance) {
                            gameState.currentDebuff = zone.specialMechanic;
                            gameState.debuffEndTime = Date.now() + zone.specialMechanic.duration;
                            logMessage(`${zone.specialMechanic.name} activated! Essence gain halved for ${zone.specialMechanic.duration / 1000} seconds.`, "system-warn");
                        }
                    } else if (zone.specialMechanic.type === 'mana') {
                        gameStateManager.addMana(zone.specialMechanic.manaPerClick, 'mana_click');
                        if (gameState.mana >= gameState.manaMax && !gameState.manaBoostActive) {
                            gameStateManager.setState('manaBoostActive', true, 'mana_boost_activate');
                            gameStateManager.setState('manaBoostEndTime', Date.now() + zone.specialMechanic.boostDuration, 'mana_boost_timer');
                            gameStateManager.setMana(0, 'mana_reset'); // Reset mana
                            logMessage(`${zone.specialMechanic.name} full! Zone-wide boost activated for ${zone.specialMechanic.boostDuration / 1000} seconds.`, "system-ok");
                        }
                    }
                }

                let essenceGained = getEssencePerClick();
                // Apply debuff
                if (gameState.currentDebuff && Date.now() < gameState.debuffEndTime) {
                    essenceGained = Math.floor(essenceGained / 2);
                }
                // Apply mana boost
                if (gameState.manaBoostActive && Date.now() < gameState.manaBoostEndTime) {
                    essenceGained = Math.floor(essenceGained * zone.specialMechanic.boostMultiplier);
                }
                let isCrit = false;
                if (Math.random() < gameState.critChance) {
                    essenceGained = Math.floor(essenceGained * gameState.critMultiplier);
                    isCrit = true;
                }
                gameStateManager.addEssence(essenceGained, 'gather');
                gainXP(2);
                showClickFeedback(`+${formatNumber(essenceGained)}${isCrit ? ' CRIT!' : ''}`, isCrit ? 'text-yellow-400' : 'text-white');

                // CEO Bonus
                if (gameState.ceoActive) {
                    let bonusEssence = getEssencePerClick();
                    // Apply debuff and boost to bonus too
                    if (gameState.currentDebuff && Date.now() < gameState.debuffEndTime) {
                        bonusEssence = Math.floor(bonusEssence / 2);
                    }
                    if (gameState.manaBoostActive && Date.now() < gameState.manaBoostEndTime) {
                        bonusEssence = Math.floor(bonusEssence * zone.specialMechanic.boostMultiplier);
                    }
                    gameStateManager.addEssence(bonusEssence, 'ceo_bonus');
                    gainXP(1);
                    showClickFeedback(`+${formatNumber(bonusEssence)} (CEO Bonus)`, 'text-yellow-400');
                    const flavorTexts = [
                        "The CEO whispered sweet nothings to the essence, coaxing it forth.",
                        "With a snap of his fingers, the CEO summoned extra power from the void.",
                        "The CEO's golden watch gleamed as he boosted your click with corporate magic.",
                        "In the boardroom of reality, the CEO approved your bonus essence.",
                        "The CEO leveraged your click for maximum shareholder value... in essence."
                    ];
                    const randomFlavor = flavorTexts[Math.floor(Math.random() * flavorTexts.length)];
                    logMessage(`CEO of Money helped you earn ${formatNumber(bonusEssence)} extra essence! "${randomFlavor}"`, "system-ok");
                }

                // Track consecutive clicks for wisp clumping
                const now = Date.now();
                if (now - lastClickTime < 500) { // 500ms window for consecutive clicks
                    consecutiveClicks++;
                } else {
                    consecutiveClicks = 1;
                }
                lastClickTime = now;

                manaWisps(e, consecutiveClicks);
            }

            updateUI();
            checkQuestCompletion();
        }

        function handleBossClick() {
            let damage = getAttackDamage();
            bossState.hp -= damage;
            showClickFeedback(`+${damage} Damage`, 'text-red-400');
            DOMElements.actionButton.classList.remove('shake');
            void DOMElements.actionButton.offsetWidth; // Trigger reflow
            DOMElements.actionButton.classList.add('shake');

            // CEO Bonus for boss
            if (gameState.ceoActive) {
                let bonusDamage = getAttackDamage();
                bossState.hp -= bonusDamage;
                showClickFeedback(`+${bonusDamage} (CEO Bonus)`, 'text-yellow-400');
                const bossFlavorTexts = [
                    "The CEO called in artillery strikes on the boss!",
                    "With a hostile takeover bid, the CEO weakened the foe.",
                    "The CEO's board meeting decided the boss's fate.",
                    "Corporate synergy amplified your attack!",
                    "The CEO leveraged the boss's weaknesses for maximum damage."
                ];
                const randomFlavor = bossFlavorTexts[Math.floor(Math.random() * bossFlavorTexts.length)];
                logMessage(`CEO of Money helped you deal ${bonusDamage} extra damage! "${randomFlavor}"`, "system-ok");
            }

            const bossHpElement = document.getElementById('bossHp');
            if (bossHpElement) bossHpElement.textContent = `${formatNumber(bossState.hp)} / ${formatNumber(bossState.maxHp)}`;

            if (bossState.hp <= 0) {
                winBossFight();
            }
        }

        function toggleBankMode() {
            if (bossState.active) {
                DOMElements.bankModeToggle.checked = false;
                logMessage("Cannot access bank mode during boss fight.", "system-warn");
                updateUI(); // Ensure button state is correct
                return;
            }
            gameStateManager.setState('isBankMode', DOMElements.bankModeToggle.checked, 'toggle_bank_mode');
            if (gameState.isBankMode) {
                gameState.originalZoneName = DOMElements.zoneName.textContent;
                gameState.originalActionPrompt = DOMElements.actionPrompt.textContent;
                DOMElements.zoneName.textContent = "Bank";
                DOMElements.actionPrompt.textContent = "Store clicks in your bank.";
            } else {
                if (gameState.originalZoneName) {
                    DOMElements.zoneName.textContent = gameState.originalZoneName;
                }
                if (gameState.originalActionPrompt) {
                    DOMElements.actionPrompt.textContent = gameState.originalActionPrompt;
                }
            }
            // Animate container swap
            const zoneEl = document.getElementById('zoneObjectivesContainer');
            const bankEl = document.getElementById('bankContainer');
            if (gameState.isBankMode) {
                zoneEl.parentNode.insertBefore(bankEl, zoneEl);
                logMessage("Bank mode activated. Clicks are now stored.", "system-ok");
            } else {
                zoneEl.parentNode.insertBefore(zoneEl, bankEl);
                logMessage("Bank mode deactivated. Clicks now generate Essence.", "system");
            }
            updateUI(); // This will immediately update button state based on new mode
        }


        function usePassiveSurge() {
            if (gameState.bankedClicks < 50 || gameState.passiveBoostActive) return;
            gameStateManager.addBankedClicks(-50, 'passive_surge');
            gameState.passiveBoostActive = true;
            gameState.passiveBoostEndTime = Date.now() + 60000;
            gameState.activeEvents.push({
                id: 'passive_surge',
                name: '(Bank) Passive Surge',
                description: 'Passive essence x2',
                startTime: Date.now(),
                endTime: Date.now() + 60000
            });
            logMessage("Passive Surge activated! Passive essence doubled for 60 seconds.", "system-ok");
            updateUI(); // Re-check button states after spending banked clicks
            DOMElements.passiveSurgeButton.classList.add('success-click');
            setTimeout(() => DOMElements.passiveSurgeButton.classList.remove('success-click'), 500);
        }

        function hireCEO() {
            if (gameState.bankedClicks < 100 || gameState.ceoActive) return;
            gameStateManager.addBankedClicks(-100, 'hire_ceo');
            gameState.ceoActive = true;
            gameState.ceoEndTime = Date.now() + 150000; // 2.5 minutes
            gameState.activeEvents.push({
                id: 'ceo_active',
                name: '(Bank) Hire CEO',
                description: 'Bonus clicks on every manual click',
                startTime: Date.now(),
                endTime: Date.now() + 150000
            });
            logMessage("Hired CEO of Money! Bonus clicks activated for 2.5 minutes.", "system-ok");
            updateUI(); // Re-check button states after spending banked clicks
            DOMElements.hireCEOButton.classList.add('success-click');
            setTimeout(() => DOMElements.hireCEOButton.classList.remove('success-click'), 500);
        }

        function useBankInvestment() {
            if (gameState.bankedClicks < 100) return;
            gameStateManager.addBankedClicks(-100, 'bank_investment');
            // Randomly select stat or no effect
            const stats = [
                { name: 'Essence per click', key: 'clickMultiplier' },
                { name: 'Passive income', key: 'passiveMultiplier' },
                { name: 'Attack damage', key: 'attackMultiplier' },
                { name: 'Critical chance', key: 'critChance' },
                { name: 'Critical multiplier', key: 'critMultiplier' },
                { name: 'no effect', key: null }
            ];
            const randomIndex = Math.floor(Math.random() * stats.length);
            const selected = stats[randomIndex];
            if (selected.key) {
                gameState.investmentStatBoost = selected.key;
                gameState.investmentStatEndTime = Date.now() + 60000; // 60 seconds
                gameState.activeEvents.push({
                    id: 'risky_investment_boost',
                    name: '(Bank) Risky Investment',
                    description: `${selected.name} x4`,
                    startTime: Date.now(),
                    endTime: Date.now() + 60000
                });
                logMessage(`Risky investment successful! ${selected.name} x4 for 60 seconds.`, "system-ok");
            } else {
                logMessage("Risky investment failed! No effect.", "system-warn");
            }
            updateUI(); // Re-check button states after spending banked clicks
            DOMElements.bankInvestmentButton.classList.add('success-click');
            setTimeout(() => DOMElements.bankInvestmentButton.classList.remove('success-click'), 500);
        }

        function convertClicksToEssence() {
            if (gameState.bankedClicks < 1) return;
            const clicksUsed = gameState.bankedClicks;
            const essenceGained = clicksUsed * 2;
            gameStateManager.addEssence(essenceGained, 'convert_clicks');
            gameStateManager.addBankedClicks(-clicksUsed, 'convert_clicks');
            logMessage(`Converted ${formatNumber(clicksUsed)} banked clicks to ${formatNumber(essenceGained)} essence!`, "system-ok");
            updateUI(); // This will re-enable the button if bank is no longer full
            DOMElements.convertClicksButton.classList.add('success-click');
            setTimeout(() => DOMElements.convertClicksButton.classList.remove('success-click'), 500);
        }

        function toggleAutoClicker() {
            gameStateManager.toggleState('isAutoClickerActive', 'toggle_auto_clicker');
            if (gameState.isAutoClickerActive) {
                logMessage("Auto-clicker activated.", "system-ok");
            } else {
                logMessage("Auto-clicker deactivated.", "system");
            }
            updateUI();
        }

        function checkQuestCompletion(allowBossTrigger = true) {
            if (gameState.currentZoneIndex >= gameState.zones.length) return;
            const zone = gameState.zones[gameState.currentZoneIndex];
            let allCompleted = true;

            zone.challenges.forEach(challenge => {
                if (challenge.completed) return;

                let isCompleted = false;
                switch (challenge.type) {
                    case 'essence':
                        if (gameState.essence >= challenge.requirement) isCompleted = true;
                        break;
                    case 'clicks':
                        if (gameState.totalClicks >= challenge.requirement) isCompleted = true;
                        break;
                    case 'level':
                           if (gameState.level >= challenge.requirement) isCompleted = true;
                        break;
                    case 'passive':
                        if (gameState.totalPassiveGained >= challenge.requirement) isCompleted = true;
                        break;
                }

                if (isCompleted) {
                    challenge.completed = true;
                    logMessage(`Objective Complete: ${challenge.description}`, "quest");
                }
            });

            zone.challenges.forEach(c => {
                if (!c.completed) allCompleted = false;
            });

            // Boss fight is now manual via button

            updateQuestList();
        }

        function startBossFight() {
            // Check if player is ready
            if (!DOMElements.bossReadyButton.classList.contains('active')) {
                logMessage("You must confirm you're ready for battle first!", "system-warn");
                shakeElements(DOMElements.bossReadyContainer);
                return;
            }

            clearAllParticles(); // Clear any lingering particles
            const zone = gameState.zones[gameState.currentZoneIndex];
            const boss = zone.boss;
            bossState.active = true;
            bossState.hp = boss.hp;
            bossState.maxHp = boss.hp;
            bossState.timeLeft = boss.timer;
            bossState.isMiniBoss = false;

            logMessage(`A powerful foe appears! The ${boss.name} blocks your path!`, "danger");
            
            // Clear any existing embers
            const existingEmbers = DOMElements.bossContainer.querySelectorAll('.ember');
            existingEmbers.forEach(e => e.remove());

            DOMElements.bossContainer.innerHTML = `
                <div class="fade-in w-full">
                    <h3 class="font-cinzel text-4xl font-bold text-orange-300 drop-shadow-lg">${boss.name}</h3>
                    <p class="text-orange-200 mt-2 mb-4">${boss.flavorText}</p>
                    <p id="bossHp" class="text-2xl font-bold text-white">${formatNumber(bossState.hp)} / ${formatNumber(bossState.maxHp)}</p>
                    <div class="w-full bg-gray-700 rounded-full h-4 mt-4 border-2 border-black/50">
                        <div id="bossTimerBar" class="bg-yellow-400 h-full rounded-full" style="width: 100%"></div>
                    </div>
                    <p id="bossTimeLeft" class="text-lg font-bold mt-2">${bossState.timeLeft}s remaining</p>
                </div>
            `;

            // --- Script for infernal embers effect ---
            const embersContainer = DOMElements.bossContainer;
            if (embersContainer) {
                for (let i = 0; i < 10; i++) {
                    const ember = document.createElement('div');
                    ember.classList.add('ember');

                    const size = Math.random() * 4 + 2; // 2px to 6px
                    ember.style.width = `${size}px`;
                    ember.style.height = `${size}px`;
                    ember.style.left = `${Math.random() * 100}%`;
                    ember.style.animationDelay = `${Math.random() * 8}s`;
                    ember.style.animationDuration = `${Math.random() * 4 + 6}s`; // 6s to 10s

                    embersContainer.appendChild(ember);
                }
            }
            DOMElements.bossContainer.classList.remove('hidden', 'absolute', 'inset-0');
            DOMElements.bossContainer.classList.add('flex');
            DOMElements.zoneName.style.display = 'none';
            DOMElements.actionPrompt.style.display = 'none';
            DOMElements.bossReadyContainer.style.display = 'none'; // Hide checkbox during boss fight

            gameState.isBankMode = false;
            DOMElements.bankModeToggle.checked = false;
            DOMElements.actionButton.className = 'btn action-btn attack-mode';

            bossState.timer = setInterval(() => {
                if (!gameState.bossFrozen) {
                    bossState.timeLeft--;
                }
                const timerBar = document.getElementById('bossTimerBar');
                const timeLeftDisplay = document.getElementById('bossTimeLeft');

                if (timerBar) timerBar.style.width = `${(bossState.timeLeft / boss.timer) * 100}%`;
                if (timeLeftDisplay) timeLeftDisplay.textContent = `${bossState.timeLeft}s remaining`;

                if (bossState.timeLeft <= 0) {
                    loseBossFight();
                }
            }, 1000);
        }

        function winBossFight() {
            clearInterval(bossState.timer);
            bossState.active = false;
            const zone = gameState.zones[gameState.currentZoneIndex];
            const boss = zone.boss;

            logMessage(`The ${boss.name} has been vanquished! The path forward is clear.`, "victory");

            // XP calculation: (boss.hp / 10) * 2 maintains original balance
            // Since boss HP is scaled 10x, we divide by 10 to get original value, then *2 for XP
            const xpGained = (boss.hp / 10) * 2;
            gainXP(xpGained);
            logMessage(`You gained ${formatNumber(xpGained)} XP for your victory!`, 'system-ok');

            // Loot drop
            const performance = bossState.timeLeft / boss.timer; // 0 to 1
            let dropChance = 0.1 + performance * 0.4; // 10% to 50%
            let forceRare = false;
            if (gameState.guaranteeRareDrop) {
                dropChance = 1; // Guarantee drop
                forceRare = true;
                gameState.guaranteeRareDrop = false; // Reset
            }
            if (Math.random() < dropChance) {
                let relicPool = RELICS;
                if (forceRare) {
                    relicPool = RELICS.filter(r => ['Rare', 'Epic', 'Legendary'].includes(r.rarity));
                }
                const relic = relicPool[Math.floor(Math.random() * relicPool.length)];
                if (!gameState.relics.some(r => r.id === relic.id)) {
                    gameState.relics.push(relic);
                    logMessage(`You found a relic: ${relic.name} - ${relic.description}!`, 'victory');
                } else {
                    logMessage(`You found a duplicate relic: ${relic.name}. It's already in your collection.`, 'system-ok');
                }
            }

            DOMElements.bossContainer.classList.add('hidden');
            DOMElements.bossContainer.classList.remove('flex');
            DOMElements.zoneName.style.display = '';
            DOMElements.actionPrompt.style.display = '';

            // Reset boss ready button after boss fight
            DOMElements.bossReadyButton.classList.remove('active');

            // Show boss ready checkbox again if boss is still ready
            let currentBossReady = false;
            if (gameState.currentZoneIndex < gameState.zones.length) {
                const zone = gameState.zones[gameState.currentZoneIndex];
                currentBossReady = zone.challenges.every(c => c.completed);
            }
            if (currentBossReady && !gameState.isBankMode) {
                DOMElements.bossReadyContainer.style.display = 'block';
            }

            DOMElements.actionButton.className = 'btn action-btn gather-mode';

            if (!bossState.isMiniBoss) {
                gameState.currentZoneIndex++;

                if (gameState.currentZoneIndex >= ZONES.length) {
                    if (!gameState.infiniteMode) {
                        gameState.infiniteMode = true;
                        logMessage("You have entered the Infinite Realms! Endless challenges await.", "victory");
                    }
                    generateInfiniteZone(gameState.currentZoneIndex);
                    loadZone();
                } else {
                    loadZone();
                }
            } else {
                logMessage("The mini-boss has been defeated! The storm clears.", "victory");
            }

            updateUI();
        }

        function loseBossFight() {
            clearInterval(bossState.timer);
            bossState.active = false;
            const zone = gameState.zones[gameState.currentZoneIndex];
            const boss = zone.boss;

            logMessage(`You were overwhelmed by the ${boss.name}. Regroup and try again.`, "danger");

            DOMElements.bossContainer.classList.add('hidden');
            DOMElements.bossContainer.classList.remove('flex');
            DOMElements.zoneName.style.display = '';
            DOMElements.actionPrompt.style.display = '';

            // Reset boss ready button after losing boss fight
            DOMElements.bossReadyButton.classList.remove('active');

            // Show boss ready checkbox again if boss is still ready
            let currentBossReady = false;
            if (gameState.currentZoneIndex < gameState.zones.length) {
                const zone = gameState.zones[gameState.currentZoneIndex];
                currentBossReady = zone.challenges.every(c => c.completed);
            }
            if (currentBossReady && !gameState.isBankMode) {
                DOMElements.bossReadyContainer.style.display = 'block';
            }

            // Keep challenges completed, just reset button to Gather
            DOMElements.actionButton.className = 'btn action-btn gather-mode';

            logMessage("Your failure has reset the zone's challenge.", "system-warn");

            updateUI();
        }


        // --- Player Progression ---
        function gainXP(amount) {
            gameStateManager.addXP(Math.floor(amount * gameState.xpMultiplier), 'xp_gain');
            while (gameState.xp >= gameState.xpToNextLevel) {
                levelUp();
            }
        }
        
        function levelUp() {
            gameStateManager.addLevel(1, 'level_up');
            gameState.xp -= gameState.xpToNextLevel;
            gameState.xpToNextLevel = Math.floor(gameState.xpToNextLevel * 1.5);
            logMessage(`You have reached Level ${gameState.level}!`, "levelup");
            updateUI();
            checkQuestCompletion();
        }
        
        function getUpgradeColor(level) {
            if (level < 10) return '#808080'; // gray
            if (level < 20) return '#2ecc71'; // green
            if (level < 30) return '#3498db'; // blue
            if (level < 40) return '#8e44ad'; // purple
            if (level < 50) return '#f39c12'; // gold
            if (level < 60) return '#e74c3c'; // crimson
            if (level < 70) return '#d35400'; // burnt orange
            if (level < 80) return '#ffffff'; // white
            if (level < 90) return '#00ffff'; // cyan
            return '#ff00ff'; // magenta
        }

        function getRarityColor(rarity) {
            switch(rarity) {
                case 'Common': return '#808080';
                case 'Uncommon': return '#2ecc71';
                case 'Rare': return '#3498db';
                case 'Epic': return '#8e44ad';
                case 'Legendary': return '#f39c12';
                default: return '#ffffff';
            }
        }

        // --- UI Updates ---
        function updateUI() {
            // Stats
            const currentTitle = getPlayerTitle();
            DOMElements.playerTitle.textContent = currentTitle;
            document.title = currentTitle + " - Gilded Syntax";
            DOMElements.playerLevel.textContent = gameState.level;
            const xpProgress = Math.min((gameState.xp / gameState.xpToNextLevel) * 100, 100);
            document.getElementById('xpBar').style.width = `${xpProgress}%`;
            document.getElementById('xpText').textContent = `${formatNumber(gameState.xp)} / ${formatNumber(gameState.xpToNextLevel)}`;
            DOMElements.playerEssence.textContent = showFullEssence ? gameState.essence.toLocaleString() : formatNumber(gameState.essence);
            DOMElements.headerEssence.textContent = gameState.essence.toLocaleString();
            DOMElements.essencePerClick.textContent = formatNumber(getEssencePerClick());
            // Display attack as integer (no decimals due to 10x scaling system)
            DOMElements.playerAttack.textContent = Math.floor(getAttackDamage());
            // Calculate effective passive income rate including boosts
            let effectivePassiveRate = gameState.passiveIncomeRate;
            if (gameState.passiveBoostActive && Date.now() < gameState.passiveBoostEndTime) {
                effectivePassiveRate *= 2;
            }
            if (gameState.investmentActive && Date.now() < gameState.investmentEndTime) {
                effectivePassiveRate *= 2;
            }
            // Apply debuff
            if (gameState.currentDebuff && Date.now() < gameState.debuffEndTime) {
                effectivePassiveRate = Math.floor(effectivePassiveRate / 2);
            }
            // Apply mana boost
            const zone = gameState.zones[gameState.currentZoneIndex];
            if (zone && zone.specialMechanic && zone.specialMechanic.type === 'mana' && gameState.manaBoostActive && Date.now() < gameState.manaBoostEndTime) {
                effectivePassiveRate = Math.floor(effectivePassiveRate * zone.specialMechanic.boostMultiplier);
            }
            DOMElements.passiveIncome.textContent = formatNumber(effectivePassiveRate);
            DOMElements.playerCritChance.textContent = (gameState.critChance * 100).toFixed(1) + '%';
            DOMElements.playerCritMult.textContent = gameState.critMultiplier.toFixed(1) + 'x';

            DOMElements.playerStreak.textContent = gameState.streak > 0 ? gameState.streak : '';

            // Bank
            DOMElements.bankedClicks.textContent = showFullBankedClicks ? gameState.bankedClicks.toLocaleString() : formatNumber(gameState.bankedClicks);
            DOMElements.bankSize.textContent = formatNumber(getBankSize());
            const interestRate = 0.001 * (1 + gameState.bankUpgradeLevel * 0.1);
            document.getElementById('interestRate').textContent = (gameState.bankedClicks * interestRate).toFixed(2);
            document.getElementById('accumulatedInterest').textContent = formatNumber(gameState.totalBankInterestEarned);
            // Update bank mode UI
            if (bossState.active) {
                DOMElements.actionButton.className = 'btn action-btn attack-mode';
            } else {
                // Check if boss is ready
                let bossReady = false;
                if (gameState.currentZoneIndex < gameState.zones.length) {
                    const zone = gameState.zones[gameState.currentZoneIndex];
                    bossReady = zone.challenges.every(c => c.completed);
                }
                if (gameState.isBankMode) {
                    DOMElements.actionButton.className = 'btn action-btn store-mode';
                } else if (bossReady) {
                    DOMElements.actionButton.className = 'btn action-btn boss-mode';
                } else {
                    DOMElements.actionButton.className = 'btn action-btn gather-mode';
                }
                // Hide action prompt when boss is ready and not in bank mode
                if (bossReady && !gameState.isBankMode) {
                    DOMElements.actionPrompt.style.display = 'none';
                    // Show boss ready checkbox
                    DOMElements.bossReadyContainer.style.display = 'block';
                } else {
                    DOMElements.actionPrompt.style.display = '';
                    // Hide boss ready checkbox
                    DOMElements.bossReadyContainer.style.display = 'none';
                }
            }
            DOMElements.bankModeToggle.checked = gameState.isBankMode;
            if (gameState.isBankMode) {
                DOMElements.zoneName.textContent = "Bank" + (gameState.bankedClicks >= getBankSize() ? " (Full)" : "");
                DOMElements.actionPrompt.textContent = "Store clicks in your bank.";
            }
            DOMElements.autoClickButton.textContent = gameState.isAutoClickerActive ? "Auto-Clicker: On" : "Auto-Clicker: Off";
            DOMElements.autoClickRate.textContent = getAutoClickRate();

            // Safety check for expired timers
            if (gameState.passiveBoostActive && Date.now() > gameState.passiveBoostEndTime) {
                gameState.passiveBoostActive = false;
            }
            if (gameState.ceoActive && Date.now() > gameState.ceoEndTime) {
                gameState.ceoActive = false;
            }

            // Update bank upgrade tooltips with cooldown indicators
            if (gameState.passiveBoostActive) {
                const timeLeft = Math.ceil((gameState.passiveBoostEndTime - Date.now()) / 1000);
                DOMElements.passiveSurgeButton.setAttribute('data-tooltip', `Active: Doubles passive essence (${timeLeft}s remaining)`);
            } else {
                DOMElements.passiveSurgeButton.setAttribute('data-tooltip', 'Spend 50 banked clicks to double passive essence for 60 seconds');
            }

            if (gameState.ceoActive) {
                const timeLeft = Math.ceil((gameState.ceoEndTime - Date.now()) / 1000);
                DOMElements.hireCEOButton.setAttribute('data-tooltip', `Active: Bonus clicks on every manual click (${timeLeft}s remaining)`);
            } else {
                DOMElements.hireCEOButton.setAttribute('data-tooltip', 'Spend 100 banked clicks to hire CEO for 2.5 minutes, providing bonus clicks on every manual click');
            }

            if (gameState.investmentStatEndTime > Date.now()) {
                const timeLeft = Math.ceil((gameState.investmentStatEndTime - Date.now()) / 1000);
                DOMElements.bankInvestmentButton.setAttribute('data-tooltip', `Active: Random stat boost (${timeLeft}s remaining)`);
            } else {
                DOMElements.bankInvestmentButton.setAttribute('data-tooltip', 'Spend 100 banked clicks on a risky investment: randomly quadruple one stat for 60 seconds or get no effect');
            }
            // Removed title to prevent duplicate tooltips with custom data-tooltip
            DOMElements.passiveSurgeButton.disabled = gameState.passiveBoostActive || gameState.bankedClicks < 50;
            DOMElements.hireCEOButton.disabled = gameState.ceoActive || gameState.bankedClicks < 100;
            DOMElements.bankInvestmentButton.disabled = gameState.bankedClicks < 100 || (gameState.investmentStatEndTime > Date.now());
            DOMElements.convertClicksButton.disabled = gameState.bankedClicks < 1;

            // Determine current button mode
            let bossReady = false;
            if (gameState.currentZoneIndex < gameState.zones.length) {
                const zone = gameState.zones[gameState.currentZoneIndex];
                bossReady = zone.challenges.every(c => c.completed);
            }
            let currentMode = 'gather-mode';
            if (bossState.active) {
                currentMode = 'attack-mode';
            } else if (gameState.isBankMode) {
                currentMode = 'store-mode';
            } else if (bossReady) {
                currentMode = 'boss-mode';
            }

            // Clear effects on button state change
            if (previousButtonMode !== currentMode) {
                clearAllParticles();
                previousButtonMode = currentMode;
            }

            DOMElements.actionButton.className = 'btn action-btn ' + currentMode;

            // Disable button if bank is full in store mode, or if boss is ready but not confirmed (but not in bank mode)
            if (gameState.isBankMode && gameState.bankedClicks >= getBankSize()) {
                DOMElements.actionButton.classList.add('disabled');
            } else if (bossReady && !gameState.isBankMode && !DOMElements.bossReadyButton.classList.contains('active')) {
                DOMElements.actionButton.classList.add('disabled');
            } else {
                DOMElements.actionButton.classList.remove('disabled');
            }

            // Update multipliers with diminishing returns after Lv.50
            gameStateManager.recalculateMultipliers('update_ui');

            // Apply temporary stat boost from risky investment
            if (gameState.investmentStatBoost && Date.now() < gameState.investmentStatEndTime) {
                gameStateManager.multiplyMultiplier(gameState.investmentStatBoost, 4, 'temporary_boost');
            } else if (gameState.investmentStatBoost) {
                gameState.investmentStatBoost = null;
            }

            // Reset multipliers that are affected by relics before applying effects
            gameStateManager.setMultiplier('attackMultiplier', 1, 'reset_multipliers');
            gameStateManager.setMultiplier('xpMultiplier', 1, 'reset_multipliers');

            // Apply companion, relic, and active event effects
            gameState.companions.forEach(companion => {
                applyCompanionEffect(companion);
            });
            gameState.relics.forEach(relic => {
                applyRelicEffect(relic);
            });
            gameState.activeEvents.forEach(event => {
                applyEventEffect(event);
            });

            // Apply temporary attack boost after relics
            if (gameState.investmentStatBoost === 'attackMultiplier' && Date.now() < gameState.investmentStatEndTime) {
                gameStateManager.multiplyMultiplier('attackMultiplier', 4, 'temporary_attack_boost');
            }

            // Update upgrade labels with rarity colors
            DOMElements.clickLabel.textContent = `Click Power (Lv.${gameState.clickUpgradeLevel})`;
            DOMElements.clickLabel.style.color = getUpgradeColor(gameState.clickUpgradeLevel);
            DOMElements.upgradeClick.textContent = `Upgrade (${formatNumber(getClickUpgradeCost())})`;
            DOMElements.passiveLabel.textContent = `Passive Income (Lv.${gameState.passiveUpgradeLevel})`;
            DOMElements.passiveLabel.style.color = getUpgradeColor(gameState.passiveUpgradeLevel);
            DOMElements.upgradePassive.textContent = `Upgrade (${formatNumber(getPassiveUpgradeCost())})`;
            DOMElements.bankLabel.textContent = `Bank Capacity (Lv.${gameState.bankUpgradeLevel})`;
            DOMElements.bankLabel.style.color = getUpgradeColor(gameState.bankUpgradeLevel);
            DOMElements.upgradeBank.textContent = `Upgrade (${formatNumber(getBankUpgradeCost())})`;
            DOMElements.autoLabel.textContent = `Auto-Clicker (Lv.${gameState.autoClickUpgradeLevel})`;
            DOMElements.autoLabel.style.color = getUpgradeColor(gameState.autoClickUpgradeLevel);
            DOMElements.upgradeAutoClick.textContent = `Upgrade (${formatNumber(getAutoClickUpgradeCost())})`;
            DOMElements.critChanceLabel.textContent = `Critical Chance (Lv.${gameState.critChanceUpgradeLevel})`;
            DOMElements.critChanceLabel.style.color = getUpgradeColor(gameState.critChanceUpgradeLevel);
            DOMElements.upgradeCritChance.textContent = `Upgrade (${formatNumber(getCritChanceUpgradeCost())})`;
            DOMElements.critMultLabel.textContent = `Critical Multiplier (Lv.${gameState.critMultUpgradeLevel})`;
            DOMElements.critMultLabel.style.color = getUpgradeColor(gameState.critMultUpgradeLevel);
            DOMElements.upgradeCritMult.textContent = `Upgrade (${formatNumber(getCritMultUpgradeCost())})`;
            DOMElements.luckLabel.textContent = `Luck (Lv.${gameState.luckUpgradeLevel})`;
            DOMElements.luckLabel.style.color = getUpgradeColor(gameState.luckUpgradeLevel);
            DOMElements.upgradeLuck.textContent = `Upgrade (${formatNumber(getLuckUpgradeCost())})`;
            DOMElements.efficiencyLabel.textContent = `Efficiency (Lv.${gameState.efficiencyUpgradeLevel})`;
            DOMElements.efficiencyLabel.style.color = getUpgradeColor(gameState.efficiencyUpgradeLevel);
            DOMElements.upgradeEfficiency.textContent = `Upgrade (${formatNumber(getEfficiencyUpgradeCost())})`;
            DOMElements.regenerationLabel.textContent = `Regeneration (Lv.${gameState.regenerationUpgradeLevel})`;
            DOMElements.regenerationLabel.style.color = getUpgradeColor(gameState.regenerationUpgradeLevel);
            DOMElements.upgradeRegeneration.textContent = `Upgrade (${formatNumber(getRegenerationUpgradeCost())})`;
            DOMElements.timeCrystalLabel.textContent = `Time Crystal (Lv.${gameState.timeCrystalUpgradeLevel})`;
            DOMElements.timeCrystalLabel.style.color = getUpgradeColor(gameState.timeCrystalUpgradeLevel);
            DOMElements.upgradeTimeCrystal.textContent = `Upgrade (${formatNumber(getTimeCrystalUpgradeCost())})`;

            // Prestige
            DOMElements.prestigePoints.textContent = formatNumber(gameState.prestigePoints);
            DOMElements.prestigeButton.disabled = gameState.level < 50;

            // Dynamic tooltips
            if (bossState.active) {
                DOMElements.actionButton.setAttribute('data-tooltip', "Attack the boss to deal damage and defeat it");
                } else if (gameState.isBankMode) {
                    DOMElements.actionButton.setAttribute('data-tooltip', "Store this click in your bank for later use");
                } else if (bossReady && !DOMElements.bossReadyButton.classList.contains('active')) {
                    DOMElements.actionButton.setAttribute('data-tooltip', "Confirm you're ready for battle first");
                } else {
                    DOMElements.actionButton.setAttribute('data-tooltip', "Click to gather essence from this zone");
                }

            updateChronicleCollapse();
            checkAchievements();
            updateAchievementsList();
            updateCompanionsList();
            updateRelicsList();
            updateSpecialMechanicDisplay();

            // Update event flavor text
            const flavorEl = document.getElementById('eventFlavorText');
            if (gameState.activeEvents.length > 0) {
                flavorEl.textContent = '';
            } else if (gameState.eventBufferCountdown > 0) {
                flavorEl.textContent = `Event Incoming in: ${gameState.eventBufferCountdown}s`;
            } else {
                flavorEl.textContent = '';
            }

            // Update music icon color
            if (gameState.musicEnabled) {
                DOMElements.musicIconButton.classList.remove('text-gray-500');
                DOMElements.musicIconButton.classList.add('text-white');
            } else {
                DOMElements.musicIconButton.classList.remove('text-white');
                DOMElements.musicIconButton.classList.add('text-gray-500');
            }

            if (!isReset && (gameState.essence > 0 || gameState.level > 1 || gameState.prestigePoints > 0)) {
                saveGame();
            }
        }
        
        function updateQuestList() {
                DOMElements.questList.classList.add('relative');
                if (gameState.currentZoneIndex >= gameState.zones.length) {
                  DOMElements.questList.innerHTML = `<p class="text-green-400">All syntax realms mastered!</p>`;
                  document.getElementById('zoneFlavorText').textContent = '';
                  return;
                }
              const zone = gameState.zones[gameState.currentZoneIndex];
              const existing = DOMElements.questList.children;
              let allCompleted = true;
             zone.challenges.forEach((challenge, index) => {
                 if (!challenge.completed) allCompleted = false;
                 let questEl;
                 if (existing[index]) {
                     questEl = existing[index];
                 } else {
                     questEl = document.createElement('div');
                     questEl.className = 'space-y-1 tooltip';
                     DOMElements.questList.appendChild(questEl);
                 }
                 questEl.setAttribute('data-tooltip', challenge.description);
                 let progress = 0;
                 let current = 0;
                 switch (challenge.type) {
                     case 'essence': current = gameState.essence; break;
                     case 'clicks': current = gameState.totalClicks; break;
                     case 'level': current = gameState.level; break;
                     case 'passive': current = gameState.totalPassiveGained; break;
                 }
                 progress = Math.min((current / challenge.requirement) * 100, 100);
                 if (challenge.completed) {
                     questEl.innerHTML = `<div class="flex justify-between"><span class="text-gray-500 line-through">${challenge.description}</span><span class="text-green-500 font-bold"></span></div>`;
                 } else {
                     questEl.innerHTML = `
                         <div>${challenge.description}</div>
                         <div class="w-full bg-gray-700 rounded-full h-2">
                             <div class="bg-blue-500 h-full rounded-full transition-all duration-300" style="width: ${progress}%"></div>
                         </div>
                         <div class="text-xs text-gray-400">${formatNumber(current)} / ${formatNumber(challenge.requirement)}</div>
                     `;
                 }
             });
             // Remove extra elements if fewer challenges
             while (existing.length > zone.challenges.length) {
                 DOMElements.questList.removeChild(existing[existing.length - 1]);
             }
             // Update flavor text
             let completedCount = 0;
             zone.challenges.forEach(c => { if (c.completed) completedCount++; });
             document.getElementById('zoneFlavorText').textContent = `${completedCount} / ${zone.challenges.length}`;
             // Blur objectives and add overlay if completed
             if (allCompleted) {
                 for (let child of DOMElements.questList.children) {
                     if (child.tagName === 'DIV') child.classList.add('module-blur');
                 }
                 const existingOverlay = DOMElements.questList.querySelector('.objectives-overlay');
                 if (existingOverlay) existingOverlay.remove();
                 const overlay = document.createElement('div');
                 overlay.className = 'objectives-overlay';
                 overlay.textContent = 'Challenge Boss To Proceed';
                 DOMElements.questList.appendChild(overlay);
             } else {
                 for (let child of DOMElements.questList.children) {
                     child.classList.remove('module-blur');
                 }
                 const existingOverlay = DOMElements.questList.querySelector('.objectives-overlay');
                 if (existingOverlay) existingOverlay.remove();
             }
         }

        function checkAchievements() {
            ACHIEVEMENTS.forEach(achievement => {
                if (!gameState.achievements.includes(achievement.id) && achievement.condition()) {
                    gameState.achievements.push(achievement.id);
                    logMessage(`Achievement Unlocked: ${achievement.name} - ${achievement.description}`, "victory");
                }
            });
        }

        function updateAchievementsList() {
            const existing = DOMElements.achievementsList.children;
            if (existing.length === ACHIEVEMENTS.length) {
                // Update existing elements to prevent tooltip flickering
                ACHIEVEMENTS.forEach((achievement, index) => {
                    const achEl = existing[index];
                    achEl.setAttribute('data-tooltip', achievement.description);
                    achEl.classList.remove('above', 'below');
                    achEl.classList.add('below');
                });
            } else {
                // Recreate if list changed
                DOMElements.achievementsList.innerHTML = '';
                ACHIEVEMENTS.forEach((achievement, index) => {
                    const achEl = document.createElement('div');
                    achEl.className = 'flex justify-between items-center text-xs tooltip';
                    achEl.classList.add('below');
                    achEl.setAttribute('data-tooltip', achievement.description);
                    if (gameState.achievements.includes(achievement.id)) {
                        achEl.innerHTML = `<span class="text-yellow-400 font-bold">${achievement.name}</span><span class="text-green-500"></span>`;
                    } else {
                        achEl.innerHTML = `<span class="text-gray-500">${achievement.name}</span><span class="text-gray-500">Locked</span>`;
                    }
                    DOMElements.achievementsList.appendChild(achEl);
                });
            }
        }

        function loadZone() {
            if (gameState.currentZoneIndex >= gameState.zones.length && !gameState.infiniteMode) return;
            if (gameState.infiniteMode && gameState.currentZoneIndex >= gameState.zones.length) {
                generateInfiniteZone(gameState.currentZoneIndex);
            }
            const zone = gameState.zones[gameState.currentZoneIndex];
            DOMElements.zoneName.textContent = zone.name;
            DOMElements.actionPrompt.textContent = zone.actionPrompt;
            logMessage(`You have entered the ${zone.name}.`, "zone");
            updateQuestList();
            // Initialize special mechanic
            if (zone.specialMechanic) {
                if (zone.specialMechanic.type === 'mana') {
                    gameState.mana = 0;
                    gameState.manaMax = zone.specialMechanic.maxMana;
                    gameState.manaBoostActive = false;
                }
            } else {
                gameState.mana = 0;
                gameState.manaMax = 0;
                gameState.manaBoostActive = false;
            }
            updateSpecialMechanicDisplay();

            // Always reset boss ready button when loading a new zone
            DOMElements.bossReadyButton.classList.remove('active');
        }

        function generateInfiniteZone(zoneIndex) {
            const baseIndex = zoneIndex - ZONES.length + 1;
            const scale = Math.pow(1.5, baseIndex);
            const zoneNames = ["Eternal Abyss", "Void Citadel", "Cosmic Forge", "Nebula Spire", "Quantum Rift", "Astral Domain", "Dimensional Nexus", "Temporal Vault"];
            const prompts = ["Harness the infinite power.", "Conquer the endless void.", "Shape reality itself.", "Navigate the cosmic currents.", "Pierce the quantum veil.", "Command the astral forces.", "Bridge the dimensions.", "Unlock the temporal secrets."];
            const bossNames = ["Infinite Guardian", "Void Overlord", "Cosmic Behemoth", "Nebula Colossus", "Quantum Leviathan", "Astral Titan", "Dimensional Horror", "Temporal Emperor"];
            const flavors = ["A being of pure infinity, growing stronger with each defeat.", "The ruler of nothingness, devouring all in its path.", "A cosmic entity that warps space and time.", "A swirling mass of stellar energy and fury.", "A creature that exists in multiple quantum states.", "A radiant figure commanding celestial armies.", "A horror that spans countless realities.", "A master of time, bending ages to its will."];

            const zone = {
                name: `${zoneNames[baseIndex % zoneNames.length]} ${baseIndex}`,
                actionPrompt: prompts[baseIndex % prompts.length],
                challenges: [
                    { id: `infinite_gather_${baseIndex}`, description: `Gather ${formatNumber(100000000000 * scale)} Essence`, type: 'essence', requirement: 100000000000 * scale, completed: false },
                    { id: `infinite_clicks_${baseIndex}`, description: `Perform ${formatNumber(1000000000 * scale)} clicks`, type: 'clicks', requirement: 1000000000 * scale, completed: false },
                    { id: `infinite_level_${baseIndex}`, description: `Reach Level ${50 + baseIndex * 10}`, type: 'level', requirement: 50 + baseIndex * 10, completed: false }
                ],
                boss: {
                    name: `${bossNames[baseIndex % bossNames.length]} ${baseIndex}`,
                    // Boss HP formula: 10000000000 * Math.pow(1.2, baseIndex)
                    // The 10000000000 is 1e9 * 10 (base HP * 10x scaling factor)
                    // Math.pow(1.2, baseIndex) provides exponential scaling for difficulty
                    hp: 10000000000 * Math.pow(1.2, baseIndex),
                    timer: 100 + baseIndex * 5,
                    flavorText: flavors[baseIndex % flavors.length]
                }
            };
            // Random special mechanic
            if (Math.random() < 0.5) {
                if (Math.random() < 0.5) {
                    zone.specialMechanic = {
                        type: "debuff",
                        name: "Infinite Mist",
                        description: `${Math.floor(10 + baseIndex)}% chance per click to halve essence gain for ${Math.floor(3 + baseIndex / 2)} seconds`,
                        chance: 0.1 + baseIndex * 0.01,
                        duration: 3000 + baseIndex * 500,
                        effect: "half_click"
                    };
                } else {
                    zone.specialMechanic = {
                        type: "mana",
                        name: "Infinite Mana",
                        description: "Build mana with clicks for a zone-wide boost",
                        maxMana: 50 + baseIndex * 10,
                        manaPerClick: 1,
                        boostMultiplier: 1.5 + baseIndex * 0.1,
                        boostDuration: 5000 + baseIndex * 500
                    };
                }
            }
            gameState.zones.push(zone);
        }

        function logMessage(message, type = "normal") {
            const msgEl = document.createElement('div');
            msgEl.classList.add('fade-in', 'flex', 'flex-col');

            const timeEl = document.createElement('span');
            timeEl.textContent = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second: '2-digit'});
            timeEl.className = 'text-white text-xs opacity-75';
            timeEl.style.fontSize = '0.6rem';

            const textEl = document.createElement('span');
            textEl.textContent = message;

            switch (type) {
                case "system": textEl.className += " text-gray-400 italic"; break;
                case "system-ok": textEl.className += " text-green-400 italic"; break;
                case "system-warn": textEl.className += " text-yellow-400 italic"; break;
                case "quest": textEl.className += " text-amber-300"; break;
                case "zone": textEl.className += " text-purple-400 font-bold"; break;
                case "levelup": textEl.className += " text-yellow-300 font-bold font-cinzel"; break;
                case "danger": textEl.className += " text-red-400 font-bold"; break;
                case "victory": textEl.className += " text-green-300 font-bold font-cinzel"; break;
                default: textEl.className += " text-gray-300"; break;
            }

            msgEl.appendChild(timeEl);
            msgEl.appendChild(textEl);

            // Check if user was at bottom before adding
            const wasAtBottom = DOMElements.chatLog.scrollTop + DOMElements.chatLog.clientHeight >= DOMElements.chatLog.scrollHeight;

            DOMElements.chatLog.appendChild(msgEl);

            // Remove old messages if exceeding limit, and adjust scroll if not at bottom
            let removedHeight = 0;
            while (DOMElements.chatLog.children.length > 20) {
                const removedEl = DOMElements.chatLog.firstChild;
                removedHeight += removedEl.offsetHeight;
                DOMElements.chatLog.removeChild(removedEl);
            }

            // Auto-scroll only if user was at bottom
            if (wasAtBottom) {
                DOMElements.chatLog.scrollTop = DOMElements.chatLog.scrollHeight;
            } else if (removedHeight > 0) {
                // Adjust scroll position to prevent view shifting when messages are removed from top
                DOMElements.chatLog.scrollTop -= removedHeight;
            }
        }
        
        function showClickFeedback(text, colorClass) {
            const feedback = document.createElement('div');
            feedback.textContent = text;
            feedback.className = `absolute font-bold text-xl pointer-events-none ${colorClass} opacity-100 transition-all duration-1000`;
            feedback.style.background = 'rgba(0, 0, 0, 0.7)';
            feedback.style.padding = '4px 8px';
            feedback.style.borderRadius = '4px';
            feedback.style.textShadow = '2px 2px 4px rgba(0, 0, 0, 0.8)';
            feedback.style.zIndex = '101';

            // Random position around the button
            const rect = DOMElements.actionButton.getBoundingClientRect();
            const containerRect = DOMElements.clickFeedbackContainer.getBoundingClientRect();

            const x = Math.random() * rect.width + (rect.left - containerRect.left);
            const y = Math.random() * rect.height + (rect.top - containerRect.top);

            feedback.style.left = `${x}px`;
            feedback.style.top = `${y}px`;

            DOMElements.clickFeedbackContainer.appendChild(feedback);

            setTimeout(() => {
                feedback.style.opacity = '0';
                feedback.style.transform = 'translateY(-50px)';
            }, 10);

            setTimeout(() => {
                feedback.remove();
            }, 1000);
        }

        // --- Transition System ---
        // Reusable transition system for delayed screen changes within specific containers
        // Usage examples:
        // showTransition('bouncing-dots', 2000, () => { /* callback after animation */ });
        // showTransition('spinner', 1000, () => { /* different transition type */ }, containerElement);
        // showTransition('bouncing-dots', 1500, () => { /* zone change */ }, document.getElementById('actionArea'));
        // Can be used anywhere in the game for delayed transitions within specific modules
        function showTransition(transitionType, duration = 2000, callback = null, container = null) {
            // Remove any existing transition
            const existingTransition = document.querySelector('.transition-overlay');
            if (existingTransition) {
                existingTransition.remove();
            }

            // Default to action area if no container specified
            const targetContainer = container || document.getElementById('actionArea');

            // Create transition overlay
            const overlay = document.createElement('div');
            overlay.className = 'transition-overlay';
            overlay.style.cssText = `
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: radial-gradient(circle at center, rgba(26, 32, 44, 0.8) 0%, rgba(26, 32, 44, 0.4) 60%, rgba(26, 32, 44, 0.1) 100%);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 100;
                pointer-events: none;
                border-radius: inherit;
            `;

            // Create transition content based on type
            let transitionContent;
            if (transitionType === 'bouncing-dots') {
                transitionContent = document.createElement('div');
                transitionContent.className = 'bouncing-dots-transition';
                transitionContent.innerHTML = `
                    <div class="dot1"></div>
                    <div class="dot2"></div>
                    <div class="dot3"></div>
                `;
            } else {
                // Default transition - simple fade
                transitionContent = document.createElement('div');
                transitionContent.style.cssText = `
                    width: 50px;
                    height: 50px;
                    border: 4px solid rgba(240, 195, 107, 0.9);
                    border-top: 4px solid transparent;
                    border-radius: 50%;
                    animation: spin 1s linear infinite;
                `;

                // Add spin animation
                if (!document.querySelector('#spin-keyframes')) {
                    const style = document.createElement('style');
                    style.id = 'spin-keyframes';
                    style.textContent = `
                        @keyframes spin {
                            0% { transform: rotate(0deg); }
                            100% { transform: rotate(360deg); }
                        }
                    `;
                    document.head.appendChild(style);
                }
            }

            overlay.appendChild(transitionContent);
            targetContainer.appendChild(overlay);

            // Remove transition after duration and call callback
            setTimeout(() => {
                if (overlay && overlay.parentNode) {
                    overlay.remove();
                }
                if (callback && typeof callback === 'function') {
                    callback();
                }
            }, duration);
        }

        // --- Utility Functions ---
        function getEssencePerClick() {
            return Math.floor((1 + Math.floor(gameState.level / 2)) * gameState.clickMultiplier * gameState.prestigeMultiplier);
        }

        // === ATTACK DAMAGE CALCULATION ===
        // Returns attack damage per boss hit, scaled by 10x for integer precision
        // Base formula: floor((essencePerClick/50 + 1) * attackMultiplier * 10)
        // The *10 ensures clean integers while maintaining balance with 10x scaled boss HP
        function getAttackDamage() {
            return Math.floor(((getEssencePerClick() / 50) + 1) * gameState.attackMultiplier * 10);
        }

        function getBankSize() {
            return Math.floor((50 + (gameState.level * 10)) * gameState.bankMultiplier * gameState.prestigeMultiplier);
        }

        function getAutoClickRate() {
            return Math.floor((1 + Math.floor(gameState.level / 5)) * gameState.autoClickMultiplier * gameState.prestigeMultiplier);
        }

        function getPassiveIncomeRate() {
            return Math.floor((Math.max(1, Math.floor(gameState.level / 5)) * Math.pow(1.2, gameState.currentZoneIndex)) * gameState.passiveMultiplier * gameState.prestigeMultiplier);
        }

        function updatePassiveIncome() {
            const now = Date.now();
            const today = new Date().toDateString();
            if (gameState.lastLoginDate !== today) {
                gameState.streak++;
                gameState.lastLoginDate = today;
                const bonus = gameState.streak * 1000;
                gameStateManager.addEssence(bonus, 'daily_login');
                logMessage(`Daily login bonus! Streak: ${gameState.streak} days. Gained ${formatNumber(bonus)} essence.`, "system-ok");
            }
            const timeDiff = (now - gameState.lastUpdateTime) / 1000; // seconds
            let passiveRate = gameState.passiveIncomeRate;
            if (gameState.passiveBoostActive && now < gameState.passiveBoostEndTime) {
                passiveRate *= 2;
            } else if (gameState.passiveBoostActive) {
                gameState.passiveBoostActive = false;
                updateUI();
            }
            // Apply debuff to passive
            if (gameState.currentDebuff && now < gameState.debuffEndTime) {
                passiveRate = Math.floor(passiveRate / 2);
            } else if (gameState.currentDebuff) {
                gameState.currentDebuff = null;
                updateUI();
            }
            // Apply mana boost to passive
            const zone = gameState.zones[gameState.currentZoneIndex];
            if (zone && zone.specialMechanic && zone.specialMechanic.type === 'mana' && gameState.manaBoostActive && now < gameState.manaBoostEndTime) {
                passiveRate = Math.floor(passiveRate * zone.specialMechanic.boostMultiplier);
            } else if (gameState.manaBoostActive) {
                gameState.manaBoostActive = false;
                updateUI();
            }
            const passiveGained = Math.floor(timeDiff * passiveRate);
            if (passiveGained > 0) {
                gameStateManager.addEssence(passiveGained, 'passive_income');
                gameState.totalPassiveGained += passiveGained;
                gameState.accumulatedPassive += passiveGained;
                gainXP(Math.floor(passiveGained / 100));
                checkQuestCompletion(false);
            }

            // Bank interest (compound, scales with bank upgrades, per second)
            let interestThisTick = gameState.bankedClicks * (0.001 * (1 + gameState.bankUpgradeLevel * 0.1)) * timeDiff;
            if (gameState.activeEvents.some(e => e.effect === 'double_bank')) {
                interestThisTick *= 2;
            }
            gameState.fractionalBankInterest += interestThisTick;
            let wholeClicks = Math.floor(gameState.fractionalBankInterest);
            if (wholeClicks > 0) {
                gameStateManager.addBankedClicks(wholeClicks, 'bank_interest');
                gameState.accumulatedBankInterest += wholeClicks;
                gameState.totalBankInterestEarned += wholeClicks;
                gameState.fractionalBankInterest -= wholeClicks;
                // Note: We don't call updateUI() here as it's called every second in the main loop
            }

            // Auto-clicker
            if (gameState.isAutoClickerActive) {
                if (gameState.bankedClicks >= gameState.autoClickCostPerSecond) {
                    gameStateManager.addBankedClicks(-gameState.autoClickCostPerSecond, 'auto_click_cost');
                    const essenceGained = getAutoClickRate();
                    gameStateManager.addEssence(essenceGained, 'auto_click');
                    gainXP(1);
                } else {
                    gameState.isAutoClickerActive = false;
                    logMessage("Auto-clicker deactivated: insufficient banked clicks.", "system-warn");
                }
            }

            gameState.lastUpdateTime = now;
            gameState.passiveIncomeRate = getPassiveIncomeRate();

            // Log accumulated passive every 10 seconds
            if (now - gameState.lastPassiveLogTime > 10000 && gameState.accumulatedPassive > 0) {
                logMessage(`You gained ${formatNumber(gameState.accumulatedPassive)} Essence from passive essence.`, "system-ok");
                gameState.accumulatedPassive = 0;
                gameState.lastPassiveLogTime = now;
            }

            // Log bank interest every 10 seconds
            if (now - gameState.lastBankLogTime > 10000 && gameState.accumulatedBankInterest > 0) {
                logMessage(`Your bank has accrued ${formatNumber(gameState.accumulatedBankInterest)} interest clicks.`, "system-ok");
                gameState.accumulatedBankInterest = 0;
                gameState.lastBankLogTime = now;
            }

            // Random event trigger (5% chance every second)
            if (Math.random() < 0.05 && gameState.activeEvents.length === 0 && !gameState.pendingEvent && Date.now() > gameState.eventCooldownEndTime) {
                triggerRandomEvent();
                gameState.nextEventCountdown = 20; // Reset countdown on trigger
            }

            // Update event buffer
            if (gameState.eventBufferCountdown > 0) {
                gameState.eventBufferCountdown--;
                if (gameState.eventBufferCountdown <= 0) {
                    activatePendingEvent();
                }
            }

            // Update event countdown
            if (gameState.nextEventCountdown > 0) {
                gameState.nextEventCountdown--;
            }

            // Update active events
            updateActiveEvents();
        }

        function buyClickUpgrade() {
            const cost = getClickUpgradeCost();
            if (gameState.essence >= cost) {
                gameStateManager.addEssence(-cost, 'click_upgrade');
                gameState.clickUpgradeLevel++;
                logMessage("Click Power upgraded! Essence per click increased.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.clickLabel, DOMElements.upgradeClick);
            }
        }

        function buyPassiveUpgrade() {
            const cost = getPassiveUpgradeCost();
            if (gameState.essence >= cost) {
                gameStateManager.addEssence(-cost, 'passive_upgrade');
                gameState.passiveUpgradeLevel++;
                logMessage("Passive Income upgraded! Passive income increased.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
                DOMElements.upgradePassive.classList.add('success-click');
                setTimeout(() => DOMElements.upgradePassive.classList.remove('success-click'), 500);
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.passiveLabel, DOMElements.upgradePassive);
            }
        }

        function buyBankUpgrade() {
            const cost = getBankUpgradeCost();
            if (gameState.essence >= cost) {
                gameStateManager.addEssence(-cost, 'bank_upgrade');
                gameState.bankUpgradeLevel++;
                logMessage("Bank Capacity upgraded! Bank size increased.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
                DOMElements.upgradeBank.classList.add('success-click');
                setTimeout(() => DOMElements.upgradeBank.classList.remove('success-click'), 500);
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.bankLabel, DOMElements.upgradeBank);
            }
        }

        function buyAutoClickUpgrade() {
            const cost = getAutoClickUpgradeCost();
            if (gameState.essence >= cost) {
                gameStateManager.addEssence(-cost, 'auto_click_upgrade');
                gameState.autoClickUpgradeLevel++;
                logMessage("Auto-Clicker upgraded! Auto-click rate increased.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
                DOMElements.upgradeAutoClick.classList.add('success-click');
                setTimeout(() => DOMElements.upgradeAutoClick.classList.remove('success-click'), 500);
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.autoLabel, DOMElements.upgradeAutoClick);
            }
        }

        function buyCritChanceUpgrade() {
            const cost = getCritChanceUpgradeCost();
            if (gameState.essence >= cost) {
                gameStateManager.addEssence(-cost, 'crit_chance_upgrade');
                gameState.critChanceUpgradeLevel++;
                logMessage("Critical Chance upgraded! Critical hit chance increased.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
                DOMElements.upgradeCritChance.classList.add('success-click');
                setTimeout(() => DOMElements.upgradeCritChance.classList.remove('success-click'), 500);
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.critChanceLabel, DOMElements.upgradeCritChance);
            }
        }

        function buyCritMultUpgrade() {
            const cost = getCritMultUpgradeCost();
            if (gameState.essence >= cost) {
                gameStateManager.addEssence(-cost, 'crit_mult_upgrade');
                gameState.critMultUpgradeLevel++;
                logMessage("Critical Multiplier upgraded! Critical damage increased.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
                DOMElements.upgradeCritMult.classList.add('success-click');
                setTimeout(() => DOMElements.upgradeCritMult.classList.remove('success-click'), 500);
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.critMultLabel, DOMElements.upgradeCritMult);
            }
        }

        function buyLuckUpgrade() {
            const cost = getLuckUpgradeCost();
            if (gameState.essence >= cost) {
                gameStateManager.addEssence(-cost, 'luck_upgrade');
                gameState.luckUpgradeLevel++;
                logMessage("Luck upgraded! Critical hit chance increased.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
                DOMElements.upgradeLuck.classList.add('success-click');
                setTimeout(() => DOMElements.upgradeLuck.classList.remove('success-click'), 500);
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.luckLabel, DOMElements.upgradeLuck);
            }
        }

        function buyEfficiencyUpgrade() {
            const cost = getEfficiencyUpgradeCost();
            if (gameState.essence >= cost) {
                gameStateManager.addEssence(-cost, 'efficiency_upgrade');
                gameState.efficiencyUpgradeLevel++;
                logMessage("Efficiency upgraded! Upgrade costs reduced.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
                DOMElements.upgradeEfficiency.classList.add('success-click');
                setTimeout(() => DOMElements.upgradeEfficiency.classList.remove('success-click'), 500);
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.efficiencyLabel, DOMElements.upgradeEfficiency);
            }
        }

        function buyRegenerationUpgrade() {
            const cost = getRegenerationUpgradeCost();
            if (gameState.essence >= cost) {
                gameStateManager.addEssence(-cost, 'regeneration_upgrade');
                gameState.regenerationUpgradeLevel++;
                logMessage("Regeneration upgraded! Passive income increased.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
                DOMElements.upgradeRegeneration.classList.add('success-click');
                setTimeout(() => DOMElements.upgradeRegeneration.classList.remove('success-click'), 500);
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.regenerationLabel, DOMElements.upgradeRegeneration);
            }
        }

        function buyTimeCrystalUpgrade() {
            const cost = getTimeCrystalUpgradeCost();
            if (gameState.essence >= cost) {
                gameStateManager.addEssence(-cost, 'time_crystal_upgrade');
                gameState.timeCrystalUpgradeLevel++;
                logMessage("Time Crystal upgraded! Offline progress cap increased.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
                DOMElements.upgradeTimeCrystal.classList.add('success-click');
                setTimeout(() => DOMElements.upgradeTimeCrystal.classList.remove('success-click'), 500);
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.timeCrystalLabel, DOMElements.upgradeTimeCrystal);
            }
        }

        function prestige() {
            if (gameState.level < 50) return;
            const pointsGained = Math.floor(gameState.level / 10);
            gameStateManager.addPrestigePoints(pointsGained, 'prestige');
            gameState.prestigeMultiplier = 1 + gameState.prestigePoints * 0.01;
            // Reset
            gameState.level = 1;
            gameState.xp = 0;
            gameState.xpToNextLevel = 100;
            gameState.essence = 0;
            gameState.totalClicks = 0;
            gameState.bankedClicks = 0;
            gameState.currentZoneIndex = 0;
            gameState.zones = JSON.parse(JSON.stringify(ZONES));
            gameState.passiveIncomeRate = 0;
            gameState.totalPassiveGained = 0;
            gameState.accumulatedPassive = 0;
            gameState.lastPassiveLogTime = Date.now();
            gameState.activeEvents = [];
            gameState.companions = [];
            logMessage(`You have prestiged! Gained ${pointsGained} prestige points. Multiplier increased to ${gameState.prestigeMultiplier.toFixed(2)}x`, "victory");
            loadZone();
            updateUI();
            DOMElements.prestigeButton.classList.add('success-click');
            setTimeout(() => DOMElements.prestigeButton.classList.remove('success-click'), 500);
        }

        function exportSave() {
            const saveData = btoa(JSON.stringify(gameState));
            navigator.clipboard.writeText(saveData).then(() => {
                logMessage("Save code copied to clipboard! Share this code to transfer your save.", "system-ok");
            }).catch(() => {
                logMessage("Failed to copy save code. Please check clipboard permissions.", "system-warn");
            });
        }

        function loadSave() {
            const code = DOMElements.loadSaveInput.value.trim();
            if (!code) {
                logMessage("Please enter a save code.", "system-warn");
                return;
            }
            try {
                const decoded = atob(code);
                const loadedState = JSON.parse(decoded);
                // Basic validation
                if (typeof loadedState !== 'object' || !loadedState.essence) {
                    throw new Error("Invalid save data");
                }
                // Merge the loaded state
                gameState = { ...gameState, ...loadedState };
                // Ensure new properties are initialized (same as loadGame)
                if (typeof gameState.accumulatedPassive === 'undefined') gameState.accumulatedPassive = 0;
                if (typeof gameState.lastPassiveLogTime === 'undefined') gameState.lastPassiveLogTime = Date.now();
                if (typeof gameState.clickUpgradeLevel === 'undefined') gameState.clickUpgradeLevel = 0;
                if (typeof gameState.passiveUpgradeLevel === 'undefined') gameState.passiveUpgradeLevel = 0;
                if (typeof gameState.bankUpgradeLevel === 'undefined') gameState.bankUpgradeLevel = 0;
                if (typeof gameState.autoClickUpgradeLevel === 'undefined') gameState.autoClickUpgradeLevel = 0;
                if (typeof gameState.critChanceUpgradeLevel === 'undefined') gameState.critChanceUpgradeLevel = 0;
                if (typeof gameState.critMultUpgradeLevel === 'undefined') gameState.critMultUpgradeLevel = 0;
                if (typeof gameState.luckUpgradeLevel === 'undefined') gameState.luckUpgradeLevel = 0;
                if (typeof gameState.efficiencyUpgradeLevel === 'undefined') gameState.efficiencyUpgradeLevel = 0;
                if (typeof gameState.regenerationUpgradeLevel === 'undefined') gameState.regenerationUpgradeLevel = 0;
                if (typeof gameState.critChance === 'undefined') gameState.critChance = 0;
                if (typeof gameState.critMultiplier === 'undefined') gameState.critMultiplier = 2;
                if (typeof gameState.prestigePoints === 'undefined') gameState.prestigePoints = 0;
                if (typeof gameState.prestigeMultiplier === 'undefined') gameState.prestigeMultiplier = 1;
                if (typeof gameState.accumulatedBankInterest === 'undefined') gameState.accumulatedBankInterest = 0;
                if (typeof gameState.lastBankLogTime === 'undefined') gameState.lastBankLogTime = Date.now();
                if (typeof gameState.totalBankInterestEarned === 'undefined') gameState.totalBankInterestEarned = 0;
                if (typeof gameState.passiveBoostActive === 'undefined') gameState.passiveBoostActive = false;
                if (typeof gameState.passiveBoostEndTime === 'undefined') gameState.passiveBoostEndTime = 0;
                if (typeof gameState.ceoActive === 'undefined') gameState.ceoActive = false;
                if (typeof gameState.ceoEndTime === 'undefined') gameState.ceoEndTime = 0;
                if (typeof gameState.lastCEOLogTime === 'undefined') gameState.lastCEOLogTime = Date.now();
                if (typeof gameState.xpMultiplier === 'undefined') gameState.xpMultiplier = 1;
                if (typeof gameState.investmentStatBoost === 'undefined') gameState.investmentStatBoost = null;
                if (typeof gameState.investmentStatEndTime === 'undefined') gameState.investmentStatEndTime = 0;
                if (typeof gameState.isAutoClickerActive === 'undefined') gameState.isAutoClickerActive = false;
                if (typeof gameState.autoClickCostPerSecond === 'undefined') gameState.autoClickCostPerSecond = 1;
                // Restore CEO from active events
                gameState.activeEvents.forEach(event => {
                    if (event.id === 'ceo_active') {
                        gameState.ceoActive = true;
                        gameState.ceoEndTime = event.endTime;
                    }
                });
                if (typeof gameState.activeEvents === 'undefined') gameState.activeEvents = [];
                if (typeof gameState.companions === 'undefined') gameState.companions = [];
                if (typeof gameState.relics === 'undefined') gameState.relics = [];
                if (typeof gameState.currentDebuff === 'undefined') gameState.currentDebuff = null;
                if (typeof gameState.debuffEndTime === 'undefined') gameState.debuffEndTime = 0;
                if (typeof gameState.mana === 'undefined') gameState.mana = 0;
                if (typeof gameState.manaMax === 'undefined') gameState.manaMax = 0;
                if (typeof gameState.manaBoostActive === 'undefined') gameState.manaBoostActive = false;
                if (typeof gameState.manaBoostEndTime === 'undefined') gameState.manaBoostEndTime = 0;
                if (typeof gameState.infiniteMode === 'undefined') gameState.infiniteMode = false;
                if (typeof gameState.startTime === 'undefined') gameState.startTime = Date.now();
                if (typeof gameState.streak === 'undefined') gameState.streak = 0;
                if (typeof gameState.lastLoginDate === 'undefined') gameState.lastLoginDate = new Date().toDateString();
                if (typeof gameState.timeCrystalUpgradeLevel === 'undefined') gameState.timeCrystalUpgradeLevel = 0;
                if (typeof gameState.nextEventCountdown === 'undefined') gameState.nextEventCountdown = 20;
                if (typeof gameState.pendingEvent === 'undefined') gameState.pendingEvent = null;
                if (typeof gameState.eventBufferCountdown === 'undefined') gameState.eventBufferCountdown = 0;
                if (typeof gameState.bossFrozen === 'undefined') gameState.bossFrozen = false;
                if (typeof gameState.guaranteeRareDrop === 'undefined') gameState.guaranteeRareDrop = false;
                if (typeof gameState.attackMultiplier === 'undefined') gameState.attackMultiplier = 1;
                if (typeof gameState.investmentStatBoost === 'undefined') gameState.investmentStatBoost = null;
                if (typeof gameState.investmentStatEndTime === 'undefined') gameState.investmentStatEndTime = 0;
                if (typeof gameState.originalZoneName === 'undefined') gameState.originalZoneName = null;
                if (typeof gameState.fractionalBankInterest === 'undefined') gameState.fractionalBankInterest = 0;
                if (typeof gameState.musicEnabled === 'undefined') gameState.musicEnabled = false;
                if (typeof gameState.chronicleCollapsed === 'undefined') gameState.chronicleCollapsed = false;
                if (typeof gameState.eventCooldownEndTime === 'undefined') gameState.eventCooldownEndTime = 0;
                // Clear any active events on load to prevent them from continuing
                gameState.activeEvents = [];
                gameState.pendingEvent = null;
                gameState.eventBufferCountdown = 0;
                gameState.nextEventCountdown = 20;
                // Deep copy zones from master list but keep completed status
                const masterZones = JSON.parse(JSON.stringify(ZONES));
                gameState.zones = masterZones.map((zone, index) => {
                    if (loadedState.zones && loadedState.zones[index]) {
                        zone.challenges.forEach((challenge, cIndex) => {
                            if(loadedState.zones[index].challenges[cIndex]){
                                challenge.completed = loadedState.zones[index].challenges[cIndex].completed;
                            }
                        });
                    }
                    return zone;
                });
                // Reset bank mode on load
                gameState.isBankMode = false;
                // Recheck quest completion
                checkQuestCompletion(false);
                // Skip offline passive and daily login for manual load
                gameState.lastUpdateTime = Date.now();
                logMessage("Save loaded successfully!", "system-ok");
                loadZone();
                updateUI();
            } catch (e) {
                logMessage("Failed to load save: Invalid code or corrupted data.", "system-warn");
            }
        }

        function triggerRandomEvent() {
            // Rarity weights: Common 40%, Uncommon 30%, Rare 20%, Epic 7%, Legendary 3%
            const rarityWeights = {
                'Common': 0.4,
                'Uncommon': 0.3,
                'Rare': 0.2,
                'Epic': 0.07,
                'Legendary': 0.03
            };
            const rand = Math.random();
            let cumulative = 0;
            let selectedRarity = 'Common';
            for (const [rarity, weight] of Object.entries(rarityWeights)) {
                cumulative += weight;
                if (rand < cumulative) {
                    selectedRarity = rarity;
                    break;
                }
            }
            // Get events of selected rarity
            const rarityEvents = EVENTS.filter(e => e.rarity === selectedRarity);
            const event = rarityEvents[Math.floor(Math.random() * rarityEvents.length)];
            gameState.pendingEvent = event;
            gameState.eventBufferCountdown = 11;
            const incomingMessages = [
                "The veil between realms thins... An event stirs in the ether!",
                "Whispers of power echo through the syntax... Something approaches!",
                "The gilded threads of fate weave a new pattern... Brace yourself!",
                "Ancient energies coalesce... A random event manifests soon!",
                "The code of destiny rewrites itself... An event is imminent!"
            ];
            const randomMessage = incomingMessages[Math.floor(Math.random() * incomingMessages.length)];
            logMessage(`Event Incoming: ${randomMessage}`, "system-ok");
        }

        function activatePendingEvent() {
            const event = gameState.pendingEvent;
            if (!event) return;
            gameState.activeEvents.push({
                ...event,
                startTime: Date.now(),
                endTime: Date.now() + event.duration
            });
            const msgType = event.type === 'negative' ? "system-warn" : "system-ok";
            logMessage(`Event Activated: (${event.rarity}) ${event.name}`, msgType);
            // Add effect description
            let effectDesc = "";
            switch (event.effect) {
                case 'double_click': effectDesc = "Doubles essence gained from clicks"; break;
                case 'half_click': effectDesc = "Halves essence gained from clicks"; break;
                case 'quarter_click': effectDesc = "Reduces click power by 25%"; break;
                case 'triple_passive': effectDesc = "Triples passive essence"; break;
                case 'half_passive': effectDesc = "Halves passive essence"; break;
                case 'max_crit': effectDesc = "Grants 100% critical hit chance"; break;
                case 'half_costs': effectDesc = "Halves upgrade costs"; break;
                case 'double_bank': effectDesc = "Doubles bank interest rate"; break;
                case 'quad_passive': effectDesc = "Quadruples passive essence"; break;
                case 'super_crit': effectDesc = "150% crit chance with 2x multiplier"; break;
                case 'quintuple_click': effectDesc = "Quintuples essence from clicks"; break;
                case 'infinite_crit': effectDesc = "100% crit chance with 3x multiplier"; break;
                case 'decuple_passive': effectDesc = "Decuples passive essence"; break;
                case 'legendary_boost': effectDesc = "Sextuples clicks and passive essence"; break;
                case 'freeze_boss': effectDesc = "Freezes boss timer for 30 seconds"; break;
                case 'guarantee_rare': effectDesc = "Guarantees rare+ boss drops"; break;
                case 'luck_boost': effectDesc = "Increases luck by 10%"; break;
                default: effectDesc = event.description;
            }
            logMessage(`Effect: ${effectDesc} for ${event.duration / 1000} seconds`, "system");
            applyEventEffect(event);
            gameState.pendingEvent = null;
            // Handle chained events
            if (event.chain === 'mini_boss') {
                setTimeout(() => {
                    if (!bossState.active) {
                        logMessage("The Essence Storm has attracted a Mini-Boss!", "danger");
                        // Simple mini-boss: small HP, short timer
                        bossState.active = true;
                        bossState.hp = 100;
                        bossState.maxHp = 100;
                        bossState.timeLeft = 10;
                        bossState.isMiniBoss = true;
                        DOMElements.bossContainer.innerHTML = `
                            <div class="fade-in w-full">
                                <h3 class="font-cinzel text-2xl font-bold text-red-300 drop-shadow-lg">Mini-Boss: Storm Elemental</h3>
                                <p class="text-red-200 mt-2 mb-4">A small but fierce foe drawn by the storm!</p>
                                <p id="bossHp" class="text-xl font-bold text-white">100 / 100</p>
                                <div class="w-full bg-gray-700 rounded-full h-4 mt-4 border-2 border-black/50">
                                    <div id="bossTimerBar" class="bg-yellow-400 h-full rounded-full" style="width: 100%"></div>
                                </div>
                                <p id="bossTimeLeft" class="text-lg font-bold mt-2">10s remaining</p>
                            </div>
                        `;
                        DOMElements.bossContainer.classList.remove('hidden', 'absolute', 'inset-0');
                        DOMElements.bossContainer.classList.add('flex');
                        DOMElements.zoneName.style.display = 'none';
                        DOMElements.actionPrompt.style.display = 'none';
                        DOMElements.actionButton.className = 'btn action-btn attack-mode';
                        bossState.timer = setInterval(() => {
                            bossState.timeLeft--;
                            const timerBar = document.getElementById('bossTimerBar');
                            const timeLeftDisplay = document.getElementById('bossTimeLeft');
                            if (timerBar) timerBar.style.width = `${(bossState.timeLeft / 10) * 100}%`;
                            if (timeLeftDisplay) timeLeftDisplay.textContent = `${bossState.timeLeft}s remaining`;
                            if (bossState.timeLeft <= 0) {
                                loseBossFight();
                            }
                        }, 1000);
                    }
                }, 10000); // 10 seconds delay
            }
        }

        function applyEventEffect(event) {
            switch (event.effect) {
                case 'double_click':
                    gameStateManager.multiplyMultiplier('clickMultiplier', 2, 'event_' + event.id);
                    break;
                case 'triple_passive':
                    gameStateManager.multiplyMultiplier('passiveMultiplier', 3, 'event_' + event.id);
                    break;
                case 'max_crit':
                    gameStateManager.setMultiplier('critChance', 1, 'event_' + event.id);
                    break;
                case 'half_costs':
                    gameStateManager.multiplyMultiplier('efficiencyMultiplier', 0.5, 'event_' + event.id);
                    break;
                case 'half_passive':
                    gameStateManager.multiplyMultiplier('passiveMultiplier', 0.5, 'event_' + event.id);
                    break;
                case 'quarter_click':
                    gameStateManager.multiplyMultiplier('clickMultiplier', 0.75, 'event_' + event.id);
                    break;
                case 'luck_boost':
                    gameStateManager.multiplyMultiplier('luckMultiplier', 1.1, 'event_' + event.id);
                    break;
                case 'double_bank':
                    // Handled in updatePassiveIncome
                    break;
                case 'quad_passive':
                    gameStateManager.multiplyMultiplier('passiveMultiplier', 4, 'event_' + event.id);
                    break;
                case 'super_crit':
                    gameStateManager.setMultiplier('critChance', 1.5, 'event_' + event.id);
                    gameStateManager.setMultiplier('critMultiplier', 4, 'event_' + event.id); // 2x base
                    break;
                case 'quintuple_click':
                    gameStateManager.multiplyMultiplier('clickMultiplier', 5, 'event_' + event.id);
                    break;
                case 'infinite_crit':
                    gameStateManager.setMultiplier('critChance', 1, 'event_' + event.id);
                    gameStateManager.setMultiplier('critMultiplier', 6, 'event_' + event.id); // 3x base
                    break;
                case 'decuple_passive':
                    gameStateManager.multiplyMultiplier('passiveMultiplier', 10, 'event_' + event.id);
                    break;
                case 'legendary_boost':
                    gameStateManager.multiplyMultiplier('clickMultiplier', 6, 'event_' + event.id);
                    gameStateManager.multiplyMultiplier('passiveMultiplier', 6, 'event_' + event.id);
                    break;
                case 'freeze_boss':
                    gameStateManager.setState('bossFrozen', true, 'event_' + event.id);
                    break;
                case 'guarantee_rare':
                    gameStateManager.setState('guaranteeRareDrop', true, 'event_' + event.id);
                    break;
            }
        }

        function updateActiveEvents() {
            const now = Date.now();
            gameState.activeEvents = gameState.activeEvents.filter(event => {
                if (now >= event.endTime) {
                    removeEventEffect(event);
                    if (event.id === 'ceo_active') {
                        gameState.ceoActive = false;
                        logMessage("CEO of Money's contract has expired.", "system");
                    } else if (!event.name.startsWith(' ')) {
                        logMessage(`Event ended: ${event.name}`, "system");
                    }
                    return false;
                }
                return true;
            });
            updateActiveEventsList();
        }

        function removeEventEffect(event) {
            switch (event.effect) {
                case 'double_click':
                    gameStateManager.multiplyMultiplier('clickMultiplier', 0.5, 'event_end_' + event.id);
                    break;
                case 'triple_passive':
                    gameStateManager.multiplyMultiplier('passiveMultiplier', 1/3, 'event_end_' + event.id);
                    break;
                case 'max_crit':
                    gameStateManager.setMultiplier('critChance', Math.min(0.5, (0.05 * gameState.critChanceUpgradeLevel) * gameState.luckMultiplier), 'event_end_' + event.id);
                    break;
                case 'half_costs':
                    gameStateManager.multiplyMultiplier('efficiencyMultiplier', 2, 'event_end_' + event.id);
                    break;
                case 'half_passive':
                    gameStateManager.multiplyMultiplier('passiveMultiplier', 2, 'event_end_' + event.id);
                    break;
                case 'quarter_click':
                    gameStateManager.multiplyMultiplier('clickMultiplier', 1/0.75, 'event_end_' + event.id);
                    break;
                case 'luck_boost':
                    gameStateManager.multiplyMultiplier('luckMultiplier', 1/1.1, 'event_end_' + event.id);
                    break;
                case 'double_bank':
                    // Handled in updatePassiveIncome
                    break;
                case 'quad_passive':
                    gameStateManager.multiplyMultiplier('passiveMultiplier', 0.25, 'event_end_' + event.id);
                    break;
                case 'super_crit':
                    gameStateManager.setMultiplier('critChance', Math.min(0.5, (0.05 * gameState.critChanceUpgradeLevel) * gameState.luckMultiplier), 'event_end_' + event.id);
                    gameStateManager.setMultiplier('critMultiplier', 2 + 0.5 * gameState.critMultUpgradeLevel, 'event_end_' + event.id);
                    break;
                case 'quintuple_click':
                    gameStateManager.multiplyMultiplier('clickMultiplier', 0.2, 'event_end_' + event.id);
                    break;
                case 'infinite_crit':
                    gameStateManager.setMultiplier('critChance', Math.min(0.5, (0.05 * gameState.critChanceUpgradeLevel) * gameState.luckMultiplier), 'event_end_' + event.id);
                    gameStateManager.setMultiplier('critMultiplier', 2 + 0.5 * gameState.critMultUpgradeLevel, 'event_end_' + event.id);
                    break;
                case 'decuple_passive':
                    gameStateManager.multiplyMultiplier('passiveMultiplier', 0.1, 'event_end_' + event.id);
                    break;
                case 'legendary_boost':
                    gameStateManager.multiplyMultiplier('clickMultiplier', 1/6, 'event_end_' + event.id);
                    gameStateManager.multiplyMultiplier('passiveMultiplier', 1/6, 'event_end_' + event.id);
                    break;
                case 'freeze_boss':
                    gameState.bossFrozen = false;
                    break;
                case 'guarantee_rare':
                    gameState.guaranteeRareDrop = false;
                    break;
            }
        }


        function updateActiveEventsList() {
            DOMElements.activeEventsList.innerHTML = '';
            if (gameState.activeEvents.length === 0) {
                DOMElements.activeEventsList.innerHTML = '<div class="text-gray-500 text-sm">No active events</div>';
                return;
            }
            gameState.activeEvents.forEach(event => {
                const timeLeft = Math.ceil((event.endTime - Date.now()) / 1000);
                const eventEl = document.createElement('div');
                eventEl.className = 'flex justify-between items-center text-sm';
                let nameHtml = event.name;
                if (event.name.startsWith('(Bank)')) {
                    nameHtml = `<span class="rarity-prefix bank"><span>(Bank)</span></span>${event.name.substring(7)}`;
                } else if (event.rarity) {
                    const rarityClass = event.rarity.toLowerCase();
                    nameHtml = `<span class="rarity-prefix ${rarityClass}"><span>(${event.rarity})</span></span>${event.name}`;
                }
                eventEl.innerHTML = `<span>${nameHtml}</span><span class="text-gray-400">${timeLeft}s</span>`;
                DOMElements.activeEventsList.appendChild(eventEl);
            });
        }

        function getInitialGameState() {
            return {
                essence: 0,
                level: 1,
                xp: 0,
                xpToNextLevel: 100,
                totalClicks: 0,
                bankedClicks: 0,
                isBankMode: false,
                isAutoClickerActive: false,
                autoClickCostPerSecond: 1,
                currentZoneIndex: 0,
                zones: JSON.parse(JSON.stringify(ZONES)), // Deep copy
                passiveIncomeRate: 0,
                lastUpdateTime: Date.now(),
                clickMultiplier: 1,
                passiveMultiplier: 1,
                totalPassiveGained: 0,
                accumulatedPassive: 0,
                lastPassiveLogTime: Date.now(),
                clickUpgradeLevel: 0,
                passiveUpgradeLevel: 0,
                bankUpgradeLevel: 0,
                autoClickUpgradeLevel: 0,
                critChanceUpgradeLevel: 0,
                critMultUpgradeLevel: 0,
                luckUpgradeLevel: 0,
                efficiencyUpgradeLevel: 0,
                regenerationUpgradeLevel: 0,
                critChance: 0,
                critMultiplier: 2,
                prestigePoints: 0,
                prestigeMultiplier: 1,
                luckMultiplier: 1,
                efficiencyMultiplier: 1,
                regenerationMultiplier: 1,
                xpMultiplier: 1,
                investmentStatBoost: null,
                investmentStatEndTime: 0,
                accumulatedBankInterest: 0,
                lastBankLogTime: Date.now(),
                passiveBoostActive: false,
                passiveBoostEndTime: 0,
                ceoActive: false,
                ceoEndTime: 0,
                lastCEOLogTime: Date.now(),
                activeEvents: [],
                companions: [],
                relics: [],
                currentDebuff: null,
                debuffEndTime: 0,
                mana: 0,
                manaMax: 0,
                manaBoostActive: false,
                manaBoostEndTime: 0,
                infiniteMode: false,
                startTime: Date.now(),
                streak: 0,
                lastLoginDate: new Date().toDateString(),
                timeCrystalUpgradeLevel: 0,
                bossFrozen: false,
                guaranteeRareDrop: false,
                attackMultiplier: 1,
                nextEventCountdown: 20,
                pendingEvent: null,
                eventBufferCountdown: 0,
                bankMultiplier: 1,
                autoClickMultiplier: 1,
                originalZoneName: null,
                originalActionPrompt: null,
                achievements: [],
                fractionalBankInterest: 0,
                musicEnabled: false,
                eventCooldownEndTime: 0
            };
        }

        function resetProfile() {
            if (confirm("Are you sure you want to reset your progress? This will delete all saved data and cannot be undone.")) {
                isReset = true;
                gameState = getInitialGameState();
                localStorage.removeItem('gildedSyntaxSave');
                loadZone();
                updateUI();
                logMessage("Profile reset complete. All progress has been cleared.", "system");
                isReset = false;
                window.location.reload();
            }
        }

        function debugToggle() {
            gameState.essence = 20000000;
            logMessage("Debug: Set essence to 20,000,000", "system");
            if (gameState.relics.length === 0) {
                const relic = RELICS[Math.floor(Math.random() * RELICS.length)];
                gameState.relics.push(relic);
                logMessage(`Debug: Added relic ${relic.name}`, "system");
            } else {
                gameState.relics = [];
                logMessage("Debug: Removed all relics", "system");
            }
            isReset = true;
            updateUI();
            isReset = false;
        }

        function updateCompanionsList() {
            DOMElements.companionsList.innerHTML = '';
            if (gameState.companions.length === 0) {
                DOMElements.companionsList.innerHTML = '<div class="text-gray-500 text-sm">No companions summoned</div>';
                return;
            }
            gameState.companions.forEach(companion => {
                const companionEl = document.createElement('div');
                companionEl.className = 'flex justify-between items-center text-sm';
                companionEl.innerHTML = `<span class="text-white">${companion.name}</span><span class="text-green-400">${companion.description}</span>`;
                DOMElements.companionsList.appendChild(companionEl);
            });
            // Update button states
            COMPANIONS.forEach(companion => {
                const buttonEl = DOMElements['summon' + companion.id.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('')];
                const isSummoned = gameState.companions.some(c => c.id === companion.id);
                // Reset to original colors based on companion
                const colors = {
                    fire_sprite: 'bg-red-700 hover:bg-red-600',
                    water_nymph: 'bg-blue-700 hover:bg-blue-600',
                    earth_golem: 'bg-green-700 hover:bg-green-600',
                    air_spirit: 'bg-gray-700 hover:bg-gray-600',
                    shadow_imp: 'bg-purple-700 hover:bg-purple-600'
                };
                if (isSummoned) {
                    buttonEl.disabled = true;
                    buttonEl.textContent = "Summoned";
                    buttonEl.classList.remove('bg-red-700', 'hover:bg-red-600', 'bg-blue-700', 'hover:bg-blue-600', 'bg-green-700', 'hover:bg-green-600', 'bg-gray-700', 'hover:bg-gray-600', 'bg-purple-700', 'hover:bg-purple-600', 'bg-green-600', 'cursor-not-allowed', 'opacity-50');
                    buttonEl.classList.add(...colors[companion.id].split(' '), 'cursor-not-allowed', 'opacity-50');
                } else {
                    buttonEl.disabled = false;
                    buttonEl.textContent = "Summon";
                    buttonEl.classList.remove('bg-red-700', 'hover:bg-red-600', 'bg-blue-700', 'hover:bg-blue-600', 'bg-green-700', 'hover:bg-green-600', 'bg-gray-700', 'hover:bg-gray-600', 'bg-purple-700', 'hover:bg-purple-600', 'bg-green-600', 'cursor-not-allowed', 'opacity-50');
                    buttonEl.classList.add(...colors[companion.id].split(' '));
                }
            });
        }

        function updateRelicsList() {
            DOMElements.relicsList.innerHTML = '';
            if (gameState.relics.length === 0) {
                DOMElements.relicsList.innerHTML = '<div class="text-gray-500 text-sm">No relics collected</div>';
                return;
            }
            gameState.relics.forEach(relic => {
                const relicEl = document.createElement('div');
                relicEl.className = 'flex justify-between items-center text-sm glow-static';
                relicEl.style.color = getRarityColor(relic.rarity);
                relicEl.innerHTML = `<span>${relic.name}</span><span class="text-green-400">${relic.description}</span>`;
                DOMElements.relicsList.appendChild(relicEl);
            });
        }

        function updateSpecialMechanicDisplay() {
            const zone = gameState.zones[gameState.currentZoneIndex];
            if (!zone || !zone.specialMechanic) {
                DOMElements.specialMechanicDisplay.innerHTML = '';
                return;
            }
            // Hide if boss is ready or bank mode is active
            if (gameState.currentZoneIndex < gameState.zones.length) {
                const bossReady = zone.challenges.every(c => c.completed);
                if (bossReady || gameState.isBankMode) {
                    DOMElements.specialMechanicDisplay.innerHTML = '';
                    return;
                }
            }
            const mechanic = zone.specialMechanic;
            if (mechanic.type === 'debuff') {
                if (gameState.currentDebuff) {
                    const timeLeft = Math.ceil((gameState.debuffEndTime - Date.now()) / 1000);
                    DOMElements.specialMechanicDisplay.innerHTML = `<div class="text-red-400 text-sm">${mechanic.name}: Essence halved for ${timeLeft}s</div>`;
                } else {
                    DOMElements.specialMechanicDisplay.innerHTML = `<div class="text-gray-500 text-sm">${mechanic.description}</div>`;
                }
            } else if (mechanic.type === 'mana') {
                const manaPercent = (gameState.mana / gameState.manaMax) * 100;
                const boostText = gameState.manaBoostActive ? ` (Boost Active: ${Math.ceil((gameState.manaBoostEndTime - Date.now()) / 1000)}s)` : '';
                DOMElements.specialMechanicDisplay.innerHTML = `
                    <div class="text-blue-400 text-sm mb-2">${mechanic.name}: ${mechanic.description}</div>
                    <div class="w-full bg-gray-700 rounded-full h-4">
                        <div class="bg-blue-500 h-full rounded-full transition-all duration-300" style="width: ${manaPercent}%"></div>
                    </div>
                    <div class="text-sm text-gray-300 mt-1">${gameState.mana}/${gameState.manaMax}${boostText}</div>
                `;
            }
        }

        function summonCompanion(companionId) {
            const companion = COMPANIONS.find(c => c.id === companionId);
            const buttonEl = DOMElements['summon' + companionId.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('')];
            if (!companion) return;
            if (gameState.companions.some(c => c.id === companionId)) {
                DOMElements.companionFlavor.textContent = "(Already summoned)";
                setTimeout(() => DOMElements.companionFlavor.textContent = "", 2000);
                shakeElements(buttonEl.previousElementSibling, buttonEl);
                return;
            }
            const missingLevel = gameState.level < companion.unlockReq.level;
            const missingEssence = gameState.essence < companion.cost;
            if (missingLevel || missingEssence) {
                let message = "(You need ";
                if (missingLevel && missingEssence) {
                    message += "required level and essence)";
                } else if (missingLevel) {
                    message += "required level)";
                } else {
                    message += "essence)";
                }
                DOMElements.companionFlavor.textContent = message;
                setTimeout(() => DOMElements.companionFlavor.textContent = "", 2000);
                shakeElements(buttonEl.previousElementSibling, buttonEl);
                return;
            }

            gameStateManager.addEssence(-companion.cost, 'summon_companion');
            gameState.companions.push(companion);
            applyCompanionEffect(companion);
            logMessage(`Summoned ${companion.name}! ${companion.description}`, "system-ok");
            DOMElements.companionFlavor.textContent = "(Summoned!)";
            setTimeout(() => DOMElements.companionFlavor.textContent = "", 2000);
            updateUI();
            buttonEl.classList.add('success-click');
            setTimeout(() => buttonEl.classList.remove('success-click'), 500);
        }

        function applyCompanionEffect(companion) {
            gameStateManager.applyCompanionEffect(companion, 'apply_companion');
        }

        function applyRelicEffect(relic) {
            gameStateManager.applyRelicEffect(relic, 'apply_relic');
        }
        
        function getPlayerTitle() {
            let currentTitle = "Neophyte";
            for (const title of TITLES) {
                if (gameState.level >= title.level) {
                    currentTitle = title.name;
                }
            }
            return currentTitle;
        }
        
        function formatNumber(num) {
            if (num < 1000) return num.toString();
            if (num < 1000000) return (num / 1000).toFixed(1) + 'K';
            if (num < 1000000000) return (num / 1000000).toFixed(1) + 'M';
            if (num < 1000000000000) return (num / 1000000000).toFixed(1) + 'B';
            if (num < 1000000000000000) return (num / 1000000000000).toFixed(1) + 'T';
            return (num / 1000000000000000).toFixed(1) + 'Q';
        }

        function toggleChronicleCollapse() {
            gameStateManager.toggleState('chronicleCollapsed', 'toggle_chronicle_collapse');
            updateChronicleCollapse();
        }

        function updateChronicleCollapse() {
            const button = DOMElements.chronicleCollapseButton;
            const log = DOMElements.chatLog;
            if (gameState.chronicleCollapsed) {
                log.classList.add('collapsed');
                button.innerHTML = '<span style="font-family: monospace;"></span> Expand';
            } else {
                log.classList.remove('collapsed');
                log.style.height = '';
                button.innerHTML = '<span style="font-family: monospace;"></span> Collapse';
            }
        }

        function fadeInAudio(audio, targetVolume, duration) {
            const startVolume = audio.volume;
            const volumeStep = (targetVolume - startVolume) / (duration / 100);
            const fadeInterval = setInterval(() => {
                audio.volume += volumeStep;
                if (audio.volume >= targetVolume) {
                    audio.volume = targetVolume;
                    clearInterval(fadeInterval);
                }
            }, 100);
        }

        function toggleMusic() {
            gameStateManager.toggleState('musicEnabled', 'toggle_music');
            const audio = document.getElementById('backgroundMusic');
            if (gameState.musicEnabled) {
                audio.volume = 0.3;
                audio.play().catch(e => console.log('Audio play failed:', e));
            } else {
                audio.pause();
            }
            updateUI();
        }

        function getClickUpgradeCost() { return Math.floor(100 * Math.pow(1.5, gameState.clickUpgradeLevel) * gameState.efficiencyMultiplier); }
        function getPassiveUpgradeCost() { return Math.floor(200 * Math.pow(1.5, gameState.passiveUpgradeLevel) * gameState.efficiencyMultiplier); }
        function getBankUpgradeCost() { return Math.floor(150 * Math.pow(1.5, gameState.bankUpgradeLevel) * gameState.efficiencyMultiplier); }
        function getAutoClickUpgradeCost() { return Math.floor(250 * Math.pow(1.5, gameState.autoClickUpgradeLevel) * gameState.efficiencyMultiplier); }
        function getCritChanceUpgradeCost() { return Math.floor(300 * Math.pow(1.5, gameState.critChanceUpgradeLevel) * gameState.efficiencyMultiplier); }
        function getCritMultUpgradeCost() { return Math.floor(400 * Math.pow(1.5, gameState.critMultUpgradeLevel) * gameState.efficiencyMultiplier); }
        function getLuckUpgradeCost() { return Math.floor(500 * Math.pow(1.5, gameState.luckUpgradeLevel) * gameState.efficiencyMultiplier); }
        function getEfficiencyUpgradeCost() { return Math.floor(600 * Math.pow(1.5, gameState.efficiencyUpgradeLevel) * gameState.efficiencyMultiplier); }
        function getRegenerationUpgradeCost() { return Math.floor(700 * Math.pow(1.5, gameState.regenerationUpgradeLevel) * gameState.efficiencyMultiplier); }
        function getTimeCrystalUpgradeCost() { return Math.floor(1000 * Math.pow(1.5, gameState.timeCrystalUpgradeLevel) * gameState.efficiencyMultiplier); }

        // --- Save/Load ---
        function saveGame() {
            localStorage.setItem('gildedSyntaxSave', JSON.stringify(gameState));
        }

        function loadGame() {
            const savedGame = localStorage.getItem('gildedSyntaxSave');
            if (savedGame) {
                const loadedState = JSON.parse(savedGame);
                // Basic validation and merging
                gameState = { ...gameState, ...loadedState };
                // Ensure new properties are initialized
                if (typeof gameState.accumulatedPassive === 'undefined') gameState.accumulatedPassive = 0;
                if (typeof gameState.lastPassiveLogTime === 'undefined') gameState.lastPassiveLogTime = Date.now();
                if (typeof gameState.clickUpgradeLevel === 'undefined') gameState.clickUpgradeLevel = 0;
                if (typeof gameState.passiveUpgradeLevel === 'undefined') gameState.passiveUpgradeLevel = 0;
                if (typeof gameState.bankUpgradeLevel === 'undefined') gameState.bankUpgradeLevel = 0;
                if (typeof gameState.autoClickUpgradeLevel === 'undefined') gameState.autoClickUpgradeLevel = 0;
                if (typeof gameState.critChanceUpgradeLevel === 'undefined') gameState.critChanceUpgradeLevel = 0;
                if (typeof gameState.critMultUpgradeLevel === 'undefined') gameState.critMultUpgradeLevel = 0;
                if (typeof gameState.luckUpgradeLevel === 'undefined') gameState.luckUpgradeLevel = 0;
                if (typeof gameState.efficiencyUpgradeLevel === 'undefined') gameState.efficiencyUpgradeLevel = 0;
                if (typeof gameState.regenerationUpgradeLevel === 'undefined') gameState.regenerationUpgradeLevel = 0;
                if (typeof gameState.critChance === 'undefined') gameState.critChance = 0;
                if (typeof gameState.critMultiplier === 'undefined') gameState.critMultiplier = 2;
                if (typeof gameState.prestigePoints === 'undefined') gameState.prestigePoints = 0;
                if (typeof gameState.prestigeMultiplier === 'undefined') gameState.prestigeMultiplier = 1;
                if (typeof gameState.accumulatedBankInterest === 'undefined') gameState.accumulatedBankInterest = 0;
                if (typeof gameState.lastBankLogTime === 'undefined') gameState.lastBankLogTime = Date.now();
                if (typeof gameState.totalBankInterestEarned === 'undefined') gameState.totalBankInterestEarned = 0;
                if (typeof gameState.passiveBoostActive === 'undefined') gameState.passiveBoostActive = false;
                if (typeof gameState.passiveBoostEndTime === 'undefined') gameState.passiveBoostEndTime = 0;
                if (typeof gameState.ceoActive === 'undefined') gameState.ceoActive = false;
                if (typeof gameState.ceoEndTime === 'undefined') gameState.ceoEndTime = 0;
                if (typeof gameState.lastCEOLogTime === 'undefined') gameState.lastCEOLogTime = Date.now();
                if (typeof gameState.xpMultiplier === 'undefined') gameState.xpMultiplier = 1;
                if (typeof gameState.isAutoClickerActive === 'undefined') gameState.isAutoClickerActive = false;
                if (typeof gameState.autoClickCostPerSecond === 'undefined') gameState.autoClickCostPerSecond = 1;
                // Restore CEO from active events
                gameState.activeEvents.forEach(event => {
                    if (event.id === 'ceo_active') {
                        gameState.ceoActive = true;
                        gameState.ceoEndTime = event.endTime;
                    }
                });
                if (typeof gameState.activeEvents === 'undefined') gameState.activeEvents = [];
                if (typeof gameState.companions === 'undefined') gameState.companions = [];
                if (typeof gameState.relics === 'undefined') gameState.relics = [];
                if (typeof gameState.currentDebuff === 'undefined') gameState.currentDebuff = null;
                if (typeof gameState.debuffEndTime === 'undefined') gameState.debuffEndTime = 0;
                if (typeof gameState.mana === 'undefined') gameState.mana = 0;
                if (typeof gameState.manaMax === 'undefined') gameState.manaMax = 0;
                if (typeof gameState.manaBoostActive === 'undefined') gameState.manaBoostActive = false;
                if (typeof gameState.manaBoostEndTime === 'undefined') gameState.manaBoostEndTime = 0;
                if (typeof gameState.infiniteMode === 'undefined') gameState.infiniteMode = false;
                if (typeof gameState.startTime === 'undefined') gameState.startTime = Date.now();
                if (typeof gameState.streak === 'undefined') gameState.streak = 0;
                if (typeof gameState.lastLoginDate === 'undefined') gameState.lastLoginDate = new Date().toDateString();
                if (typeof gameState.timeCrystalUpgradeLevel === 'undefined') gameState.timeCrystalUpgradeLevel = 0;
                if (typeof gameState.nextEventCountdown === 'undefined') gameState.nextEventCountdown = 20;
                if (typeof gameState.pendingEvent === 'undefined') gameState.pendingEvent = null;
                if (typeof gameState.eventBufferCountdown === 'undefined') gameState.eventBufferCountdown = 0;
                if (typeof gameState.bossFrozen === 'undefined') gameState.bossFrozen = false;
                if (typeof gameState.guaranteeRareDrop === 'undefined') gameState.guaranteeRareDrop = false;
                if (typeof gameState.attackMultiplier === 'undefined') gameState.attackMultiplier = 1;
                if (typeof gameState.originalZoneName === 'undefined') gameState.originalZoneName = null;
                if (typeof gameState.fractionalBankInterest === 'undefined') gameState.fractionalBankInterest = 0;
                if (typeof gameState.musicEnabled === 'undefined') gameState.musicEnabled = true;
                if (typeof gameState.chronicleCollapsed === 'undefined') gameState.chronicleCollapsed = false;
                if (typeof gameState.eventCooldownEndTime === 'undefined') gameState.eventCooldownEndTime = 0;
                // Clear any active events on load to prevent them from continuing
                gameState.activeEvents = [];
                gameState.pendingEvent = null;
                gameState.eventBufferCountdown = 0;
                gameState.nextEventCountdown = 20;
                  // Deep copy zones from master list but keep completed status
                  const masterZones = JSON.parse(JSON.stringify(ZONES));
                  gameState.zones = masterZones.map((zone, index) => {
                      if (loadedState.zones && loadedState.zones[index]) {
                          zone.challenges.forEach((challenge, cIndex) => {
                                if(loadedState.zones[index].challenges[cIndex]){
                                  challenge.completed = loadedState.zones[index].challenges[cIndex].completed;
                                }
                          });
                      }
                      return zone;
                  });
                  // Reset bank mode on load
                  gameState.isBankMode = false;
                  // Recheck quest completion
                  checkQuestCompletion(false);
                  // Calculate offline passive income
                const now = Date.now();
                const timeDiff = (now - gameState.lastUpdateTime) / 1000;
                const maxOfflineTime = 3600000 + gameState.timeCrystalUpgradeLevel * 1800000; // 1h + 30min per level
                const cappedTimeDiff = Math.min(timeDiff, maxOfflineTime);
                const passiveGained = Math.floor(cappedTimeDiff * gameState.passiveIncomeRate);
                if (passiveGained > 0) {
                    gameStateManager.addEssence(passiveGained, 'offline_passive');
                    gainXP(Math.floor(passiveGained / 100));
                    const timeStr = timeDiff > maxOfflineTime ? ` (capped at ${Math.floor(maxOfflineTime / 3600)}h)` : '';
                    logMessage(`While you were away from Gilded Syntax, you gained ${formatNumber(passiveGained)} Essence from passive essence${timeStr}.`, "system-ok");
                }
                gameState.lastUpdateTime = now;
                // Check daily login
                const today = new Date().toDateString();
                if (gameState.lastLoginDate !== today) {
                    gameState.streak++;
                    gameState.lastLoginDate = today;
                    const bonus = gameState.streak * 1000; // 1K essence per streak day
                    gameStateManager.addEssence(bonus, 'daily_login');
                    logMessage(`Daily login bonus! Streak: ${gameState.streak} days. Gained ${formatNumber(bonus)} essence.`, "system-ok");
                }
                // Validate loaded game state
                validateGameState('load_game');
                logMessage("Welcome back to Gilded Syntax, your progress has been restored.", "system-ok");
            } else {
                logMessage("Welcome to Gilded Syntax. Begin your ascent through the gilded realms.", "system");
            }
        }

        // Validate game state integrity
        function validateGameState(reason = 'validation') {
            // Check for negative values that should never be negative
            const nonNegativeFields = ['essence', 'level', 'xp', 'totalClicks', 'bankedClicks', 'passiveIncomeRate'];
            nonNegativeFields.forEach(field => {
                if (typeof gameState[field] === 'number' && gameState[field] < 0) {
                    console.warn(`[GameState Validation] ${field} was negative (${gameState[field]}), clamping to 0, reason: ${reason}`);
                    gameState[field] = 0;
                }
            });

            // Check multiplier ranges (should be positive)
            const multiplierFields = ['clickMultiplier', 'passiveMultiplier', 'bankMultiplier', 'autoClickMultiplier', 'luckMultiplier', 'efficiencyMultiplier', 'regenerationMultiplier', 'xpMultiplier', 'attackMultiplier'];
            multiplierFields.forEach(field => {
                if (typeof gameState[field] === 'number' && gameState[field] <= 0) {
                    console.warn(`[GameState Validation] ${field} was non-positive (${gameState[field]}), resetting to 1, reason: ${reason}`);
                    gameState[field] = 1;
                }
            });

            // Check crit chance bounds (0 to 1)
            if (typeof gameState.critChance === 'number' && (gameState.critChance < 0 || gameState.critChance > 1)) {
                console.warn(`[GameState Validation] critChance out of bounds (${gameState.critChance}), clamping to valid range, reason: ${reason}`);
                gameState.critChance = Math.max(0, Math.min(1, gameState.critChance));
            }

            // Check crit multiplier (should be >= 1)
            if (typeof gameState.critMultiplier === 'number' && gameState.critMultiplier < 1) {
                console.warn(`[GameState Validation] critMultiplier too low (${gameState.critMultiplier}), resetting to 2, reason: ${reason}`);
                gameState.critMultiplier = 2;
            }

            // Check boolean fields
            const booleanFields = ['isBankMode', 'isAutoClickerActive', 'musicEnabled', 'chronicleCollapsed', 'bossFrozen', 'guaranteeRareDrop'];
            booleanFields.forEach(field => {
                if (typeof gameState[field] !== 'boolean') {
                    console.warn(`[GameState Validation] ${field} was not boolean (${typeof gameState[field]}), resetting to false, reason: ${reason}`);
                    gameState[field] = false;
                }
            });

            // Check zone index bounds
            if (typeof gameState.currentZoneIndex !== 'number' || gameState.currentZoneIndex < 0) {
                console.warn(`[GameState Validation] currentZoneIndex invalid (${gameState.currentZoneIndex}), resetting to 0, reason: ${reason}`);
                gameState.currentZoneIndex = 0;
            }

            console.log(`[GameState Validation] Completed validation, reason: ${reason}`);
        }

        // Game State Manager for safe, logged, and validated state updates
        const gameStateManager = {
            addEssence(amount, reason = 'unknown') {
                if (typeof amount !== 'number' || isNaN(amount)) {
                    console.error(`Invalid essence amount: ${amount}, reason: ${reason}`);
                    return;
                }
                const oldValue = gameState.essence;
                gameState.essence += amount;
                if (gameState.essence < 0) {
                    console.warn(`Essence went negative: ${gameState.essence}, clamping to 0, reason: ${reason}`);
                    gameState.essence = 0;
                }
                console.log(`[GameState] Essence: ${oldValue} -> ${gameState.essence} (+${amount}) [${reason}]`);
            },

            addClicks(amount, reason = 'unknown') {
                if (typeof amount !== 'number' || isNaN(amount)) {
                    console.error(`Invalid clicks amount: ${amount}, reason: ${reason}`);
                    return;
                }
                const oldValue = gameState.totalClicks;
                gameState.totalClicks += amount;
                if (gameState.totalClicks < 0) {
                    console.warn(`Total clicks went negative: ${gameState.totalClicks}, clamping to 0, reason: ${reason}`);
                    gameState.totalClicks = 0;
                }
                console.log(`[GameState] Total Clicks: ${oldValue} -> ${gameState.totalClicks} (+${amount}) [${reason}]`);
            },

            addBankedClicks(amount, reason = 'unknown') {
                if (typeof amount !== 'number' || isNaN(amount)) {
                    console.error(`Invalid banked clicks amount: ${amount}, reason: ${reason}`);
                    return;
                }
                const oldValue = gameState.bankedClicks;
                gameState.bankedClicks += amount;
                if (gameState.bankedClicks < 0) {
                    console.warn(`Banked clicks went negative: ${gameState.bankedClicks}, clamping to 0, reason: ${reason}`);
                    gameState.bankedClicks = 0;
                }
                console.log(`[GameState] Banked Clicks: ${oldValue} -> ${gameState.bankedClicks} (+${amount}) [${reason}]`);
            },

            addXP(amount, reason = 'unknown') {
                if (typeof amount !== 'number' || isNaN(amount)) {
                    console.error(`Invalid XP amount: ${amount}, reason: ${reason}`);
                    return;
                }
                const oldValue = gameState.xp;
                gameState.xp += amount;
                if (gameState.xp < 0) {
                    console.warn(`XP went negative: ${gameState.xp}, clamping to 0, reason: ${reason}`);
                    gameState.xp = 0;
                }
                console.log(`[GameState] XP: ${oldValue} -> ${gameState.xp} (+${amount}) [${reason}]`);
            },

            addLevel(amount, reason = 'unknown') {
                if (typeof amount !== 'number' || isNaN(amount)) {
                    console.error(`Invalid level amount: ${amount}, reason: ${reason}`);
                    return;
                }
                const oldValue = gameState.level;
                gameState.level += amount;
                if (gameState.level < 1) {
                    console.warn(`Level went below 1: ${gameState.level}, clamping to 1, reason: ${reason}`);
                    gameState.level = 1;
                }
                console.log(`[GameState] Level: ${oldValue} -> ${gameState.level} (+${amount}) [${reason}]`);
            },

            setMultiplier(type, value, reason = 'unknown') {
                if (typeof value !== 'number' || isNaN(value) || value < 0) {
                    console.error(`Invalid multiplier value: ${value} for ${type}, reason: ${reason}`);
                    return;
                }
                const oldValue = gameState[type];
                gameState[type] = value;
                console.log(`[GameState] ${type}: ${oldValue} -> ${value} [${reason}]`);
            },

            multiplyMultiplier(type, factor, reason = 'unknown') {
                if (typeof factor !== 'number' || isNaN(factor) || factor < 0) {
                    console.error(`Invalid multiplier factor: ${factor} for ${type}, reason: ${reason}`);
                    return;
                }
                const oldValue = gameState[type];
                gameState[type] *= factor;
                console.log(`[GameState] ${type}: ${oldValue} -> ${gameState[type]} (*${factor}) [${reason}]`);
            },

            // General state setter with type validation
            setState(key, value, reason = 'unknown') {
                const oldValue = gameState[key];

                // Type-specific validation
                if (typeof value !== typeof oldValue && oldValue !== undefined) {
                    console.error(`Type mismatch for ${key}: expected ${typeof oldValue}, got ${typeof value}, reason: ${reason}`);
                    return;
                }

                // Additional validations for known properties
                if (key === 'isBankMode' || key === 'isAutoClickerActive' || key === 'musicEnabled' || key === 'chronicleCollapsed') {
                    if (typeof value !== 'boolean') {
                        console.error(`Invalid boolean value for ${key}: ${value}, reason: ${reason}`);
                        return;
                    }
                }

                if (key === 'currentZoneIndex' && (typeof value !== 'number' || value < 0 || !Number.isInteger(value))) {
                    console.error(`Invalid zone index: ${value}, reason: ${reason}`);
                    return;
                }

                gameState[key] = value;
                console.log(`[GameState] ${key}: ${oldValue} -> ${value} [${reason}]`);
            },

            // Toggle boolean flags
            toggleState(key, reason = 'unknown') {
                if (typeof gameState[key] !== 'boolean') {
                    console.error(`Cannot toggle non-boolean property: ${key}, reason: ${reason}`);
                    return;
                }
                const newValue = !gameState[key];
                this.setState(key, newValue, reason);
            },

            // Recalculate all derived multipliers (call this instead of direct calculations)
            recalculateMultipliers(reason = 'recalculate') {
                const softCap = 50;

                const newClickMultiplier = Math.pow(1.1, Math.min(gameState.clickUpgradeLevel, softCap)) *
                                          Math.pow(1.05, Math.max(gameState.clickUpgradeLevel - softCap, 0));
                this.setMultiplier('clickMultiplier', newClickMultiplier, reason);

                // Tiered passive upgrade growth
                let passiveMult = 1;
                const level = gameState.passiveUpgradeLevel;
                if (level <= 20) {
                    passiveMult = Math.pow(1.15, level);
                } else if (level <= 50) {
                    passiveMult = Math.pow(1.15, 20) * Math.pow(1.1, level - 20);
                } else if (level <= 100) {
                    passiveMult = Math.pow(1.15, 20) * Math.pow(1.1, 30) * Math.pow(1.05, level - 50);
                } else {
                    passiveMult = Math.pow(1.15, 20) * Math.pow(1.1, 30) * Math.pow(1.05, 50) * Math.pow(1.02, level - 100);
                }
                this.setMultiplier('passiveMultiplier', passiveMult, reason);

                const newBankMultiplier = Math.pow(1.1, Math.min(gameState.bankUpgradeLevel, softCap)) *
                                         Math.pow(1.05, Math.max(gameState.bankUpgradeLevel - softCap, 0));
                this.setMultiplier('bankMultiplier', newBankMultiplier, reason);

                const newAutoClickMultiplier = Math.pow(1.1, Math.min(gameState.autoClickUpgradeLevel, softCap)) *
                                              Math.pow(1.05, Math.max(gameState.autoClickUpgradeLevel - softCap, 0));
                this.setMultiplier('autoClickMultiplier', newAutoClickMultiplier, reason);

                const newLuckMultiplier = Math.pow(1.05, Math.min(gameState.luckUpgradeLevel, softCap)) *
                                         Math.pow(1.02, Math.max(gameState.luckUpgradeLevel - softCap, 0));
                this.setMultiplier('luckMultiplier', newLuckMultiplier, reason);

                const newEfficiencyMultiplier = Math.pow(0.95, Math.min(gameState.efficiencyUpgradeLevel, softCap)) *
                                                Math.pow(0.98, Math.max(gameState.efficiencyUpgradeLevel - softCap, 0));
                this.setMultiplier('efficiencyMultiplier', newEfficiencyMultiplier, reason);

                const newRegenerationMultiplier = Math.pow(1.1, Math.min(gameState.regenerationUpgradeLevel, softCap)) *
                                                 Math.pow(1.05, Math.max(gameState.regenerationUpgradeLevel - softCap, 0));
                this.setMultiplier('regenerationMultiplier', newRegenerationMultiplier, reason);

                // Recalculate crit chance and multiplier
                const newCritChance = Math.min(0.5, (0.05 * gameState.critChanceUpgradeLevel) * gameState.luckMultiplier);
                this.setMultiplier('critChance', newCritChance, reason);

                const newCritMultiplier = 2 + 0.5 * gameState.critMultUpgradeLevel;
                this.setMultiplier('critMultiplier', newCritMultiplier, reason);
            },

            // Apply companion effects through manager
            applyCompanionEffect(companion, reason = 'companion_effect') {
                switch (companion.effect) {
                    case 'click_mult':
                        this.multiplyMultiplier('clickMultiplier', companion.value, reason);
                        break;
                    case 'passive_mult':
                        this.multiplyMultiplier('passiveMultiplier', companion.value, reason);
                        break;
                    case 'bank_mult':
                        this.multiplyMultiplier('bankMultiplier', companion.value, reason);
                        break;
                    case 'auto_mult':
                        this.multiplyMultiplier('autoClickMultiplier', companion.value, reason);
                        break;
                    case 'crit_chance_add':
                        this.addToMultiplier('critChance', companion.value, reason);
                        break;
                }
            },

            // Apply relic effects through manager
            applyRelicEffect(relic, reason = 'relic_effect') {
                switch (relic.effect) {
                    case 'crit_chance_add':
                        this.addToMultiplier('critChance', relic.value, reason);
                        break;
                    case 'click_mult':
                        this.multiplyMultiplier('clickMultiplier', relic.value, reason);
                        break;
                    case 'passive_mult':
                        this.multiplyMultiplier('passiveMultiplier', relic.value, reason);
                        break;
                    case 'luck_mult':
                        this.multiplyMultiplier('luckMultiplier', relic.value, reason);
                        break;
                    case 'efficiency_mult':
                        this.multiplyMultiplier('efficiencyMultiplier', relic.value, reason);
                        break;
                    case 'attack_mult':
                        this.multiplyMultiplier('attackMultiplier', relic.value, reason);
                        break;
                    case 'xp_mult':
                        this.multiplyMultiplier('xpMultiplier', relic.value, reason);
                        break;
                }
            },

            // Helper method to add to multipliers (for crit chance additions)
            addToMultiplier(type, amount, reason = 'unknown') {
                if (typeof amount !== 'number' || isNaN(amount)) {
                    console.error(`Invalid amount to add: ${amount} for ${type}, reason: ${reason}`);
                    return;
                }
                const oldValue = gameState[type];
                gameState[type] += amount;
                console.log(`[GameState] ${type}: ${oldValue} -> ${gameState[type]} (+${amount}) [${reason}]`);
            },
 
            // Mana management
            addMana(amount, reason = 'unknown') {
                if (typeof amount !== 'number' || isNaN(amount)) {
                    console.error(`Invalid mana amount: ${amount}, reason: ${reason}`);
                    return;
                }
                const oldValue = gameState.mana;
                gameState.mana += amount;
                if (gameState.mana < 0) {
                    console.warn(`Mana went negative: ${gameState.mana}, clamping to 0, reason: ${reason}`);
                    gameState.mana = 0;
                }
                console.log(`[GameState] Mana: ${oldValue} -> ${gameState.mana} (+${amount}) [${reason}]`);
            },
 
            setMana(value, reason = 'unknown') {
                if (typeof value !== 'number' || isNaN(value) || value < 0) {
                    console.error(`Invalid mana value: ${value}, reason: ${reason}`);
                    return;
                }
                const oldValue = gameState.mana;
                gameState.mana = value;
                console.log(`[GameState] Mana: ${oldValue} -> ${value} [${reason}]`);
            },
 
            // Prestige points management
            addPrestigePoints(amount, reason = 'unknown') {
                if (typeof amount !== 'number' || isNaN(amount)) {
                    console.error(`Invalid prestige points amount: ${amount}, reason: ${reason}`);
                    return;
                }
                const oldValue = gameState.prestigePoints;
                gameState.prestigePoints += amount;
                if (gameState.prestigePoints < 0) {
                    console.warn(`Prestige points went negative: ${gameState.prestigePoints}, clamping to 0, reason: ${reason}`);
                    gameState.prestigePoints = 0;
                }
                console.log(`[GameState] Prestige Points: ${oldValue} -> ${gameState.prestigePoints} (+${amount}) [${reason}]`);
            }
        };

        // Boss ready button toggle function
        function toggleBossReady() {
            const isActive = DOMElements.bossReadyButton.classList.contains('active');
            if (isActive) {
                DOMElements.bossReadyButton.classList.remove('active');
                logMessage("Not ready for battle. Click when prepared.", "system");
            } else {
                DOMElements.bossReadyButton.classList.add('active');
                logMessage("Ready for battle! The boss awaits.", "system-ok");
            }
            updateUI(); // Update button state
        }

        // --- Initialization ---
        function init() {
            // Action button
            DOMElements.actionButton.addEventListener('click', (e) => handleActionClick(e));
            DOMElements.actionButton.addEventListener('mousedown', () => DOMElements.actionButton.classList.add('pressed'));
            DOMElements.actionButton.addEventListener('mouseup', () => DOMElements.actionButton.classList.remove('pressed'));
            DOMElements.actionButton.addEventListener('mouseleave', () => DOMElements.actionButton.classList.remove('pressed'));

            DOMElements.bankModeToggle.addEventListener('change', toggleBankMode);
            DOMElements.autoClickButton.addEventListener('click', toggleAutoClicker);
            DOMElements.autoClickButton.addEventListener('mousedown', () => DOMElements.autoClickButton.classList.add('pressed'));
            DOMElements.autoClickButton.addEventListener('mouseup', () => DOMElements.autoClickButton.classList.remove('pressed'));
            DOMElements.autoClickButton.addEventListener('mouseleave', () => DOMElements.autoClickButton.classList.remove('pressed'));

            // Upgrade buttons
            const upgradeButtons = [
                DOMElements.upgradeClick, DOMElements.upgradePassive, DOMElements.upgradeBank, DOMElements.upgradeAutoClick,
                DOMElements.upgradeCritChance, DOMElements.upgradeCritMult, DOMElements.upgradeLuck,
                DOMElements.upgradeEfficiency, DOMElements.upgradeRegeneration, DOMElements.upgradeTimeCrystal
            ];
            upgradeButtons.forEach(button => {
                button.addEventListener('mousedown', () => button.classList.add('pressed'));
                button.addEventListener('mouseup', () => button.classList.remove('pressed'));
                button.addEventListener('mouseleave', () => button.classList.remove('pressed'));
            });

            DOMElements.upgradeClick.addEventListener('click', buyClickUpgrade);
            DOMElements.upgradePassive.addEventListener('click', buyPassiveUpgrade);
            DOMElements.upgradeBank.addEventListener('click', buyBankUpgrade);
            DOMElements.upgradeAutoClick.addEventListener('click', buyAutoClickUpgrade);
            DOMElements.upgradeCritChance.addEventListener('click', buyCritChanceUpgrade);
            DOMElements.upgradeCritMult.addEventListener('click', buyCritMultUpgrade);
            DOMElements.upgradeLuck.addEventListener('click', buyLuckUpgrade);
            DOMElements.upgradeEfficiency.addEventListener('click', buyEfficiencyUpgrade);
            DOMElements.upgradeRegeneration.addEventListener('click', buyRegenerationUpgrade);
            DOMElements.upgradeTimeCrystal.addEventListener('click', buyTimeCrystalUpgrade);
            // Add glow effects for upgrade labels on button hover
            DOMElements.upgradeClick.addEventListener('mouseenter', () => DOMElements.clickLabel.classList.add('glow'));
            DOMElements.upgradeClick.addEventListener('mouseleave', () => DOMElements.clickLabel.classList.remove('glow'));
            DOMElements.upgradePassive.addEventListener('mouseenter', () => DOMElements.passiveLabel.classList.add('glow'));
            DOMElements.upgradePassive.addEventListener('mouseleave', () => DOMElements.passiveLabel.classList.remove('glow'));
            DOMElements.upgradeBank.addEventListener('mouseenter', () => DOMElements.bankLabel.classList.add('glow'));
            DOMElements.upgradeBank.addEventListener('mouseleave', () => DOMElements.bankLabel.classList.remove('glow'));
            DOMElements.upgradeAutoClick.addEventListener('mouseenter', () => DOMElements.autoLabel.classList.add('glow'));
            DOMElements.upgradeAutoClick.addEventListener('mouseleave', () => DOMElements.autoLabel.classList.remove('glow'));
            DOMElements.upgradeCritChance.addEventListener('mouseenter', () => DOMElements.critChanceLabel.classList.add('glow'));
            DOMElements.upgradeCritChance.addEventListener('mouseleave', () => DOMElements.critChanceLabel.classList.remove('glow'));
            DOMElements.upgradeCritMult.addEventListener('mouseenter', () => DOMElements.critMultLabel.classList.add('glow'));
            DOMElements.upgradeCritMult.addEventListener('mouseleave', () => DOMElements.critMultLabel.classList.remove('glow'));
            DOMElements.upgradeLuck.addEventListener('mouseenter', () => DOMElements.luckLabel.classList.add('glow'));
            DOMElements.upgradeLuck.addEventListener('mouseleave', () => DOMElements.luckLabel.classList.remove('glow'));
            DOMElements.upgradeEfficiency.addEventListener('mouseenter', () => DOMElements.efficiencyLabel.classList.add('glow'));
            DOMElements.upgradeEfficiency.addEventListener('mouseleave', () => DOMElements.efficiencyLabel.classList.remove('glow'));
            DOMElements.upgradeRegeneration.addEventListener('mouseenter', () => DOMElements.regenerationLabel.classList.add('glow'));
            DOMElements.upgradeRegeneration.addEventListener('mouseleave', () => DOMElements.regenerationLabel.classList.remove('glow'));
            DOMElements.upgradeTimeCrystal.addEventListener('mouseenter', () => DOMElements.timeCrystalLabel.classList.add('glow'));
            DOMElements.upgradeTimeCrystal.addEventListener('mouseleave', () => DOMElements.timeCrystalLabel.classList.remove('glow'));
            // Companion buttons
            const companionButtons = [
                DOMElements.summonFireSprite, DOMElements.summonWaterNymph, DOMElements.summonEarthGolem,
                DOMElements.summonAirSpirit, DOMElements.summonShadowImp
            ];
            companionButtons.forEach(button => {
                button.addEventListener('mousedown', () => button.classList.add('pressed'));
                button.addEventListener('mouseup', () => button.classList.remove('pressed'));
                button.addEventListener('mouseleave', () => button.classList.remove('pressed'));
            });

            DOMElements.summonFireSprite.addEventListener('click', () => summonCompanion('fire_sprite'));
            DOMElements.summonWaterNymph.addEventListener('click', () => summonCompanion('water_nymph'));
            DOMElements.summonEarthGolem.addEventListener('click', () => summonCompanion('earth_golem'));
            DOMElements.summonAirSpirit.addEventListener('click', () => summonCompanion('air_spirit'));
            DOMElements.summonShadowImp.addEventListener('click', () => summonCompanion('shadow_imp'));
            // Add glow effects for companion names on button hover
            DOMElements.summonFireSprite.addEventListener('mouseenter', () => DOMElements.summonFireSprite.previousElementSibling.classList.add('glow'));
            DOMElements.summonFireSprite.addEventListener('mouseleave', () => DOMElements.summonFireSprite.previousElementSibling.classList.remove('glow'));
            DOMElements.summonWaterNymph.addEventListener('mouseenter', () => DOMElements.summonWaterNymph.previousElementSibling.classList.add('glow'));
            DOMElements.summonWaterNymph.addEventListener('mouseleave', () => DOMElements.summonWaterNymph.previousElementSibling.classList.remove('glow'));
            DOMElements.summonEarthGolem.addEventListener('mouseenter', () => DOMElements.summonEarthGolem.previousElementSibling.classList.add('glow'));
            DOMElements.summonEarthGolem.addEventListener('mouseleave', () => DOMElements.summonEarthGolem.previousElementSibling.classList.remove('glow'));
            DOMElements.summonAirSpirit.addEventListener('mouseenter', () => DOMElements.summonAirSpirit.previousElementSibling.classList.add('glow'));
            DOMElements.summonAirSpirit.addEventListener('mouseleave', () => DOMElements.summonAirSpirit.previousElementSibling.classList.remove('glow'));
            DOMElements.summonShadowImp.addEventListener('mouseenter', () => DOMElements.summonShadowImp.previousElementSibling.classList.add('glow'));
            DOMElements.summonShadowImp.addEventListener('mouseleave', () => DOMElements.summonShadowImp.previousElementSibling.classList.remove('glow'));
            // Bank buttons
            const bankButtons = [
                DOMElements.passiveSurgeButton, DOMElements.hireCEOButton, DOMElements.bankInvestmentButton, DOMElements.convertClicksButton
            ];
            bankButtons.forEach(button => {
                button.addEventListener('mousedown', () => button.classList.add('pressed'));
                button.addEventListener('mouseup', () => button.classList.remove('pressed'));
                button.addEventListener('mouseleave', () => button.classList.remove('pressed'));
            });

            DOMElements.passiveSurgeButton.addEventListener('click', usePassiveSurge);
            DOMElements.hireCEOButton.addEventListener('click', hireCEO);
            DOMElements.bankInvestmentButton.addEventListener('click', useBankInvestment);
            DOMElements.convertClicksButton.addEventListener('click', convertClicksToEssence);

            // Prestige button
            DOMElements.prestigeButton.addEventListener('mousedown', () => DOMElements.prestigeButton.classList.add('pressed'));
            DOMElements.prestigeButton.addEventListener('mouseup', () => DOMElements.prestigeButton.classList.remove('pressed'));
            DOMElements.prestigeButton.addEventListener('mouseleave', () => DOMElements.prestigeButton.classList.remove('pressed'));
            DOMElements.prestigeButton.addEventListener('click', prestige);
            DOMElements.exportSaveButton.addEventListener('click', exportSave);
            DOMElements.loadSaveButton.addEventListener('click', loadSave);
            DOMElements.loadSaveButton.addEventListener('mousedown', () => DOMElements.loadSaveButton.classList.add('pressed'));
            DOMElements.loadSaveButton.addEventListener('mouseup', () => DOMElements.loadSaveButton.classList.remove('pressed'));
            DOMElements.loadSaveButton.addEventListener('mouseleave', () => DOMElements.loadSaveButton.classList.remove('pressed'));
            document.getElementById('resetProfile').addEventListener('click', resetProfile);
            document.getElementById('debugButton').addEventListener('click', debugToggle);
            DOMElements.playerEssence.addEventListener('click', () => { showFullEssence = !showFullEssence; updateUI(); });
            DOMElements.bankedClicks.addEventListener('click', () => { showFullBankedClicks = !showFullBankedClicks; updateUI(); });

            // Music icon button
            DOMElements.musicIconButton.addEventListener('mousedown', () => DOMElements.musicIconButton.classList.add('pressed'));
            DOMElements.musicIconButton.addEventListener('mouseup', () => DOMElements.musicIconButton.classList.remove('pressed'));
            DOMElements.musicIconButton.addEventListener('mouseleave', () => DOMElements.musicIconButton.classList.remove('pressed'));
            DOMElements.musicIconButton.addEventListener('click', toggleMusic);

            // Chronicle collapse button
            DOMElements.chronicleCollapseButton.addEventListener('click', toggleChronicleCollapse);

            // Boss ready button
            DOMElements.bossReadyButton.addEventListener('click', toggleBossReady);
            DOMElements.bossReadyButton.addEventListener('mousedown', () => DOMElements.bossReadyButton.classList.add('pressed'));
            DOMElements.bossReadyButton.addEventListener('mouseup', () => DOMElements.bossReadyButton.classList.remove('pressed'));
            DOMElements.bossReadyButton.addEventListener('mouseleave', () => DOMElements.bossReadyButton.classList.remove('pressed'));

            loadGame();
            // Initialize viewer counter - unique per user
            if (!localStorage.getItem('hasVisited')) {
                localStorage.setItem('hasVisited', 'true');
                document.getElementById('viewerCounter').textContent = 'Unique Viewers: 1';
            } else {
                document.getElementById('viewerCounter').textContent = 'Unique Viewers: 1';
            }
            gameState.eventCooldownEndTime = Date.now() + 10000; // Prevent events for 10 seconds on page load
            loadZone();
            updateUI();
            setCursor();

            // Initialize background particles
            const styles = ['combined', 'overlay', 'style3'];
            backgroundCurrentStyle = styles[Math.floor(Math.random() * styles.length)];
            setCanvasSize();
            initBackgroundParticles();
            animateBackgroundParticles();

            // Background particle event listeners
            window.addEventListener('resize', () => {
                setCanvasSize();
                initBackgroundParticles();
            });

            window.addEventListener('mousemove', (event) => {
                backgroundMouse.x = event.x;
                backgroundMouse.y = event.y;
            });

            window.addEventListener('mouseout', () => {
                backgroundMouse.x = null;
                backgroundMouse.y = null;
            });

            // Passive income every second
            setInterval(() => {
                updatePassiveIncome();
                updateUI();
                // Additional safety check: ensure button state is correct after any bank changes
                const buttonCurrentlyDisabled = DOMElements.actionButton.classList.contains('disabled');
                const shouldBeDisabled = (gameState.isBankMode && gameState.bankedClicks >= getBankSize()) ||
                                       (isBossReady() && !DOMElements.bossReadyButton.classList.contains('active'));

                if (buttonCurrentlyDisabled !== shouldBeDisabled) {
                    updateUI(); // Force another update if state is inconsistent
                }
            }, 1000);

            // Helper function to check if boss is ready
            function isBossReady() {
                if (gameState.currentZoneIndex < gameState.zones.length) {
                    const zone = gameState.zones[gameState.currentZoneIndex];
                    return zone.challenges.every(c => c.completed);
                }
                return false;
            }


            // Ensure loading screen shows for at least 1 second to allow UI to settle
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('main-game-container').style.display = 'flex';
            }, 1000);

            // Play background music on first interaction
            document.addEventListener('click', () => {
                const audio = document.getElementById('backgroundMusic');
                if (audio && audio.paused && gameState.musicEnabled) {
                    audio.volume = 0;
                    audio.play().then(() => {
                        fadeInAudio(audio, 0.3, 2000); // fade to 0.3 over 2 seconds
                    }).catch(e => console.log('Audio play failed:', e));
                }
            }, { once: true });

            // Effect Canvas Setup
            canvas = document.getElementById('effect-canvas');
            ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });

            animateParticles();

            // FPS Counter Update
            setInterval(() => {
                fps = frameCount;
                frameCount = 0;
                const fpsEl = document.getElementById('fps-counter');
                if (fpsEl) fpsEl.textContent = `FPS: ${fps}`;
            }, 1000);
        }

        // --- Effect Functions ---

        // Mana Wisps (Gather Effect)
        function manaWisps(e, consecutiveClicks = 1) {
            const baseFloatingWisps = 20; // Original floating wisps
            const attractedWisps = Math.min(consecutiveClicks * 2, 20); // Up to 20 attracted wisps (reduced)

            // Create original floating wisps (old behavior)
            for (let i = 0; i < baseFloatingWisps; i++) {
                createParticle(e.clientX, e.clientY + window.scrollY, {
                    type: 'wisp',
                    mouseAttraction: false // Original floating behavior
                });
            }

            // Create attracted wisps (new clumping behavior) - always create some when consecutive
            for (let i = 0; i < attractedWisps; i++) {
                createParticle(e.clientX, e.clientY + window.scrollY, {
                    type: 'wisp',
                    consecutiveClicks: consecutiveClicks,
                    mouseAttraction: true, // New mouse clumping behavior
                    duration: 1500, // Faster fade away (1.5 seconds vs 2.5 seconds for floating wisps)
                    sizeMultiplier: 1.3 // Make enhanced wisps 30% bigger
                });
            }
        }

        // Force Wave (Store Effect)
        function forceWave(e) {
            // Get button center for attraction
            const buttonRect = DOMElements.actionButton.getBoundingClientRect();
            const buttonCenterX = buttonRect.left + buttonRect.width / 2;
            const buttonCenterY = buttonRect.top + buttonRect.height / 2 + window.scrollY;

            // Main wave ring - MORE VISIBLE
            const wave = {
                x: e.clientX,
                y: e.clientY + window.scrollY,
                radius: 0,
                life: 35, // Increased duration for better visibility
                update() {
                    this.radius += 8.0; // Faster expansion for more prominent effect
                    this.life--;
                },
                draw(ctx) {
                    const screenY = this.y - window.scrollY;

                    // Subtle white wave
                    ctx.strokeStyle = `rgba(255, 255, 255, ${Math.min(this.life / 35 * 0.7, 0.6)})`;
                    ctx.lineWidth = 6 * (this.life / 35); // Reduced thickness
                    ctx.globalAlpha = Math.min(this.life / 35 * 0.8, 0.7); // Reduced opacity
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.4)';
                    ctx.shadowBlur = 4 * (this.life / 35); // Reduced shadow
                    ctx.beginPath();
                    ctx.arc(this.x, screenY, this.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Remove shadow for next elements
                    ctx.shadowBlur = 0;

                    // Subtle white inner highlight ring
                    ctx.strokeStyle = `rgba(255, 255, 255, ${Math.min((this.life / 35) * 0.6, 0.5)})`;
                    ctx.lineWidth = 2 * (this.life / 35); // Reduced thickness
                    ctx.globalAlpha = Math.min((this.life / 35) * 0.8, 0.6);
                    ctx.beginPath();
                    ctx.arc(this.x, screenY, this.radius * 0.25, 0, Math.PI * 2);
                    ctx.stroke();

                    // Remove second inner ring for subtlety
                }
            };
            particles.push(wave);

            // Secondary ripple rings - also more visible
            for (let i = 1; i <= 3; i++) {
                setTimeout(() => {
                    const ripple = {
                        x: e.clientX,
                        y: e.clientY + window.scrollY,
                        radius: 0,
                        delay: i * 4, // Tighter stagger
                        life: 28 - i * 2, // Longer life for each ring
                        ringIndex: i,
                        update() {
                            if (this.delay > 0) {
                                this.delay--;
                                return;
                            }
                            this.radius += 9.5 - this.ringIndex * 1.2; // Faster expansion
                            this.life--;
                        },
                        draw(ctx) {
                            if (this.delay > 0) return;

                            const screenY = this.y - window.scrollY;
                            const alpha = Math.min((this.life / (28 - this.ringIndex * 2)) * (1.0 - this.ringIndex * 0.1), 1);

                            // Subtle white rings
                            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.5})`; // Reduced opacity
                            ctx.lineWidth = (3 - this.ringIndex * 0.6) * alpha; // Thinner lines
                            ctx.globalAlpha = alpha * 0.6; // Reduced overall alpha
                            ctx.shadowColor = 'rgba(255, 255, 255, 0.3)';
                            ctx.shadowBlur = 2 * alpha; // Reduced shadow
                            ctx.beginPath();
                            ctx.arc(this.x, screenY, this.radius, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.shadowBlur = 0;
                        }
                    };
                    particles.push(ripple);
                }, i * 60); // Tighter delay between ripples
            }

            // Add visible button-attracting sparkles (spawn away and get sucked in, gradually increasing)
            let sparkleCount = 0;
            const maxSparkles = 12;
            const batchSizes = [1, 2, 3, 3, 3]; // Gradually increase batch size
            let batchIndex = 0;

            const sparkleInterval = setInterval(() => {
                if (sparkleCount >= maxSparkles || batchIndex >= batchSizes.length) {
                    clearInterval(sparkleInterval);
                    return;
                }

                const batchSize = batchSizes[batchIndex];
                for (let i = 0; i < batchSize && sparkleCount < maxSparkles; i++) {
                    // Spawn at random distance and angle away from button center
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 150 + Math.random() * 100; // 150-250 pixels away
                    const sparkle = {
                        x: buttonCenterX + Math.cos(angle) * distance,
                        y: buttonCenterY + Math.sin(angle) * distance,
                        vx: (Math.random() - 0.5) * 0.5, // Gentler initial movement
                        vy: (Math.random() - 0.5) * 0.5,
                        life: 90, // Longer life for sustained effect
                        maxLife: 90,
                        buttonAttraction: true,
                        buttonCenterX: buttonCenterX,
                        buttonCenterY: buttonCenterY,
                        update() {
                            this.life--;

                            if (this.buttonAttraction && this.life > 0) {
                                // Attract towards button center
                                const dx = this.buttonCenterX - this.x;
                                const dy = this.buttonCenterY - this.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);

                                if (distance > 0) {
                                    const attractionStrength = 0.08; // Stronger attraction to suck in
                                    const attraction = Math.min(attractionStrength, distance * 0.02);
                                    this.vx += (dx / distance) * attraction;
                                    this.vy += (dy / distance) * attraction;
                                }
                            }

                            this.x += this.vx;
                            this.y += this.vy;

                            if (this.buttonAttraction) {
                                this.vx *= 0.98; // Less drag for stronger pull
                                this.vy *= 0.98;
                            }
                        },
                        draw(ctx) {
                            const screenY = this.y - window.scrollY;
                            const alpha = this.life / this.maxLife;

                            // More visible white sparkles
                            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.9})`; // Increased opacity
                            ctx.globalAlpha = alpha * 1.0; // Full opacity

                            const size = (3 + Math.random() * 2) * alpha; // Larger size
                            ctx.beginPath();
                            ctx.arc(this.x, screenY, size, 0, Math.PI * 2);
                            ctx.fill();

                            // More visible sparkle effect
                            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                            ctx.lineWidth = 1.2; // Thicker lines
                            const sparkleSize = 6 * alpha; // Larger sparkle
                            ctx.beginPath();
                            ctx.moveTo(this.x - sparkleSize, screenY);
                            ctx.lineTo(this.x + sparkleSize, screenY);
                            ctx.moveTo(this.x, screenY - sparkleSize);
                            ctx.lineTo(this.x, screenY + sparkleSize);
                            ctx.stroke();

                            // More visible glow effect (for brighter sparkles)
                            if (alpha > 0.6) {
                                ctx.globalAlpha = alpha * 0.4; // Increased glow intensity
                                ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;
                                ctx.beginPath();
                                ctx.arc(this.x, screenY, size * 2, 0, Math.PI * 2); // Larger glow
                                ctx.fill();
                            }
                        }
                    };
                    particles.push(sparkle);
                    sparkleCount++;
                }
                batchIndex++;
            }, 150); // Add batches every 150ms
        }

        // Boss Strike (Attack Effect)
        function bossStrike(e) {
            // Create multiple slash marks
            for (let i = 0; i < 4; i++) {
                const slash = {
                    x: e.clientX,
                    y: e.clientY + window.scrollY,
                    width: 0,
                    maxWidth: 150,
                    height: 3,
                    rotation: Math.random() * 180,
                    life: 15, // 250ms / 16.67 ~15 frames
                    delay: Math.floor(Math.random() * 6), // delay in frames
                    update() {
                        if (this.delay > 0) {
                            this.delay--;
                            return;
                        }
                        if (this.width < this.maxWidth) {
                            this.width += 10; // grow
                        } else {
                            this.width -= 10; // shrink
                        }
                        this.life--;
                    },
                    draw(ctx) {
                        const screenY = this.y - window.scrollY;
                        ctx.save();
                        ctx.translate(this.x, screenY);
                        ctx.rotate(this.rotation * Math.PI / 180);
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = this.height;
                        ctx.globalAlpha = this.life / 15;
                        ctx.beginPath();
                        ctx.moveTo(-this.width / 2, 0);
                        ctx.lineTo(this.width / 2, 0);
                        ctx.stroke();
                        ctx.restore();
                    }
                };
                particles.push(slash);
            }

            // Create impact particles
            for (let i = 0; i < 30; i++) {
                createParticle(e.clientX, e.clientY + window.scrollY, {
                    type: 'spark',
                    gravity: true,
                    speedMultiplier: 1.0,
                    duration: Math.random() * 500 + 400
                });
            }
        }

        // Core logic for simple particles
        function createParticle(x, y, options = {}) {
            const { type, duration = 2500, speedMultiplier = 0.3, gravity = false, consecutiveClicks = 1, mouseAttraction = false, sizeMultiplier = 1.0 } = options;

            const particle = {
                x, y,
                vx: 0, vy: 0,
                life: Math.ceil(duration / 16.67), // assuming ~60fps
                maxLife: Math.ceil(duration / 16.67),
                size: type === 'spark' ? Math.random() * 4 + 1 : type === 'wisp' ? (Math.random() * 8 + 3) * sizeMultiplier : Math.random() * 10 + 5,
                color: type === 'wisp' ? '#00ffff' : type === 'spark' ? `hsl(${Math.random() * 20 + 35}, 100%, 60%)` : '#fff',
                gravity,
                mouseAttraction,
                consecutiveClicks,
                originalX: x,
                originalY: y,
                update() {
                    this.life--;

                    if (this.mouseAttraction && this.life > 0) {
                        // Calculate attraction to mouse position
                        const dx = mousePosition.x - this.x;
                        const dy = mousePosition.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 0) {
                            // Stronger attraction with more consecutive clicks
                            const attractionStrength = (this.consecutiveClicks * 0.5 + 1) * 0.02;
                            const maxDistance = 200; // Maximum attraction distance

                            if (distance < maxDistance) {
                                const attraction = Math.min(attractionStrength * (1 - distance / maxDistance), 0.1);
                                this.vx += (dx / distance) * attraction;
                                this.vy += (dy / distance) * attraction;
                            }
                        }
                    }

                    this.x += this.vx;
                    this.y += this.vy;

                    if (this.gravity) {
                        this.vy += 0.2; // Gravity effect
                    } else if (!this.mouseAttraction) { // Original wisp behavior for non-attracted wisps
                        this.vx += (Math.random() - 0.5) * 0.1; // Gentle sway
                        this.vy *= 0.98;
                    } else {
                        // Apply some drag to mouse-attracted wisps
                        this.vx *= 0.98;
                        this.vy *= 0.98;

                        // Keep wisps somewhat contained around the original click area
                        const dx = this.x - this.originalX;
                        const dy = this.y - this.originalY;
                        const containmentDistance = Math.sqrt(dx * dx + dy * dy);

                        if (containmentDistance > 150) {
                            const containmentStrength = 0.01;
                            this.vx -= (dx / containmentDistance) * containmentStrength;
                            this.vy -= (dy / containmentDistance) * containmentStrength;
                        }
                    }
                },
                draw(ctx) {
                    const screenY = this.y - window.scrollY;
                    ctx.fillStyle = this.color;

                    // Enhanced alpha based on mouse attraction and consecutive clicks
                    let baseAlpha = this.life / this.maxLife;
                    if (this.mouseAttraction) {
                        // Make wisps more visible when attracted to mouse
                        baseAlpha = Math.min(baseAlpha * (1 + this.consecutiveClicks * 0.2), 1);
                    }

                    ctx.globalAlpha = baseAlpha;
                    ctx.beginPath();
                    ctx.arc(this.x, screenY, this.size, 0, Math.PI * 2);
                    ctx.fill();

                    // Add a subtle glow effect for mouse-attracted wisps
                    if (this.mouseAttraction && this.consecutiveClicks > 3) {
                        ctx.globalAlpha = baseAlpha * 0.3;
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(this.x, screenY, this.size * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            };

            const angle = Math.random() * Math.PI * 2;
            const speed = (Math.random() * 5 + 2) * speedMultiplier;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = Math.sin(angle) * speed;

            particles.push(particle);
        }


        function clearAllParticles() {
            particles = [];
        }

        // Mouse move for cursor positioning
        document.addEventListener('mousemove', e => {
            if (customCursor.style.display === 'none') {
                customCursor.style.display = 'block';
            }
            // Hotspot for the up-left rotated crystal tip
            const hotspotX = 9;
            const hotspotY = 9;
            const x = e.clientX - hotspotX;
            const y = e.clientY - hotspotY;
            customCursor.style.transform = `translate3d(${x}px, ${y}px, 0)`;

            // Track mouse position for wisp attraction
            mousePosition.x = e.clientX;
            mousePosition.y = e.clientY + window.scrollY;
        });

        // Clicking animation
        document.addEventListener('mousedown', () => {
            if (customCursor.style.display !== 'none') {
                customCursor.classList.add('clicking');
            }
        });
        document.addEventListener('mouseup', () => {
            customCursor.classList.remove('clicking');
        });

        window.onload = init;

    </script>
</body>
</html>

