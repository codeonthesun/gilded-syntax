<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gilded Syntax</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=MedievalSharp&family=Cinzel:wght@400;700&family=Inter:wght@400;500;600&display=swap" rel="stylesheet">
    <style>
        * {
            cursor: none !important; /* Hide system cursor globally for custom cursors */
        }
        body {
            font-family: 'Inter', sans-serif;
            touch-action: manipulation; /* Prevents double-tap zoom on mobile */
            caret-color: transparent; /* Hides the blinking text caret */
        }
        .font-cinzel {
            font-family: 'Cinzel', serif;
        }
        .chat-log::-webkit-scrollbar {
            display: none;
        }
        .chat-log {
            scrollbar-width: none;
        }
        .chat-log.collapsed > div:not(:last-child) {
            display: none;
        }
        .chat-log.collapsed {
            height: 4rem;
        }
        .boss-timer-bar {
            transition: width 0.1s linear;
        }
        .tooltip {
            position: relative;
        }
        .tooltip::after {
            content: attr(data-tooltip);
            position: absolute;
            bottom: 100%;
            left: 50%;
            transform: translateX(-50%) translateY(4px);
            background: #1f2937;
            color: #f9fafb;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 14px;
            font-family: 'Inter', sans-serif;
            line-height: 1.4;
            white-space: normal;
            word-break: break-word;
            text-align: left;
            min-width: 200px;
            max-width: 400px;
            max-height: 200px;
            overflow-y: auto;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s;
            z-index: 2000;
            border: 2px solid #374151;
            box-shadow: 0 4px 8px rgba(0,0,0,0.3);
        }
        .tooltip:hover::after {
            opacity: 1;
        }
        .tooltip.above::after {
            bottom: 100%;
            top: auto;
            transform: translateX(-50%) translateY(4px);
        }
        .tooltip.below::after {
            top: 100%;
            left: 100%;
            bottom: auto;
            transform: translateX(0) translateY(0);
        }
        .tooltip.left::after {
            top: 50%;
            left: 0;
            bottom: auto;
            transform: translateX(-120%) translateY(-50%);
        }
        .tooltip.right::after {
            top: 50%;
            left: 100%;
            bottom: auto;
            transform: translateX(40px) translateY(10px);
        }
        #zoneObjectivesContainer, #bankContainer {
            transition: order 0.5s ease-in-out;
        }
        .glow {
            animation: faintGlow 1.5s infinite ease-in-out;
            position: relative;
        }
        .glow::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            width: 0;
            height: 2px;
            background: currentColor;
            box-shadow: 0 0 8px currentColor;
            animation: trace 0.6s ease forwards;
        }
        .glow-static {
            animation: faintGlow 1.5s infinite ease-in-out;
        }
        @keyframes faintGlow {
            0%, 100% { text-shadow: 0 0 8px currentColor; }
            50% { text-shadow: 0 0 15px currentColor; }
        }
        @keyframes trace {
            0% { width: 0; }
            100% { width: 100%; }
        }

        /* --- Generic Button Styles --- */
        .btn {
            cursor: pointer;
            border: none;
            background: none;
            padding: 0;
            font-family: 'MedievalSharp', cursive;
            color: white;
            text-shadow: 1px 1px 3px rgba(0, 0, 0, 0.7);
            transition: all 0.1s ease-in-out;
            position: relative;
            -webkit-tap-highlight-color: transparent; /* Removes blue highlight on mobile tap */
        }

        /* Fixed size for action buttons */
        .action-btn {
            width: 160px;
            height: 128px;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .action-btn .content {
            display: none;
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            justify-content: center;
            align-items: center;
        }

        .action-btn.gather-mode .gather-content { display: flex; }
        .action-btn.gather-mode { width: 128px; height: 128px; }
        .action-btn.boss-mode .boss-content { display: flex; }
        .action-btn.boss-mode .boss-content { display: flex; }
        .action-btn.boss-mode { height: 80px; }
        .action-btn.attack-mode .attack-content { display: flex; }
        .action-btn.attack-mode { height: 80px; }
        .action-btn.store-mode .store-content { display: flex; }

        .btn:focus {
            outline: none;
        }

        /* --- Style 2: Dragon Scale Button --- */
        .scale-btn {
            background: linear-gradient(135deg, #6d0000, #a50000);
            border: 3px solid #3b0000;
            border-radius: 15px;
            font-size: 22px;
            height: 72px;
            box-shadow: 0 6px 0 #3b0000, 0 8px 12px rgba(0,0,0,0.5), inset 0 0 8px rgba(255,165,0,0.3);
            overflow: hidden;
        }

        .scale-btn::before { /* Scale pattern overlay */
            content: "";
            position: absolute;
            top: 0; left: -50%;
            width: 200%; height: 200%;
            background-image:
                radial-gradient(circle at 15px 15px, rgba(255,255,255,0.05) 5px, transparent 5.5px),
                radial-gradient(circle at 0 0, rgba(255,255,255,0.05) 5px, transparent 5.5px);
            background-size: 15px 15px;
        }

        .scale-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 10px 0 #3b0000, 0 12px 20px rgba(0,0,0,0.45), inset 0 0 15px rgba(255,165,0,0.5);
        }

        .scale-btn:active {
            transform: translateY(4px);
            box-shadow: 0 4px 0 #3b0000, 0 6px 8px rgba(0,0,0,0.6), inset 0 0 25px rgba(255,165,0,0.7);
            background: linear-gradient(135deg, #8b0000, #c00);
        }

        /* --- Style 3: Gold Coin Pile Button --- */
        .coin-pile-btn {
            position: relative;
        }
        .coin-pile-btn .coin {
            position: absolute;
            width: 90px;
            height: 90px;
            background: radial-gradient(circle, #f0c36b 0%, #d4a24a 60%, #a97f33 100%);
            border-radius: 50%;
            box-shadow: 0 5px 0 #6d5220, 0 8px 10px rgba(0,0,0,0.5);
            transition: all 0.15s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            display: flex;
            align-items: center;
            justify-content: center;
            left: 50%;
        }
        .coin-pile-btn .top-coin {
            font-size: 22px;
            color: #4d3817;
            text-shadow: 1px 1px 1px rgba(255, 230, 179, 0.5);
            z-index: 5;
            transform: translateX(-50%);
            top: 15px;
        }
        .coin-pile-btn .mid-coin {
            z-index: 4;
            transform: translateX(calc(-50% - 10px)) rotate(-10deg);
            background: radial-gradient(circle, #d4a24a 0%, #a97f33 60%, #8b662b 100%);
            top: 20px;
        }
        .coin-pile-btn .bottom-coin {
            z-index: 3;
            transform: translateX(calc(-50% + 10px)) rotate(15deg);
            background: radial-gradient(circle, #c89b3c 0%, #a97f33 60%, #6d5220 100%);
            top: 25px;
        }
        .coin-pile-btn .left-coin {
            z-index: 2;
            transform: translateX(calc(-50% - 35px)) rotate(-20deg);
            background: radial-gradient(circle, #a97f33 0%, #8b662b 60%, #4d3817 100%);
            top: 30px;
        }
        .coin-pile-btn .right-coin {
            z-index: 1;
            transform: translateX(calc(-50% + 35px)) rotate(20deg);
            background: radial-gradient(circle, #a97f33 0%, #8b662b 60%, #4d3817 100%);
            top: 35px;
        }
        .coin-pile-btn:hover .top-coin {
            transform: translateX(-50%) translateY(-4px) scale(1.02);
        }
        .coin-pile-btn:hover .mid-coin {
            transform: translateX(calc(-50% - 12px)) translateY(-1px) rotate(-12deg);
        }
        .coin-pile-btn:hover .bottom-coin {
            transform: translateX(calc(-50% + 12px)) translateY(-1px) rotate(17deg);
        }
        .coin-pile-btn:hover .left-coin {
            transform: translateX(calc(-50% - 37px)) translateY(-1px) rotate(-22deg);
        }
        .coin-pile-btn:hover .right-coin {
            transform: translateX(calc(-50% + 37px)) translateY(-1px) rotate(22deg);
        }
        .coin-pile-btn:active .coin {
            transition: all 0.05s ease-in-out;
        }
        .coin-pile-btn:active .top-coin {
            transform: translateX(-50%) translateY(4px);
            box-shadow: 0 2px 0 #6d5220, 0 4px 5px rgba(0,0,0,0.6), inset 0 0 15px rgba(0,0,0,0.5);
        }
        .coin-pile-btn:active .mid-coin {
            transform: translateX(calc(-50% - 8px)) translateY(2px) rotate(-5deg);
        }
        .coin-pile-btn:active .bottom-coin {
            transform: translateX(calc(-50% + 8px)) translateY(4px) rotate(10deg);
        }
        .coin-pile-btn:active .left-coin {
            transform: translateX(calc(-50% - 30px)) translateY(3px) rotate(-15deg);
        }
        .coin-pile-btn:active .right-coin {
            transform: translateX(calc(-50% + 30px)) translateY(4px) rotate(15deg);
        }


        /* --- Style 4: Arcane Crystal Button --- */
        .crystal-btn-wrapper {
            position: relative;
            display: flex;
            align-items: center;
            justify-content: center;
            animation: float 6s ease-in-out infinite;
        }

        .crystal-btn-wrapper::after {
            content: '';
            position: absolute;
            bottom: -40px;
            left: 50%;
            transform: translateX(-50%);
            width: 80px;
            height: 20px;
            background: radial-gradient(ellipse at center, rgba(37, 150, 190, 0.4) 0%, rgba(37, 150, 190, 0.1) 70%, transparent 100%);
            border-radius: 50%;
            animation: shadowFloat 6s ease-in-out infinite;
            z-index: -1;
        }

        .crystal-btn {
            width: 120px;
            height: 120px;
            background: radial-gradient(circle, #4fc3f7 0%, #2596be 100%);
            clip-path: polygon(50% 0%, 100% 25%, 100% 75%, 50% 100%, 0% 75%, 0% 25%);
            font-size: 24px;
            display: flex;
            align-items: center;
            justify-content: center;
            text-align: center;
            line-height: 1.1;
            box-shadow: 0 0 15px #2596be, 0 0 25px #2596be, 0 0 35px #81d4fa;
        }

        .crystal-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            border-radius: 50%;
            z-index: -1;
            width: 120px;
            height: 120px;
            background: rgba(37, 150, 190, 0.2);
        }


        .crystal-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 25px #4fc3f7, 0 0 40px #4fc3f7, 0 0 55px #b3e5fc;
        }

        .crystal-btn:active {
            transform: scale(0.95);
            background: radial-gradient(circle, #81d4fa 0%, #2596be 100%);
            box-shadow: 0 0 10px #4fc3f7, 0 0 20px #4fc3f7, 0 0 30px #b3e5fc, inset 0 0 20px #fff;
            transition: all 0.05s ease-in-out;
        }

        @keyframes float {
            0% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
            100% { transform: translateY(0px); }
        }

        @keyframes shadowFloat {
            0% {
                width: 80px;
                height: 20px;
                opacity: 0.6;
                bottom: -40px;
            }
            50% {
                width: 120px;
                height: 30px;
                opacity: 0.3;
                bottom: -55px;
            }
            100% {
                width: 80px;
                height: 20px;
                opacity: 0.6;
                bottom: -40px;
            }
        }

        @keyframes pulse {
            0% { transform: translate(-50%, -50%); opacity: 0.7; }
            70% { transform: translate(-50%, -50%); opacity: 0; }
            100% { transform: translate(-50%, -50%); opacity: 0; }
        }

        /* Custom Cursor Styles */
        .custom-cursor {
            position: fixed;
            top: 0;
            left: 0;
            width: 48px;
            height: 48px;
            z-index: 9999;
            pointer-events: none;
            transition: transform 0.05s ease-out;
        }

        .custom-cursor svg {
            width: 100%;
            height: 100%;
            transform-origin: center;
            transition: transform 0.1s ease-out;
            filter: drop-shadow(2px 2px 3px rgba(0,0,0,0.6));
        }

        /* Pulse animation for crystal cursors */
        .custom-cursor[data-shape="fireCrystal"] svg,
        .custom-cursor[data-shape="shadowCrystal"] svg,
        .custom-cursor[data-shape="shardCluster"] svg {
            animation: pulse 3s infinite ease-in-out;
        }

        @keyframes pulse {
            0% { transform: scale(0.95); }
            70% { transform: scale(1.1); }
            100% { transform: scale(0.95); }
        }

        /* Clicking animation */
        .custom-cursor.clicking svg {
            transform: scale(0.85);
        }
        .shake {
            animation: shake 0.7s ease-in-out;
            transform: translate3d(0, 0, 0);
        }
        @keyframes shake {
            10%, 90% { transform: translate3d(-1px, 0, 0); }
            20%, 80% { transform: translate3d(2px, 0, 0); }
            30%, 50%, 70% { transform: translate3d(-4px, 0, 0); }
            40%, 60% { transform: translate3d(4px, 0, 0); }
        }
        .fade-in {
            animation: fadeIn 0.5s ease-in-out;
        }
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        .objectives-overlay {
            position: absolute;
            top: -0.5rem;
            left: -0.6rem;
            right: -0.6rem;
            bottom: 0;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #f9fafb;
            font-family: 'Cinzel', serif;
            font-size: 1.125rem;
            font-weight: bold;
            z-index: 10;
        }
        /* Global blur effect for visually disabling completed or disabled modules */
        .module-blur {
            filter: blur(2px);
            opacity: 0.7;
        }
        .pressed {
            transform: scale(0.95);
            transition: transform 0.1s ease-out;
        }

        .disabled {
            pointer-events: none;
            opacity: 0.6;
        }

        .disabled:hover {
            transform: none;
        }

        /* Effect Canvas and Particles */
        canvas {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            pointer-events: none;
            z-index: 99;
        }

        /* Background Particle Canvas */
        #particleCanvas {
            z-index: -1;
            pointer-events: none;
            background-color: #111827;
        }

        /* Rarity Effects */
        :root {
            --common: #808080;
            --uncommon: #2ecc71;
            --rare: #3498db;
            --epic: #8e44ad;
            --legendary: #f39c12;
        }

        .rarity-prefix {
            font-size: 0.9rem;
            font-weight: 700;
            text-transform: uppercase;
            letter-spacing: 1px;
            position: relative;
            display: inline-block;
            margin-right: 0.75rem;
        }
        .rarity-prefix span {
            position: relative;
            display: inline-block;
            z-index: 1;
        }

        .common { color: var(--common); }
        .uncommon {
            color: var(--uncommon);
            animation: uncommon-glow 1000s infinite ease-in-out;
        }
        @keyframes uncommon-glow {
            0%, 100% { text-shadow: 0 0 3px var(--uncommon); }
            50% { text-shadow: 0 0 8px var(--uncommon); }
        }
        .rare {
            color: var(--rare);
            animation: rare-shimmer 1000s infinite alternate;
        }
        @keyframes rare-shimmer {
            from { text-shadow: 0 0 10px var(--rare), 0 0 15px var(--rare); }
            to { text-shadow: 0 0 20px var(--rare), 0 0 30px #a9d6f5; }
        }
        .epic {
            color: var(--epic);
            animation: epic-void 1000s infinite ease-in-out;
        }
        @keyframes epic-void {
            0%, 100% {
                text-shadow: 0 0 5px #000, 0 0 8px var(--epic), 0 0 12px #c39bd3;
                transform: scale(1);
            }
            50% {
                text-shadow: 0 0 8px #000, 0 0 15px var(--epic), 0 0 25px #c39bd3;
                transform: scale(1.03);
            }
        }
        .legendary {
            color: #f7d674;
            animation: legendary-fire 1000s infinite linear;
        }
        .legendary::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 120%;
            height: 140%;
            transform: translate(-50%, -50%);
            border: 3px solid transparent;
            border-radius: 10px;
            animation: legendary-border-glow 2.5s infinite ease-in-out;
        }
        @keyframes legendary-fire {
            0%, 100% {
                text-shadow: 0 0 10px #f39c12, 0 0 20px #e67e22, 0 0 30px #d35400;
            }
            50% {
                text-shadow: 0 0 12px #f1c40f, 0 0 24px #e67e22, 0 0 36px #d35400;
            }
        }
        @keyframes legendary-border-glow {
            0%, 100% {
                border-color: #f39c12;
                box-shadow: 0 0 15px #f39c12;
            }
            50% {
                border-color: #f1c40f;
                box-shadow: 0 0 25px #f1c40f, 0 0 5px #fff inset;
            }
        }

        /* Base label styling */
        .label-container {
            background-color: #6b1a1a;
            border: 1px solid #374151;
            border-radius: 0;
            position: relative;
            overflow: hidden;
            transition: all 0.3s ease;
        }

        /* UI Background */
        .ui-bg {
            background-color: #18212f;
        }

        /* --- Idle Effect 5: Infernal Embers --- */
        .effect-embers {
            border-color: rgba(255, 100, 0, 0.3);
            animation: embers-glow 4s infinite ease-in-out;
        }
        .effect-embers .ember {
            position: absolute;
            background-color: #ff4500;
            border-radius: 20% 80% 40% 60% / 60% 30% 70% 40%; /* Irregular shape */
            opacity: 0;
            animation: float-ember 8s infinite linear;
            box-shadow: 0 0 5px #ff8c00, 0 0 10px #ff4500;
        }

        @keyframes embers-glow {
              0%, 100% {
                 box-shadow: 0 0 15px rgba(255, 69, 0, 0.2), 0 0 20px rgba(255, 69, 0, 0.1) inset;
             }
             50% {
                 box-shadow: 0 0 25px rgba(255, 69, 0, 0.4), 0 0 30px rgba(255, 69, 0, 0.2) inset;
             }
        }

        @keyframes float-ember {
            0% { transform: translateY(0) scale(1.2) rotate(0deg); opacity: 0; }
            20%, 80% { opacity: 0.9; }
            100% { transform: translateY(-120px) scale(0.2) rotate(360deg); opacity: 0; }
        }

    </style>
</head>
<body class="ui-bg text-gray-200 overflow-auto min-h-screen">
    <audio id="backgroundMusic" src="664408__seth_makes_sounds__whimsical-melancholic-song-thing.wav" preload="auto" loop></audio>

    <!-- Loading Screen -->
    <div id="loading-screen" class="fixed inset-0 ui-bg flex items-center justify-center z-50">
        <div class="text-center">
            <img src="logo.png" alt="Gilded Syntax" class="h-16 mx-auto mb-4 object-contain">
            <div class="text-gray-400 animate-pulse">Preparing your adventure</div>
        </div>
    </div>

    <!-- Custom Cursor -->
    <div id="custom-cursor" class="custom-cursor" style="display: none;"></div>
    <!-- Custom Cursor -->
    <div id="custom-cursor" class="custom-cursor" style="display: none;"></div>

    <canvas id="particleCanvas"></canvas>
    <canvas id="effect-canvas"></canvas>

    <!-- SVG Definitions -->
    <div style="display: none;">
        <div id="crystalSVG">
            <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 32 32">
                <defs>
                    <linearGradient id="crystalGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                        <stop offset="0%" style="stop-color:#ffff00;stop-opacity:1" />
                        <stop offset="100%" style="stop-color:#ffd700;stop-opacity:1" />
                    </linearGradient>
                    <filter id="crystalGlow" x="-50%" y="-50%" width="200%" height="200%">
                        <feGaussianBlur stdDeviation="1.5" result="coloredBlur"/>
                        <feMerge>
                            <feMergeNode in="coloredBlur"/>
                            <feMergeNode in="SourceGraphic"/>
                        </feMerge>
                    </filter>
                </defs>
                <g filter="url(#crystalGlow)" transform="rotate(135 16 16)">
                    <path d="M16 2 L22 12 L16 30 L10 12 Z" fill="url(#crystalGradient)" stroke="#daa520" stroke-width="1.5"/>
                    <path d="M16 2 L10 12 L16 9 Z" fill="#ffffff" opacity="0.7"/>
                    <path d="M16 2 L22 12 L16 9 Z" fill="#fffacd" opacity="0.7"/>
                </g>
            </svg>
        </div>
    </div>

    <!-- Main Game Container -->
    <div id="main-game-container" class="flex flex-col md:flex-row min-h-screen w-full max-w-7xl mx-auto p-2 md:p-4 gap-4" style="display: none;">

        <!-- Left Panel: Chat/Log and Player Stats -->
        <div class="flex flex-col w-full md:w-1/3 md:h-full gap-4">
            <!-- Game Title and Active Events -->
            <div class="ui-bg rounded-lg p-4 shadow-lg border border-gray-700 relative">
                <button id="musicIconButton" class="absolute top-2 left-2 text-white text-xl btn tooltip right" style="z-index: 2001;" data-tooltip="Toggle background music">♪</button>
                <div class="text-center mb-4">
                    <img src="logo.png" alt="Gilded Syntax" data-tooltip="Gilded Syntax - Clicker Adventure Game" class="h-12 md:h-16 mx-auto tooltip object-contain">
                    <p class="text-sm text-gray-400">Your journey begins...</p>
                </div>
                <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 flex justify-between items-center">
                    <span class="tooltip" data-tooltip="Active random events">Active Events</span>
                    <span class="text-xs text-gray-500" id="eventFlavorText"></span>
                </h2>
                <div id="activeEventsList" class="space-y-1 text-sm">
                    <!-- Events will be injected here -->
                </div>
            </div>

            <!-- Chat Log -->
            <div class="ui-bg rounded-lg p-4 shadow-lg flex-grow flex flex-col border border-gray-700 h-full">
                <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 flex justify-between items-center">
                    <span class="tooltip" data-tooltip="Game log and messages">Chronicle</span>
                    <button id="chronicleCollapseButton" class="btn text-sm px-2 py-1 bg-gray-700 hover:bg-gray-600 text-white rounded"><span style="font-family: monospace;">▼</span> Collapse</button>
                </h2>
                <div id="chatLog" class="chat-log h-72 overflow-y-auto pr-2 space-y-2 text-sm">
                    <!-- Messages will be injected here -->
                </div>
            </div>

            <!-- Player Stats -->
            <div class="ui-bg rounded-lg p-4 shadow-lg border border-gray-700">
                <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 tooltip right" data-tooltip="Your current stats and progress">Adventurer</h2>
                <div class="space-y-2 text-sm">
                    <div class="flex justify-between"><span class="tooltip right" data-tooltip="Your current adventurer title">Title:</span> <span id="playerTitle" class="font-bold text-amber-400"></span></div>
                    <div class="flex justify-between"><span class="tooltip right" data-tooltip="Your adventurer level">Level:</span> <span id="playerLevel" class="font-bold text-white"></span></div>
                    <div class="w-full bg-gray-700 rounded-full h-2 tooltip right" data-tooltip="XP progress to next level">
                        <div id="xpBar" class="bg-blue-500 h-full rounded-full transition-all duration-300" style="width: 0%"></div>
                    </div>
                    <div class="text-xs text-gray-400 mt-1" id="xpText">0 / 100</div>
                    <div class="flex justify-between"><span class="tooltip right" data-tooltip="Total essence collected">Essence:</span> <span id="playerEssence" class="font-bold text-cyan-400"></span></div>
                    <div class="flex justify-between"><span class="tooltip right" data-tooltip="Essence gained per click">Essence/Click:</span> <span id="essencePerClick" class="font-bold text-cyan-300"></span></div>
                    <div class="flex justify-between"><span class="tooltip right" data-tooltip="Essence gained passively per second">Passive/sec:</span> <span id="passiveIncome" class="font-bold text-green-400"></span></div>
                    <div class="flex justify-between"><span class="tooltip right" data-tooltip="Damage dealt per attack during boss fights">Attack:</span> <span id="playerAttack" class="font-bold text-red-400"></span></div>
                    <div class="flex justify-between"><span class="tooltip right" data-tooltip="Critical hit chance">Crit Chance:</span> <span id="playerCritChance" class="font-bold text-red-400"></span></div>
                    <div class="flex justify-between"><span class="tooltip right" data-tooltip="Critical hit damage multiplier">Crit Multiplier:</span> <span id="playerCritMult" class="font-bold text-red-300"></span></div>
                    <div class="flex justify-between"><span class="tooltip right" data-tooltip="Daily login streak">Streak:</span> <span id="playerStreak" class="font-bold text-orange-400"></span></div>
                </div>
            </div>

            <!-- Achievements -->
            <div class="ui-bg rounded-lg p-4 shadow-lg border border-gray-700">
                <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 tooltip" data-tooltip="Unlocked achievements and milestones">Achievements</h2>
                <div id="achievementsList" class="space-y-1 text-sm">
                    <!-- Achievements will be injected here -->
                </div>
            </div>

            <!-- Prestige -->
            <div class="ui-bg rounded-lg p-4 shadow-lg border border-gray-700">
                <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 tooltip" data-tooltip="Prestige system for resetting progress and gaining permanent multipliers">Prestige</h2>
                <p class="text-sm text-gray-400 mb-2">Reset your progress for prestige points. Requires Level 50.</p>
                <p class="text-sm">Prestige Points: <span id="prestigePoints" class="font-bold text-purple-400"></span></p>
                <button id="prestigeButton" data-tooltip="Reset progress to gain prestige points for permanent multipliers. Requires level 50." class="bg-purple-700 hover:bg-purple-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip">Prestige</button>
                <button id="exportSaveButton" data-tooltip="Export your save data to clipboard for sharing or backup" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip">Export Save</button>
                <input id="loadSaveInput" type="text" placeholder="Paste save code here" class="bg-gray-600 text-white px-2 py-1 rounded mr-2 mt-2 w-full">
                <button id="loadSaveButton" data-tooltip="Load save data from code" class="bg-blue-700 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip mt-2">Load Save</button>
                <button id="resetProfile" data-tooltip="Reset all progress and start fresh" class="bg-red-600 hover:bg-red-500 text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip">Reset Profile</button>
                <button id="debugButton" data-tooltip="Debug: Toggle essence between 1M and 0" class="bg-purple-700 hover:bg-purple-600 text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip">Debug</button>
            </div>

            <!-- Unique Viewers Counter -->
            <div class="text-xs text-gray-500 mt-2 text-center" id="viewerCounter">Unique Viewers: 1</div>
            <div class="text-xs text-gray-500 text-center">(Credits)</div>
        </div>

        <!-- Right Panel: Action, Quests, Bank -->
        <div class="flex flex-col w-full md:w-2/3 md:h-full gap-4">

            <!-- Action Area -->
            <div id="actionArea" class="ui-bg rounded-lg p-4 shadow-lg flex-grow flex flex-col justify-center items-center border border-gray-700 relative overflow-hidden min-h-[500px]">
                <div id="fps-counter" class="absolute top-2 right-2 text-white text-sm font-bold bg-black/50 px-2 py-1 rounded">FPS: 0</div>
                <!-- Boss UI will be injected here -->
                <div id="bossContainer" class="absolute inset-0 label-container effect-embers z-10 hidden flex-col justify-center items-center p-4 text-center"></div>

                <h2 id="zoneName" data-tooltip="The zone you are currently exploring" class="font-cinzel text-2xl md:text-3xl font-bold text-white mb-4 tooltip below"></h2>
                <p id="actionPrompt" title="Instructions for gathering essence in this zone" class="text-gray-400 mb-6 text-center"></p>
                <button id="actionButton" class="btn action-btn gather-mode">
                    <div class="content gather-content">
                        <div class="crystal-btn-wrapper">
                            <div class="crystal-btn">Gather</div>
                        </div>
                    </div>
                    <div class="content boss-content scale-btn">BOSS</div>
                    <div class="content attack-content scale-btn">ATTACK</div>
                    <div class="content store-content coin-pile-btn">
                        <div class="coin right-coin"></div>
                        <div class="coin left-coin"></div>
                        <div class="coin bottom-coin"></div>
                        <div class="coin mid-coin"></div>
                        <div class="coin top-coin">Vault</div>
                    </div>
                </button>
                <div id="click-feedback-container" class="absolute top-0 left-0 w-full h-full pointer-events-none"></div>
                <div id="specialMechanicDisplay" class="mt-4 text-center"></div>
            </div>

            <!-- Quests/Challenges -->
            <div id="zoneObjectivesContainer" class="ui-bg rounded-lg p-4 shadow-lg border border-gray-700 transition-all duration-500 ease-in-out">
                  <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 flex justify-between items-center">
                      <span class="tooltip" data-tooltip="Current zone challenges to complete">Zone Objectives</span>
                      <span class="text-xs text-gray-500 tooltip left" id="zoneFlavorText" data-tooltip="Completed objectives / Total objectives for this zone"></span>
                  </h2>
                  <div id="questList" class="space-y-2 text-sm">
                      <!-- Quests will be injected here -->
                  </div>
            </div>
            
            <!-- Bank Mode -->
            <div id="bankContainer" class="ui-bg rounded-lg p-4 shadow-lg border border-gray-700 transition-all duration-500 ease-in-out">
                <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 flex justify-between items-center">
                    <div class="flex items-center gap-2">
                        <span class="tooltip" data-tooltip="Bank system for storing clicks">Essence Bank</span>
                        <span class="text-xs text-gray-500">Interest: +<span id="interestRate"></span>/sec | Accrued: <span id="accumulatedInterest"></span></span>
                    </div>
                    <label class="inline-flex items-center cursor-pointer tooltip" data-tooltip="Toggle bank mode to store clicks instead of generating essence">
                        <span class="mr-3 text-sm font-medium text-gray-300">Bank Mode</span>
                        <input type="checkbox" id="bankModeToggle" class="sr-only peer">
                        <div class="relative w-11 h-6 bg-gray-600 peer-focus:outline-none rounded-full peer peer-checked:after:translate-x-full rtl:peer-checked:after:-translate-x-full peer-checked:after:border-white after:content-[''] after:absolute after:top-[2px] after:start-[2px] after:bg-white after:border-gray-300 after:border after:rounded-full after:h-5 after:w-5 after:transition-all peer-checked:bg-green-600"></div>
                    </label>
                </h2>
                <p class="text-center text-sm mb-4"><span class="tooltip" data-tooltip="Clicks stored in bank for auto-clicker / Maximum clicks that can be stored">Stored Clicks: <span id="bankedClicks" class="font-bold text-green-400"></span> / <span id="bankSize" class="font-bold text-gray-400"></span></span></p>
                <div class="flex items-center gap-4 text-sm justify-center">
                    <button id="autoClickButton" data-tooltip="Toggle auto-clicker on/off. Costs 1 banked click per second." class="bg-green-700 hover:bg-green-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip">
                        Auto-Clicker: Off
                    </button>
                    <button id="bankBoostButton" data-tooltip="Spend 50 banked clicks to double passive income for 60 seconds" class="bg-blue-700 hover:bg-blue-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip">
                        Bank Boost (50 Clicks)
                    </button>
                    <button id="hireCEOButton" data-tooltip="Spend 100 banked clicks to hire CEO for 2.5 minutes, providing bonus clicks on every manual click" class="bg-purple-700 hover:bg-purple-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip">
                        Hire CEO (100 Clicks)
                    </button>
                    <button id="bankInvestmentButton" data-tooltip="Spend 100 banked clicks for risky investment: 2x passive income for 30 seconds, but lose 20% of bank if interrupted by boss fight" class="bg-orange-700 hover:bg-orange-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip">
                        Risky Investment (100 Clicks)
                    </button>
                    <button id="convertClicksButton" data-tooltip="Convert banked clicks to essence (1 click = 2 essence)" class="bg-teal-700 hover:bg-teal-600 disabled:bg-gray-600 disabled:cursor-not-allowed text-white font-bold py-2 px-4 rounded transition-colors duration-200 tooltip">
                        Convert to Essence
                    </button>
                </div>
                 <p class="text-xs text-gray-500 mt-2">Cost: 1 click/second. Generates <span id="autoClickRate"></span> essence/second.</p>
            </div>

            <!-- Upgrades -->
            <div class="ui-bg rounded-lg p-4 shadow-lg border border-gray-700">
                <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 flex justify-between items-center tooltip" data-tooltip="Permanent upgrades to boost your progress">
                    <div class="flex items-center gap-2">
                        <span>Upgrades</span>
                        <span class="text-xs text-gray-500 text-left" id="upgradeFlavor"></span>
                    </div>
                    <span class="text-xs text-gray-500">Essence: <span id="headerEssence"></span></span>
                </h2>
                <div class="space-y-2 text-sm">
                    <div class="flex justify-between items-center">
                        <span id="clickLabel">Click Power (Lv.0)</span>
                        <button id="upgradeClick" data-tooltip="Increases essence gained per click by 10% per level" class="bg-blue-700 hover:bg-blue-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (100 Ess)</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span id="passiveLabel">Passive Income (Lv.0)</span>
                        <button id="upgradePassive" data-tooltip="Increases passive essence income by 10% per level" class="bg-purple-700 hover:bg-purple-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (200 Ess)</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span id="bankLabel">Bank Capacity (Lv.0)</span>
                        <button id="upgradeBank" data-tooltip="Increases bank capacity by 10% per level" class="bg-green-700 hover:bg-green-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (150 Ess)</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span id="autoLabel">Auto-Clicker (Lv.0)</span>
                        <button id="upgradeAutoClick" data-tooltip="Increases auto-click rate by 10% per level" class="bg-red-700 hover:bg-red-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (250 Ess)</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span id="critChanceLabel">Critical Chance (Lv.0)</span>
                        <button id="upgradeCritChance" data-tooltip="Increases critical hit chance by 5% per level" class="bg-orange-700 hover:bg-orange-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (300 Ess)</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span id="critMultLabel">Critical Multiplier (Lv.0)</span>
                        <button id="upgradeCritMult" data-tooltip="Increases critical hit damage multiplier by 0.5x per level" class="bg-pink-700 hover:bg-pink-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (400 Ess)</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span id="luckLabel">Luck (Lv.0)</span>
                        <button id="upgradeLuck" data-tooltip="Increases critical hit chance by 5% per level" class="bg-indigo-700 hover:bg-indigo-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (500 Ess)</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span id="efficiencyLabel">Efficiency (Lv.0)</span>
                        <button id="upgradeEfficiency" data-tooltip="Reduces upgrade costs by 5% per level" class="bg-teal-700 hover:bg-teal-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (600 Ess)</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span id="regenerationLabel">Regeneration (Lv.0)</span>
                        <button id="upgradeRegeneration" data-tooltip="Increases passive income rate by 10% per level" class="bg-emerald-700 hover:bg-emerald-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (700 Ess)</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span id="timeCrystalLabel">Time Crystal (Lv.0)</span>
                        <button id="upgradeTimeCrystal" data-tooltip="Increases offline progress cap by 30 minutes per level" class="bg-cyan-700 hover:bg-cyan-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Upgrade (1000 Ess)</button>
                    </div>
                </div>
            </div>


            <!-- Companions -->
            <div class="ui-bg rounded-lg p-4 shadow-lg border border-gray-700">
                <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 tooltip" data-tooltip="Summon companions for bonuses">
                    <div class="flex items-center gap-2">
                        <span>Companions</span>
                        <span class="text-xs text-gray-500 text-left" id="companionFlavor"></span>
                    </div>
                </h2>
                <div id="companionsList" class="space-y-2 text-sm mb-4">
                    <!-- Companions will be injected here -->
                </div>
                <div class="space-y-2 text-sm">
                    <div class="flex justify-between items-center">
                        <span class="text-gray-500">Fire Sprite (Level: 5) (1000 Ess)</span>
                        <button id="summonFireSprite" data-tooltip="Summon Fire Sprite for +10% click power" class="bg-red-700 hover:bg-red-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Summon</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-gray-500">Water Nymph (Level: 10) (2000 Ess)</span>
                        <button id="summonWaterNymph" data-tooltip="Summon Water Nymph for +10% passive income" class="bg-blue-700 hover:bg-blue-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Summon</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-gray-500">Earth Golem (Level: 15) (3000 Ess)</span>
                        <button id="summonEarthGolem" data-tooltip="Summon Earth Golem for +10% bank capacity" class="bg-green-700 hover:bg-green-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Summon</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-gray-500">Air Spirit (Level: 20) (4000 Ess)</span>
                        <button id="summonAirSpirit" data-tooltip="Summon Air Spirit for +10% auto-click rate" class="bg-gray-700 hover:bg-gray-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Summon</button>
                    </div>
                    <div class="flex justify-between items-center">
                        <span class="text-gray-500">Shadow Imp (Level: 25) (5000 Ess)</span>
                        <button id="summonShadowImp" data-tooltip="Summon Shadow Imp for +5% critical chance" class="bg-purple-700 hover:bg-purple-600 text-white font-bold py-1 px-2 rounded text-xs tooltip left">Summon</button>
                    </div>
                </div>
            </div>

            <!-- Relics -->
            <div class="ui-bg rounded-lg p-4 shadow-lg border border-gray-700">
                <h2 class="font-cinzel text-lg font-bold text-gray-300 mb-2 border-b border-gray-600 pb-2 tooltip" data-tooltip="Collected relics from boss fights">Relics</h2>
                <div id="relicsList" class="space-y-2 text-sm">
                    <!-- Relics will be injected here -->
                </div>
            </div>
        </div>
    </div>

    <script>
        // Custom Cursor Logic
        const customCursor = document.getElementById('custom-cursor');

        function setCursor() {
            const svgElement = document.getElementById('crystalSVG');
            const svgContent = svgElement.outerHTML;
            customCursor.innerHTML = svgContent;
            customCursor.dataset.shape = 'crystal';
            customCursor.style.display = 'none'; // Hide until first mouse move
        }

        setCursor();
        const ZONES = [
            {
                name: "Whispering Glade",
                actionPrompt: "The air is thick with ancient magic. Gather its essence.",
                challenges: [
                    { id: 'gather_1', description: "Gather 100 Essence", type: 'essence', requirement: 100, completed: false },
                    { id: 'gather_2', description: "Focus your power (Perform 50 clicks)", type: 'clicks', requirement: 50, completed: false }
                ],
                boss: {
                    name: "Ancient Treant",
                    hp: 50,
                    timer: 15,
                    flavorText: "The guardian of the glade awakens, its woody form groaning in protest of your presence. Strike it down before it drains your will!"
                }
            },
            {
                name: "Sunken Grotto",
                actionPrompt: "Luminescent fungi cast an eerie glow. Harvest their potent energy.",
                challenges: [
                    { id: 'gather_3', description: "Gather 1,000 Essence", type: 'essence', requirement: 1000, completed: false },
                    { id: 'gather_4', description: "Unlock deeper power (Perform 500 clicks)", type: 'clicks', requirement: 500, completed: false },
                    { id: 'upgrade_1', description: "Enhance your focus (Reach Level 5)", type: 'level', requirement: 5, completed: false }
                ],
                boss: {
                    name: "Abyssal Lurker",
                    hp: 250,
                    timer: 20,
                    flavorText: "A creature of shimmering scales and too many eyes emerges from the depths! Its gaze is paralyzing. Act quickly!"
                }
            },
            {
                name: "Volcanic Caldera",
                actionPrompt: "The ground trembles with raw power. Channel the heart of the mountain.",
                challenges: [
                    { id: 'gather_5', description: "Gather 25,000 Essence", type: 'essence', requirement: 25000, completed: false },
                    { id: 'gather_6', description: "Endure the heat (Perform 2,000 clicks)", type: 'clicks', requirement: 2000, completed: false },
                    { id: 'upgrade_2', description: "Master your abilities (Reach Level 10)", type: 'level', requirement: 10, completed: false }
                ],
                boss: {
                    name: "Magma Elemental",
                    hp: 1000,
                    timer: 25,
                    flavorText: "The very heart of the volcano takes form, a roaring inferno of molten rock and fury! Extinguish its rage before you are consumed!"
                }
            },
             {
                name: "Celestial Peak",
                actionPrompt: "Starlight condenses into tangible energy. Weave it into your being.",
                challenges: [
                    { id: 'gather_7', description: "Gather 500,000 Essence", type: 'essence', requirement: 500000, completed: false },
                    { id: 'upgrade_3', description: "Achieve enlightenment (Reach Level 15)", type: 'level', requirement: 15, completed: false },
                    { id: 'passive_1', description: "Harness the stars passively (Gain 10,000 Essence passively)", type: 'passive', requirement: 10000, completed: false }
                ],
                boss: {
                    name: "Aetheric Wyrm",
                    hp: 5000,
                    timer: 30,
                    flavorText: "A serpent of pure starlight descends from the heavens, its form both beautiful and terrifying. Unmake this celestial guardian!"
                }
            },
            {
                name: "Void Abyss",
                actionPrompt: "The emptiness calls. Draw power from the nothingness itself.",
                challenges: [
                    { id: 'gather_8', description: "Gather 2,000,000 Essence", type: 'essence', requirement: 2000000, completed: false },
                    { id: 'gather_9', description: "Conquer the void (Perform 10,000 clicks)", type: 'clicks', requirement: 10000, completed: false },
                    { id: 'upgrade_4', description: "Transcend reality (Reach Level 25)", type: 'level', requirement: 25, completed: false },
                    { id: 'passive_2', description: "Embrace the void passively (Gain 50,000 Essence passively)", type: 'passive', requirement: 50000, completed: false }
                ],
                boss: {
                    name: "Void Devourer",
                    hp: 25000,
                    timer: 35,
                    flavorText: "A swirling vortex of absolute darkness manifests, hungry for existence itself. Defy the inevitable!"
                }
            },
            {
                name: "Eternal Forge",
                actionPrompt: "Flames of creation burn eternal. Shape destiny with molten will.",
                challenges: [
                    { id: 'gather_10', description: "Gather 10,000,000 Essence", type: 'essence', requirement: 10000000, completed: false },
                    { id: 'gather_11', description: "Forge your legend (Perform 50,000 clicks)", type: 'clicks', requirement: 50000, completed: false },
                    { id: 'upgrade_5', description: "Become the smith (Reach Level 35)", type: 'level', requirement: 35, completed: false }
                ],
                boss: {
                    name: "Primordial Smith",
                    hp: 100000,
                    timer: 40,
                    flavorText: "The first craftsman of the universe wields hammers forged from the bones of dead gods. Prove your worth!"
                }
            },
            {
                name: "Dream Realm",
                actionPrompt: "Reality bends in slumber. Harvest the power of imagination.",
                challenges: [
                    { id: 'gather_12', description: "Gather 50,000,000 Essence", type: 'essence', requirement: 50000000, completed: false },
                    { id: 'gather_13', description: "Dream big (Perform 200,000 clicks)", type: 'clicks', requirement: 200000, completed: false },
                    { id: 'upgrade_6', description: "Master the subconscious (Reach Level 45)", type: 'level', requirement: 45, completed: false }
                ],
                boss: {
                    name: "Nightmare Weaver",
                    hp: 500000,
                    timer: 45,
                    flavorText: "A being of pure nightmare spins webs of terror and delight. Wake from this dream before it consumes you!"
                }
            },
            {
                name: "Nexus of Power",
                actionPrompt: "All realities converge. Claim the ultimate power.",
                challenges: [
                    { id: 'gather_14', description: "Gather 250,000,000 Essence", type: 'essence', requirement: 250000000, completed: false },
                    { id: 'gather_15', description: "Unite the realms (Perform 1,000,000 clicks)", type: 'clicks', requirement: 1000000, completed: false },
                    { id: 'upgrade_7', description: "Ascend to godhood (Reach Level 55)", type: 'level', requirement: 55, completed: false }
                ],
                boss: {
                    name: "Reality Shatterer",
                    hp: 2000000,
                    timer: 50,
                    flavorText: "The final guardian, a being that exists in all times and places simultaneously. Break the cycle!"
                }
            },
            {
                name: "Etherial Abyss",
                actionPrompt: "Dive into the void between worlds. Harness the raw ether.",
                challenges: [
                    { id: 'gather_16', description: "Gather 1,500,000,000 Essence", type: 'essence', requirement: 1500000000, completed: false },
                    { id: 'gather_17', description: "Pierce the veil (Perform 5,000,000 clicks)", type: 'clicks', requirement: 5000000, completed: false },
                    { id: 'upgrade_8', description: "Become ethereal (Reach Level 65)", type: 'level', requirement: 65, completed: false },
                    { id: 'passive_3', description: "Ether flows passively (Gain 500,000 Essence passively)", type: 'passive', requirement: 500000, completed: false }
                ],
                boss: {
                    name: "Void Weaver",
                    hp: 10000000,
                    timer: 55,
                    flavorText: "A master of nothingness, weaving threads of ether into deadly patterns. Unravel its design!"
                }
            },
            {
                name: "Crystal Spire",
                actionPrompt: "Ascend the towering crystal formations. Channel their perfect geometry.",
                challenges: [
                    { id: 'gather_18', description: "Gather 10,000,000,000 Essence", type: 'essence', requirement: 10000000000, completed: false },
                    { id: 'gather_19', description: "Shape the crystals (Perform 25,000,000 clicks)", type: 'clicks', requirement: 25000000, completed: false },
                    { id: 'upgrade_9', description: "Attune to harmony (Reach Level 75)", type: 'level', requirement: 75, completed: false }
                ],
                boss: {
                    name: "Crystal Guardian",
                    hp: 50000000,
                    timer: 60,
                    flavorText: "A colossal being of living crystal, its facets refracting deadly beams of light. Shatter its form!"
                }
            },
            {
                name: "Storm Citadel",
                actionPrompt: "Weather the eternal tempest. Command the fury of the skies.",
                challenges: [
                    { id: 'gather_20', description: "Gather 75,000,000,000 Essence", type: 'essence', requirement: 75000000000, completed: false },
                    { id: 'gather_21', description: "Ride the lightning (Perform 100,000,000 clicks)", type: 'clicks', requirement: 100000000, completed: false },
                    { id: 'upgrade_10', description: "Harness the storm (Reach Level 85)", type: 'level', requirement: 85, completed: false },
                    { id: 'passive_4', description: "Thunder rumbles passively (Gain 2,500,000 Essence passively)", type: 'passive', requirement: 2500000, completed: false }
                ],
                boss: {
                    name: "Thunder Lord",
                    hp: 250000000,
                    timer: 65,
                    flavorText: "The embodiment of electrical fury, crackling with power that could level mountains. Ground its wrath!"
                }
            },
            {
                name: "Frostbound Peaks",
                actionPrompt: "Conquer the icy summits. Forge strength from eternal winter.",
                challenges: [
                    { id: 'gather_22', description: "Gather 500,000,000,000 Essence", type: 'essence', requirement: 500000000000, completed: false },
                    { id: 'gather_23', description: "Shatter the ice (Perform 500,000,000 clicks)", type: 'clicks', requirement: 500000000, completed: false },
                    { id: 'upgrade_11', description: "Embrace the cold (Reach Level 95)", type: 'level', requirement: 95, completed: false }
                ],
                boss: {
                    name: "Ice Titan",
                    hp: 1000000000,
                    timer: 70,
                    flavorText: "A giant of frozen fury, its breath can freeze souls. Melt its icy heart!"
                }
            },
            {
                name: "Shadow Realm",
                actionPrompt: "Navigate the darkness. Master the arts of stealth and shadow.",
                challenges: [
                    { id: 'gather_24', description: "Gather 3,000,000,000,000 Essence", type: 'essence', requirement: 3000000000000, completed: false },
                    { id: 'gather_25', description: "Embrace the shadows (Perform 2,500,000,000 clicks)", type: 'clicks', requirement: 2500000000, completed: false },
                    { id: 'upgrade_12', description: "Become one with darkness (Reach Level 105)", type: 'level', requirement: 105, completed: false },
                    { id: 'passive_5', description: "Shadows whisper passively (Gain 10,000,000 Essence passively)", type: 'passive', requirement: 10000000, completed: false }
                ],
                boss: {
                    name: "Shadow Monarch",
                    hp: 5000000000,
                    timer: 75,
                    flavorText: "A ruler of darkness, commanding legions of shadow creatures. Illuminate the void!"
                }
            },
            {
                name: "Radiant Sanctuary",
                actionPrompt: "Bask in holy light. Purify your essence with divine energy.",
                challenges: [
                    { id: 'gather_26', description: "Gather 20,000,000,000,000 Essence", type: 'essence', requirement: 20000000000000, completed: false },
                    { id: 'gather_27', description: "Spread the light (Perform 10,000,000,000 clicks)", type: 'clicks', requirement: 10000000000, completed: false },
                    { id: 'upgrade_13', description: "Achieve radiance (Reach Level 115)", type: 'level', requirement: 115, completed: false }
                ],
                boss: {
                    name: "Light Seraph",
                    hp: 25000000000,
                    timer: 80,
                    flavorText: "A being of pure light, its radiance can blind and burn. Dim its eternal glow!"
                }
            },
            {
                name: "Chaos Nexus",
                actionPrompt: "Enter the heart of disorder. Bend chaos to your will.",
                challenges: [
                    { id: 'gather_28', description: "Gather 150,000,000,000,000 Essence", type: 'essence', requirement: 150000000000000, completed: false },
                    { id: 'gather_29', description: "Master the chaos (Perform 50,000,000,000 clicks)", type: 'clicks', requirement: 50000000000, completed: false },
                    { id: 'upgrade_14', description: "Control the uncontrollable (Reach Level 125)", type: 'level', requirement: 125, completed: false },
                    { id: 'passive_6', description: "Chaos swirls passively (Gain 50,000,000 Essence passively)", type: 'passive', requirement: 50000000, completed: false }
                ],
                boss: {
                    name: "Chaos Bringer",
                    hp: 100000000000,
                    timer: 85,
                    flavorText: "The source of all disorder, a swirling mass of conflicting energies. Impose order upon chaos!"
                }
            },
            {
                name: "Time's End",
                actionPrompt: "Witness the final moments. Rewrite the flow of time itself.",
                challenges: [
                    { id: 'gather_30', description: "Gather 1,000,000,000,000,000 Essence", type: 'essence', requirement: 1000000000000000, completed: false },
                    { id: 'gather_31', description: "Rewind existence (Perform 250,000,000,000 clicks)", type: 'clicks', requirement: 250000000000, completed: false },
                    { id: 'upgrade_15', description: "Transcend time (Reach Level 135)", type: 'level', requirement: 135, completed: false }
                ],
                boss: {
                    name: "Chronos Prime",
                    hp: 500000000000,
                    timer: 90,
                    flavorText: "The ultimate timekeeper, bending ages to its whim. Stop the clock forever!"
                }
            },
            {
                name: "Infinite Void",
                actionPrompt: "Step into eternity. Become one with the infinite.",
                challenges: [
                    { id: 'gather_32', description: "Gather 10,000,000,000,000,000 Essence", type: 'essence', requirement: 10000000000000000, completed: false },
                    { id: 'gather_33', description: "Embrace infinity (Perform 1,000,000,000,000 clicks)", type: 'clicks', requirement: 1000000000000, completed: false },
                    { id: 'upgrade_16', description: "Achieve infinity (Reach Level 145)", type: 'level', requirement: 145, completed: false },
                    { id: 'passive_7', description: "Infinity expands passively (Gain 250,000,000 Essence passively)", type: 'passive', requirement: 250000000, completed: false }
                ],
                boss: {
                    name: "Infinity Devourer",
                    hp: 2500000000000,
                    timer: 95,
                    flavorText: "A being that consumes infinities, growing stronger with each devoured universe. End its endless hunger!"
                }
            },
            {
                name: "Ultimate Pinnacle",
                actionPrompt: "Reach the absolute peak. Claim your place among the gods.",
                challenges: [
                    { id: 'gather_34', description: "Gather 100,000,000,000,000,000 Essence", type: 'essence', requirement: 100000000000000000, completed: false },
                    { id: 'gather_35', description: "Ascend to godhood (Perform 5,000,000,000,000 clicks)", type: 'clicks', requirement: 5000000000000, completed: false },
                    { id: 'upgrade_17', description: "Become ultimate (Reach Level 155)", type: 'level', requirement: 155, completed: false }
                ],
                boss: {
                    name: "God Emperor",
                    hp: 10000000000000,
                    timer: 100,
                    flavorText: "The supreme ruler of all existence, wielding power beyond comprehension. Dethrone the emperor!"
                }
            }
        ];

        // Background Particle System Variables
        const particleCanvas = document.getElementById('particleCanvas');
        const particleCtx = particleCanvas.getContext('2d');
        let particlesArray;
        let currentStyle = 'combined'; // Will be set randomly
        let mouse = {
            x: null,
            y: null,
            radius: 150
        };

        // Background Particle Class
        class Particle {
            constructor(x, y, directionX, directionY, size, color) {
                this.x = x;
                this.y = y;
                this.originX = x;
                this.originY = y;
                this.directionX = directionX;
                this.directionY = directionY;
                this.size = size;
                this.color = color;
            }

            draw() {
                particleCtx.beginPath();
                particleCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                particleCtx.fillStyle = this.color;
                particleCtx.fill();
            }

            update() {
                // Repel from mouse
                if (mouse.x !== null) {
                    let dx = mouse.x - this.x;
                    let dy = mouse.y - this.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < mouse.radius + this.size){
                       if(mouse.x < this.x && this.x < particleCanvas.width - this.size * 5) this.x += 3;
                       if(mouse.x > this.x && this.x > this.size * 5) this.x -= 3;
                       if(mouse.y < this.y && this.y < particleCanvas.height - this.size * 5) this.y += 3;
                       if(mouse.y > this.y && this.y > this.size * 5) this.y -= 3;
                    }
                }
                this.x += this.directionX;
                this.y += this.directionY;

                // Boundary check
                if (currentStyle !== 'overlay') { // Falling stars has its own boundary logic
                    if (this.x > particleCanvas.width || this.x < 0) this.directionX = -this.directionX;
                    if (this.y > particleCanvas.height || this.y < 0) this.directionY = -this.directionY;
                } else {
                    // Reset particles that fall off the bottom
                    if (this.y > particleCanvas.height + this.size) {
                        this.y = 0 - this.size;
                        this.x = Math.random() * particleCanvas.width;
                    }
                }

                this.draw();
            }
        }

        // Background Particle System Variables
        const backgroundParticleCanvas = document.getElementById('particleCanvas');
        const backgroundParticleCtx = backgroundParticleCanvas.getContext('2d');
        let backgroundParticlesArray;
        let backgroundCurrentStyle = 'combined'; // Will be set randomly
        let backgroundMouse = {
            x: null,
            y: null,
            radius: 150
        };

        // Background Particle Class
        class BackgroundParticle {
            constructor(x, y, directionX, directionY, size, color) {
                this.x = x;
                this.y = y;
                this.originX = x;
                this.originY = y;
                this.directionX = directionX;
                this.directionY = directionY;
                this.size = size;
                this.color = color;
            }

            draw() {
                backgroundParticleCtx.beginPath();
                backgroundParticleCtx.arc(this.x, this.y, this.size, 0, Math.PI * 2, false);
                backgroundParticleCtx.fillStyle = this.color;
                backgroundParticleCtx.fill();
            }

            update() {
                // Repel from mouse
                if (backgroundMouse.x !== null) {
                    let dx = backgroundMouse.x - this.x;
                    let dy = backgroundMouse.y - this.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < backgroundMouse.radius + this.size){
                       if(backgroundMouse.x < this.x && this.x < backgroundParticleCanvas.width - this.size * 5) this.x += 3;
                       if(backgroundMouse.x > this.x && this.x > this.size * 5) this.x -= 3;
                       if(backgroundMouse.y < this.y && this.y < backgroundParticleCanvas.height - this.size * 5) this.y += 3;
                       if(backgroundMouse.y > this.y && this.y > this.size * 5) this.y -= 3;
                    }
                }
                this.x += this.directionX;
                this.y += this.directionY;

                // Boundary check
                if (backgroundCurrentStyle !== 'overlay') { // Falling stars has its own boundary logic
                    if (this.x > backgroundParticleCanvas.width || this.x < 0) this.directionX = -this.directionX;
                    if (this.y > backgroundParticleCanvas.height || this.y < 0) this.directionY = -this.directionY;
                } else {
                    // Reset particles that fall off the bottom
                    if (this.y > backgroundParticleCanvas.height + this.size) {
                        this.y = 0 - this.size;
                        this.x = Math.random() * backgroundParticleCanvas.width;
                    }
                }

                this.draw();
            }
        }

        // Background Particle Functions
        function setCanvasSize() {
            backgroundParticleCanvas.width = window.innerWidth;
            backgroundParticleCanvas.height = window.innerHeight;
        }

        function initBackgroundParticles() {
            backgroundParticlesArray = [];
            let numberOfParticles = (backgroundParticleCanvas.height * backgroundParticleCanvas.width) / 9000;

            if (backgroundCurrentStyle === 'combined') {
                  for (let i = 0; i < numberOfParticles; i++) {
                     let size = (Math.random() * 2) + 1;
                     let x = (Math.random() * ((innerWidth - size * 2) - (size * 2)) + size * 2);
                     let y = (Math.random() * ((innerHeight - size * 2) - (size * 2)) + size * 2);
                     let directionX = (Math.random() * .2) - 0.1; // Slower movement
                     let directionY = (Math.random() * .2) - 0.1; // Slower movement
                     let color = 'rgba(255, 255, 255, 0.25)'; // Much more subtle opacity
                     backgroundParticlesArray.push(new BackgroundParticle(x, y, directionX, directionY, size, color));
                 }
            } else if (backgroundCurrentStyle === 'overlay') {
                // "Star Shower" style - more immersive falling stars
                const jewelColors = [
                    'rgba(255, 215, 0,', // gold
                    'rgba(255, 0, 0,', // red
                    'rgba(0, 255, 0,', // green
                    'rgba(0, 0, 255,', // blue
                    'rgba(255, 0, 255,', // magenta
                    'rgba(255, 165, 0,', // orange
                    'rgba(128, 0, 128,', // purple
                    'rgba(255, 255, 0,', // yellow
                    'rgba(0, 255, 255,', // cyan
                    'rgba(255, 255, 255,', // white for realistic stars
                ];
                for (let i = 0; i < numberOfParticles * 2.5; i++) { // Even more particles for denser shower effect
                    let size = (Math.random() * 2.5) + 0.3; // More varied sizes for realistic stars (0.3-2.8)
                    let x = Math.random() * backgroundParticleCanvas.width;
                    let y = Math.random() * backgroundParticleCanvas.height;
                    let directionX = (Math.random() * 0.4) - 0.2; // Gentle horizontal drift (-0.2 to +0.2)
                    let directionY = (Math.random() * 0.15) + 0.03; // Much slower falling speed (0.03-0.18)
                    let baseColor = jewelColors[Math.floor(Math.random() * jewelColors.length)];
                    let color = `${baseColor}${Math.random() * 0.15 + 0.1})`; // Lower opacity to match other effects (0.1-0.25)
                    backgroundParticlesArray.push(new BackgroundParticle(x, y, directionX, directionY, size, color));
                }
            }
            else if (backgroundCurrentStyle === 'style3') {
                // Half nebula particles
                for (let i = 0; i < numberOfParticles / 2; i++) {
                    let size = (Math.random() * 3.5) + 1.5; // Nebula particles are a bit larger in Style 3
                    let x = (Math.random() * ((innerWidth - size * 2) - (size * 2)) + size * 2);
                    let y = (Math.random() * ((innerHeight - size * 2) - (size * 2)) + size * 2);
                    let directionX = (Math.random() * .2) - 0.1; // Slower movement
                    let directionY = (Math.random() * .2) - 0.1; // Slower movement
                    const colors = ['rgba(236, 72, 153, 0.2)', 'rgba(139, 92, 246, 0.2)', 'rgba(59, 130, 246, 0.2)']; // Much more subtle opacity
                    let color = colors[Math.floor(Math.random() * colors.length)];
                    backgroundParticlesArray.push(new BackgroundParticle(x, y, directionX, directionY, size, color));
                }
                // Half starfield particles
                for (let i = 0; i < numberOfParticles / 2; i++) {
                    let size = (Math.random() * 2) + 1;
                    let x = (Math.random() * ((innerWidth - size * 2) - (size * 2)) + size * 2);
                    let y = (Math.random() * ((innerHeight - size * 2) - (size * 2)) + size * 2);
                    let directionX = (Math.random() * .2) - 0.1; // Slower movement
                    let directionY = (Math.random() * .2) - 0.1; // Slower movement
                    let color = `rgba(255, 255, 255, ${Math.random() * 0.15 + 0.05})`; // Much more subtle opacity
                    backgroundParticlesArray.push(new BackgroundParticle(x, y, directionX, directionY, size, color));
                }
            }
        }

        function animateBackgroundParticles() {
            requestAnimationFrame(animateBackgroundParticles);
            backgroundParticleCtx.clearRect(0, 0, innerWidth, innerHeight);

            for (let i = 0; i < backgroundParticlesArray.length; i++) {
                backgroundParticlesArray[i].update();
            }

            connectBackground();
        }

        function connectBackground() {
            let opacityValue = 1;
            let connectDistance = (backgroundParticleCanvas.width / 12) * (backgroundParticleCanvas.height / 12); // Reduced distance for fewer lines

            for (let a = 0; a < backgroundParticlesArray.length; a++) {
                for (let b = a; b < backgroundParticlesArray.length; b++) {
                    let shouldConnect = false;
                    if (backgroundCurrentStyle === 'combined') {
                        shouldConnect = true; // Connect all particles
                    } else if (backgroundCurrentStyle === 'style3') {
                        // Only connect starfield particles, but check for nebula obstructions
                        if (backgroundParticlesArray[a].color.startsWith('rgba(255,') && backgroundParticlesArray[b].color.startsWith('rgba(255,')) {
                            let isBlocked = false;
                            // Check against all other particles to see if they are a nebula particle in the way
                            for (let i = 0; i < backgroundParticlesArray.length; i++) {
                                if (i !== a && i !== b && !backgroundParticlesArray[i].color.startsWith('rgba(255,')) {
                                    if (isNebulaBlocking(backgroundParticlesArray[a], backgroundParticlesArray[b], backgroundParticlesArray[i])) {
                                        isBlocked = true;
                                        break; // Found a blocker, no need to check others
                                    }
                                }
                            }
                            if (!isBlocked) {
                                shouldConnect = true;
                            }
                        }
                    }

                    if (shouldConnect) {
                        let distance = ((backgroundParticlesArray[a].x - backgroundParticlesArray[b].x) * (backgroundParticlesArray[a].x - backgroundParticlesArray[b].x)) +
                                      ((backgroundParticlesArray[a].y - backgroundParticlesArray[b].y) * (backgroundParticlesArray[a].y - backgroundParticlesArray[b].y));

                        if (distance < connectDistance) {
                            opacityValue = 1 - (distance/20000);
                            let lineColor = `rgba(140, 180, 255, ${opacityValue * 0.4})`; // Fainter lines
                            backgroundParticleCtx.strokeStyle = lineColor;
                            backgroundParticleCtx.lineWidth = 0.5; // Thinner lines
                            backgroundParticleCtx.beginPath();
                            backgroundParticleCtx.moveTo(backgroundParticlesArray[a].x, backgroundParticlesArray[a].y);
                            backgroundParticleCtx.lineTo(backgroundParticlesArray[b].x, backgroundParticlesArray[b].y);
                            backgroundParticleCtx.stroke();
                        }
                    }
                }
            }
        }

        /**
         * Checks if a nebula particle is blocking the path between two starfield particles.
         * @param {BackgroundParticle} pA - The first starfield particle.
         * @param {BackgroundParticle} pB - The second starfield particle.
         * @param {BackgroundParticle} nebulaParticle - The potential blocking nebula particle.
         * @returns {boolean} - True if the nebula particle intersects the line segment.
         */
        function isNebulaBlocking(pA, pB, nebulaParticle) {
            const L2 = Math.pow(pB.x - pA.x, 2) + Math.pow(pB.y - pA.y, 2);
            if (L2 == 0.0) return false;

            // Find the projection of the nebula particle's center onto the line segment
            const t = Math.max(0, Math.min(1, ((nebulaParticle.x - pA.x) * (pB.x - pA.x) + (nebulaParticle.y - pA.y) * (pB.y - pA.y)) / L2));

            // Get the coordinates of the closest point on the line segment
            const closestX = pA.x + t * (pB.x - pA.x);
            const closestY = pA.y + t * (pB.y - pA.y);

            // Calculate the distance from this closest point to the nebula's center
            const dx = nebulaParticle.x - closestX;
            const dy = nebulaParticle.y - closestY;
            const distanceSquared = Math.pow(dx, 2) + Math.pow(dy, 2);

            // Check for collision by comparing distance to the nebula particle's radius (size)
            return distanceSquared < Math.pow(nebulaParticle.size, 2);
        }

        const TITLES = [
            { level: 1, name: "Neophyte" },
            { level: 5, name: "Acolyte" },
            { level: 10, name: "Mage" },
            { level: 15, name: "Archmage" },
            { level: 20, name: "Ascendant" },
            { level: 25, name: "Transcendent" },
            { level: 30, name: "Demi-God" },
            { level: 35, name: "Deity" },
            { level: 40, name: "God" },
            { level: 45, name: "Supreme Being" },
            { level: 50, name: "Overlord" },
            { level: 55, name: "Cosmic Entity" },
            { level: 60, name: "Reality Weaver" },
            { level: 70, name: "Omnipotent" },
            { level: 80, name: "Transcendent" },
            { level: 90, name: "Supreme Entity" },
            { level: 100, name: "Cosmic Overlord" },
            { level: 110, name: "Dimensional Master" },
            { level: 120, name: "Reality Bender" },
            { level: 130, name: "Infinite Being" },
            { level: 140, name: "Eternal Sovereign" },
            { level: 150, name: "Ultimate Existence" },
            { level: 160, name: "Absolute Dominator" },
            { level: 170, name: "Primordial Force" },
            { level: 180, name: "Universal Emperor" },
            { level: 190, name: "Multiversal Lord" },
            { level: 200, name: "Omniscient Creator" },
        ];

        const ACHIEVEMENTS = [
            { id: 'first_click', name: 'First Steps', description: 'Perform your first click', condition: () => gameState.totalClicks >= 1 },
            { id: 'thousand_clicks', name: 'Click Master', description: 'Perform 1,000 clicks', condition: () => gameState.totalClicks >= 1000 },
            { id: 'million_essence', name: 'Essence Hoarder', description: 'Gather 1,000,000 Essence', condition: () => gameState.essence >= 1000000 },
            { id: 'level_10', name: 'Rising Star', description: 'Reach Level 10', condition: () => gameState.level >= 10 },
            { id: 'all_zones', name: 'World Conqueror', description: 'Complete all zones', condition: () => gameState.currentZoneIndex >= ZONES.length },
            { id: 'passive_master', name: 'Idle Champion', description: 'Gain 100,000 Essence passively', condition: () => gameState.totalPassiveGained >= 100000 },
            { id: 'level_100', name: 'Century Milestone', description: 'Reach Level 100', condition: () => gameState.level >= 100 },
            { id: 'total_essence_1e12', name: 'Essence Billionaire', description: 'Gather 1,000,000,000,000 Essence', condition: () => gameState.essence >= 1000000000000 },
            { id: 'zone_10', name: 'Etherial Conqueror', description: 'Complete Etherial Abyss', condition: () => gameState.currentZoneIndex >= 9 },
            { id: 'zone_15', name: 'Chaos Master', description: 'Complete Chaos Nexus', condition: () => gameState.currentZoneIndex >= 16 },
            { id: 'zone_20', name: 'Ultimate Victor', description: 'Complete all zones', condition: () => gameState.currentZoneIndex >= 20 },
            { id: 'crit_master', name: 'Critical Expert', description: 'Upgrade Critical Chance to Level 10', condition: () => gameState.critChanceUpgradeLevel >= 10 },
            { id: 'prestige_1', name: 'First Rebirth', description: 'Prestige for the first time', condition: () => gameState.prestigePoints >= 1 },
            { id: 'speed_zone_10', name: 'Speed Conqueror', description: 'Complete Zone 10 in under 1 hour', condition: () => gameState.currentZoneIndex >= 9 && (Date.now() - gameState.startTime) < 3600000 },
            { id: 'relic_master', name: 'Relic Collector', description: 'Collect 5 relics', condition: () => gameState.relics.length >= 5 },
            { id: 'infinite_10', name: 'Infinite Explorer', description: 'Complete 10 infinite zones', condition: () => gameState.infiniteMode && gameState.currentZoneIndex >= ZONES.length + 9 },
            { id: 'streak_7', name: 'Dedicated Player', description: 'Maintain a 7-day login streak', condition: () => gameState.streak >= 7 },
        ];

        const EVENTS = [
            // Common (40% chance, short/weak)
            { id: 'essence_boost', name: 'Essence Boost', description: 'Doubles essence gain from clicks', duration: 30000, effect: 'double_click', type: 'positive', rarity: 'Common' },
            { id: 'click_penalty', name: 'Click Fatigue', description: 'Reduces click power by 25% for 20 seconds', duration: 20000, effect: 'quarter_click', type: 'negative', rarity: 'Common' },
            { id: 'minor_luck', name: 'Minor Luck', description: 'Increases luck by 10% for 30 seconds', duration: 30000, effect: 'luck_boost', type: 'positive', rarity: 'Common' },
            // Uncommon (30% chance, medium)
            { id: 'passive_surge', name: 'Passive Surge', description: 'Triples passive income', duration: 60000, effect: 'triple_passive', type: 'positive', rarity: 'Uncommon' },
            { id: 'crit_frenzy', name: 'Critical Frenzy', description: '100% critical hit chance', duration: 20000, effect: 'max_crit', type: 'positive', rarity: 'Uncommon' },
            { id: 'essence_drain', name: 'Essence Drain', description: 'Halves passive income for 30 seconds', duration: 30000, effect: 'half_passive', type: 'negative', rarity: 'Uncommon' },
            { id: 'bank_bonus', name: 'Bank Windfall', description: 'Doubles bank interest rate for 45 seconds', duration: 45000, effect: 'double_bank', type: 'positive', rarity: 'Uncommon' },
            // Rare (20% chance, stronger)
            { id: 'cost_reduction', name: 'Bargain Day', description: 'Halves upgrade costs', duration: 45000, effect: 'half_costs', type: 'positive', rarity: 'Rare' },
            { id: 'mega_passive', name: 'Mega Passive', description: 'Quadruples passive income', duration: 45000, effect: 'quad_passive', type: 'positive', rarity: 'Rare' },
            { id: 'crit_storm', name: 'Critical Storm', description: '150% critical hit chance and 2x multiplier', duration: 30000, effect: 'super_crit', type: 'positive', rarity: 'Rare' },
            { id: 'essence_storm', name: 'Essence Storm', description: 'Doubles essence gain but attracts a mini-boss in 10 seconds', duration: 30000, effect: 'double_click', type: 'chained', chain: 'mini_boss', rarity: 'Rare' },
            // Epic (7% chance, very strong)
            { id: 'godlike_boost', name: 'Godlike Boost', description: 'Quintuples essence gain from clicks', duration: 60000, effect: 'quintuple_click', type: 'positive', rarity: 'Epic' },
            { id: 'infinite_crit', name: 'Infinite Critical', description: '100% critical hit chance with 3x multiplier', duration: 45000, effect: 'infinite_crit', type: 'positive', rarity: 'Epic' },
            { id: 'epic_passive', name: 'Epic Passive Surge', description: 'Decuples passive income for 60 seconds', duration: 60000, effect: 'decuple_passive', type: 'positive', rarity: 'Epic' },
            // Legendary (3% chance, game-changing)
            { id: 'legendary_harvest', name: 'Harvest of Legends', description: 'Sextuples essence gain and passive income', duration: 120000, effect: 'legendary_boost', type: 'positive', rarity: 'Legendary' },
            { id: 'time_warp', name: 'Time Warp', description: 'Freezes time for bosses (no timer) for 30 seconds', duration: 30000, effect: 'freeze_boss', type: 'positive', rarity: 'Legendary' },
            { id: 'ascended_luck', name: 'Ascended Luck', description: 'Guarantees rare+ drops from next boss', duration: 60000, effect: 'guarantee_rare', type: 'positive', rarity: 'Legendary' },
        ];

        const COMPANIONS = [
            { id: 'fire_sprite', name: 'Fire Sprite', description: '+10% click power', cost: 1000, effect: 'click_mult', value: 1.1, unlockReq: { level: 5 } },
            { id: 'water_nymph', name: 'Water Nymph', description: '+10% passive income', cost: 2000, effect: 'passive_mult', value: 1.1, unlockReq: { level: 10 } },
            { id: 'earth_golem', name: 'Earth Golem', description: '+10% bank capacity', cost: 3000, effect: 'bank_mult', value: 1.1, unlockReq: { level: 15 } },
            { id: 'air_spirit', name: 'Air Spirit', description: '+10% auto-click rate', cost: 4000, effect: 'auto_mult', value: 1.1, unlockReq: { level: 20 } },
            { id: 'shadow_imp', name: 'Shadow Imp', description: '+5% critical chance', cost: 5000, effect: 'crit_chance_add', value: 0.05, unlockReq: { level: 25 } },
        ];

        const RELICS = [
            { id: 'crit_relic', name: 'Crystal of Precision', description: '+5% critical chance', effect: 'crit_chance_add', value: 0.05, rarity: 'Common' },
            { id: 'click_relic', name: 'Orb of Power', description: '+10% click power', effect: 'click_mult', value: 1.1, rarity: 'Common' },
            { id: 'passive_relic', name: 'Amulet of Flow', description: '+10% passive income', effect: 'passive_mult', value: 1.1, rarity: 'Uncommon' },
            { id: 'luck_relic', name: 'Charm of Fortune', description: '+10% luck', effect: 'luck_mult', value: 1.1, rarity: 'Rare' },
            { id: 'efficiency_relic', name: 'Tome of Thrift', description: '+5% efficiency', effect: 'efficiency_mult', value: 1.05, rarity: 'Epic' },
            // Add more relics for variety
            { id: 'attack_relic', name: 'Blade of Echoes', description: '+15% attack damage', effect: 'attack_mult', value: 1.15, rarity: 'Rare' },
            { id: 'xp_relic', name: 'Tome of Knowledge', description: '+20% XP gain', effect: 'xp_mult', value: 1.2, rarity: 'Legendary' },
        ];

        let gameState = {
            essence: 0,
            level: 1,
            xp: 0,
            xpToNextLevel: 100,
            totalClicks: 0,
            bankedClicks: 0,
            isBankMode: false,
            isAutoClickerActive: false,
            autoClickCostPerSecond: 1,
            currentZoneIndex: 0,
            zones: JSON.parse(JSON.stringify(ZONES)), // Deep copy
            passiveIncomeRate: 0,
            lastUpdateTime: Date.now(),
            clickMultiplier: 1,
            passiveMultiplier: 1,
            totalPassiveGained: 0,
            bankMultiplier: 1,
            autoClickMultiplier: 1,
            achievements: [],
            accumulatedPassive: 0,
            lastPassiveLogTime: Date.now(),
            clickUpgradeLevel: 0,
            passiveUpgradeLevel: 0,
            bankUpgradeLevel: 0,
            autoClickUpgradeLevel: 0,
            critChanceUpgradeLevel: 0,
            critMultUpgradeLevel: 0,
            luckUpgradeLevel: 0,
            efficiencyUpgradeLevel: 0,
            regenerationUpgradeLevel: 0,
            critChance: 0,
            critMultiplier: 2,
            prestigePoints: 0,
            prestigeMultiplier: 1,
            luckMultiplier: 1,
            efficiencyMultiplier: 1,
            regenerationMultiplier: 1,
            xpMultiplier: 1,
            accumulatedBankInterest: 0,
            lastBankLogTime: Date.now(),
            totalBankInterestEarned: 0,
            totalBankInterestEarned: 0,
            passiveBoostActive: false,
            passiveBoostEndTime: 0,
            ceoActive: false,
            ceoEndTime: 0,
            lastCEOLogTime: Date.now(),
            activeEvents: [],
            companions: [],
            relics: [],
            currentDebuff: null,
            debuffEndTime: 0,
            mana: 0,
            manaMax: 0,
            manaBoostActive: false,
            manaBoostEndTime: 0,
            investmentActive: false,
            investmentEndTime: 0,
            infiniteMode: false,
            startTime: Date.now(),
            streak: 0,
            lastLoginDate: new Date().toDateString(),
            timeCrystalUpgradeLevel: 0,
            bossFrozen: false,
            guaranteeRareDrop: false,
            fractionalBankInterest: 0,
            musicEnabled: false,
            chronicleCollapsed: false,
        };
        
        // DOM Elements
        const DOMElements = {
            chatLog: document.getElementById('chatLog'),
            playerTitle: document.getElementById('playerTitle'),
            playerLevel: document.getElementById('playerLevel'),
            playerEssence: document.getElementById('playerEssence'),
            essencePerClick: document.getElementById('essencePerClick'),
            playerAttack: document.getElementById('playerAttack'),
            passiveIncome: document.getElementById('passiveIncome'),
            playerCritChance: document.getElementById('playerCritChance'),
            playerCritMult: document.getElementById('playerCritMult'),
            playerStreak: document.getElementById('playerStreak'),
            zoneName: document.getElementById('zoneName'),
            actionPrompt: document.getElementById('actionPrompt'),
            actionButton: document.getElementById('actionButton'),
            actionButtonText: document.getElementById('actionButtonText'),
            questList: document.getElementById('questList'),
            bankModeToggle: document.getElementById('bankModeToggle'),
            bankedClicks: document.getElementById('bankedClicks'),
            bankSize: document.getElementById('bankSize'),
            autoClickButton: document.getElementById('autoClickButton'),
            autoClickCost: document.getElementById('autoClickCost'),
            autoClickRate: document.getElementById('autoClickRate'),
            bankBoostButton: document.getElementById('bankBoostButton'),
            hireCEOButton: document.getElementById('hireCEOButton'),
            bankInvestmentButton: document.getElementById('bankInvestmentButton'),
            convertClicksButton: document.getElementById('convertClicksButton'),
            bossContainer: document.getElementById('bossContainer'),
            clickFeedbackContainer: document.getElementById('click-feedback-container'),
            upgradeClick: document.getElementById('upgradeClick'),
            upgradePassive: document.getElementById('upgradePassive'),
            upgradeBank: document.getElementById('upgradeBank'),
            upgradeAutoClick: document.getElementById('upgradeAutoClick'),
            upgradeCritChance: document.getElementById('upgradeCritChance'),
            upgradeCritMult: document.getElementById('upgradeCritMult'),
            clickLabel: document.getElementById('clickLabel'),
            passiveLabel: document.getElementById('passiveLabel'),
            bankLabel: document.getElementById('bankLabel'),
            autoLabel: document.getElementById('autoLabel'),
            critChanceLabel: document.getElementById('critChanceLabel'),
            critMultLabel: document.getElementById('critMultLabel'),
            upgradeLuck: document.getElementById('upgradeLuck'),
            upgradeEfficiency: document.getElementById('upgradeEfficiency'),
            upgradeRegeneration: document.getElementById('upgradeRegeneration'),
            upgradeTimeCrystal: document.getElementById('upgradeTimeCrystal'),
            timeCrystalLabel: document.getElementById('timeCrystalLabel'),
            upgradeFlavor: document.getElementById('upgradeFlavor'),
            headerEssence: document.getElementById('headerEssence'),
            luckLabel: document.getElementById('luckLabel'),
            efficiencyLabel: document.getElementById('efficiencyLabel'),
            regenerationLabel: document.getElementById('regenerationLabel'),
            prestigeButton: document.getElementById('prestigeButton'),
            prestigePoints: document.getElementById('prestigePoints'),
            exportSaveButton: document.getElementById('exportSaveButton'),
            loadSaveInput: document.getElementById('loadSaveInput'),
            loadSaveButton: document.getElementById('loadSaveButton'),
            achievementsList: document.getElementById('achievementsList'),
            activeEventsList: document.getElementById('activeEventsList'),
            companionsList: document.getElementById('companionsList'),
            relicsList: document.getElementById('relicsList'),
            summonFireSprite: document.getElementById('summonFireSprite'),
            summonWaterNymph: document.getElementById('summonWaterNymph'),
            summonEarthGolem: document.getElementById('summonEarthGolem'),
            summonAirSpirit: document.getElementById('summonAirSpirit'),
            summonShadowImp: document.getElementById('summonShadowImp'),
            companionFlavor: document.getElementById('companionFlavor'),
            specialMechanicDisplay: document.getElementById('specialMechanicDisplay'),
            musicIconButton: document.getElementById('musicIconButton'),
            chronicleCollapseButton: document.getElementById('chronicleCollapseButton')
        };
        
        let bossState = {
            active: false,
            hp: 0,
            maxHp: 0,
            timer: null,
            timeLeft: 0,
            isMiniBoss: false,
        };

        let showFullEssence = false;
        let showFullAttack = false;
        let showFullBankedClicks = false;
        let previousButtonMode = '';
        let particles = [];
        let ctx;
        let canvas;
        let fps = 0;
        let frameCount = 0;

        // Wisp clumping system
        let lastClickTime = 0;
        let consecutiveClicks = 0;
        let mousePosition = { x: 0, y: 0 };

        function animateParticles() {
            if (!ctx) return; // Wait for ctx to be set
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            frameCount++;
            particles.forEach(p => {
                p.update();
                p.draw(ctx);
            });
            particles = particles.filter(p => p.life > 0 && p.x >= 0 && p.x <= canvas.width && p.y - window.scrollY >= 0 && p.y - window.scrollY <= canvas.height);
            requestAnimationFrame(animateParticles);
        }

        function shakeElements(...elements) {
            elements.forEach(el => {
                if (!el.classList.contains('shake')) {
                    el.classList.add('shake');
                    setTimeout(() => el.classList.remove('shake'), 600);
                }
            });
        }

        // --- Core Game Logic ---
        
        function handleActionClick(e) {
            if (bossState.active) {
                handleBossClick();
                bossStrike(e);
                return;
            }

            // Check if boss is ready (only if not in bank mode)
            if (!gameState.isBankMode && gameState.currentZoneIndex < gameState.zones.length) {
                const zone = gameState.zones[gameState.currentZoneIndex];
                const bossReady = zone.challenges.every(c => c.completed);
                if (bossReady) {
                    startBossFight();
                    return;
                }
            }

            DOMElements.actionButton.classList.remove('shake');
            void DOMElements.actionButton.offsetWidth; // Trigger reflow
            DOMElements.actionButton.classList.add('shake');

            gameState.totalClicks++;

            if (gameState.isBankMode) {
                if (gameState.bankedClicks < getBankSize()) {
                    gameState.bankedClicks++;
                    showClickFeedback('+1 Click', 'text-white');
                } else {
                    logMessage("Your bank is full!", "system-warn");
                }
                forceWave(e);
            } else {
                // Apply special mechanic
                const zone = gameState.zones[gameState.currentZoneIndex];
                if (zone.specialMechanic) {
                    if (zone.specialMechanic.type === 'debuff') {
                        if (Math.random() < zone.specialMechanic.chance) {
                            gameState.currentDebuff = zone.specialMechanic;
                            gameState.debuffEndTime = Date.now() + zone.specialMechanic.duration;
                            logMessage(`${zone.specialMechanic.name} activated! Essence gain halved for ${zone.specialMechanic.duration / 1000} seconds.`, "system-warn");
                        }
                    } else if (zone.specialMechanic.type === 'mana') {
                        gameState.mana += zone.specialMechanic.manaPerClick;
                        if (gameState.mana >= gameState.manaMax && !gameState.manaBoostActive) {
                            gameState.manaBoostActive = true;
                            gameState.manaBoostEndTime = Date.now() + zone.specialMechanic.boostDuration;
                            gameState.mana = 0; // Reset mana
                            logMessage(`${zone.specialMechanic.name} full! Zone-wide boost activated for ${zone.specialMechanic.boostDuration / 1000} seconds.`, "system-ok");
                        }
                    }
                }

                let essenceGained = getEssencePerClick();
                // Apply debuff
                if (gameState.currentDebuff && Date.now() < gameState.debuffEndTime) {
                    essenceGained = Math.floor(essenceGained / 2);
                }
                // Apply mana boost
                if (gameState.manaBoostActive && Date.now() < gameState.manaBoostEndTime) {
                    essenceGained = Math.floor(essenceGained * zone.specialMechanic.boostMultiplier);
                }
                let isCrit = false;
                if (Math.random() < gameState.critChance) {
                    essenceGained = Math.floor(essenceGained * gameState.critMultiplier);
                    isCrit = true;
                }
                gameState.essence += essenceGained;
                gainXP(2);
                showClickFeedback(`+${formatNumber(essenceGained)}${isCrit ? ' CRIT!' : ''}`, isCrit ? 'text-yellow-400' : 'text-white');

                // CEO Bonus
                if (gameState.ceoActive) {
                    let bonusEssence = getEssencePerClick();
                    // Apply debuff and boost to bonus too
                    if (gameState.currentDebuff && Date.now() < gameState.debuffEndTime) {
                        bonusEssence = Math.floor(bonusEssence / 2);
                    }
                    if (gameState.manaBoostActive && Date.now() < gameState.manaBoostEndTime) {
                        bonusEssence = Math.floor(bonusEssence * zone.specialMechanic.boostMultiplier);
                    }
                    gameState.essence += bonusEssence;
                    gainXP(1);
                    showClickFeedback(`+${formatNumber(bonusEssence)} (CEO Bonus)`, 'text-yellow-400');
                    const flavorTexts = [
                        "The CEO whispered sweet nothings to the essence, coaxing it forth.",
                        "With a snap of his fingers, the CEO summoned extra power from the void.",
                        "The CEO's golden watch gleamed as he boosted your click with corporate magic.",
                        "In the boardroom of reality, the CEO approved your bonus essence.",
                        "The CEO leveraged your click for maximum shareholder value... in essence."
                    ];
                    const randomFlavor = flavorTexts[Math.floor(Math.random() * flavorTexts.length)];
                    logMessage(`CEO of Money helped you earn ${formatNumber(bonusEssence)} extra essence! "${randomFlavor}"`, "system-ok");
                }

                // Track consecutive clicks for wisp clumping
                const now = Date.now();
                if (now - lastClickTime < 500) { // 500ms window for consecutive clicks
                    consecutiveClicks++;
                } else {
                    consecutiveClicks = 1;
                }
                lastClickTime = now;

                manaWisps(e, consecutiveClicks);
            }

            updateUI();
            checkQuestCompletion();
        }

        function handleBossClick() {
            let damage = Math.floor(getEssencePerClick() / 50) + 1;
            bossState.hp -= damage;
            showClickFeedback(`+${damage} Damage`, 'text-red-400');
            DOMElements.actionButton.classList.remove('shake');
            void DOMElements.actionButton.offsetWidth; // Trigger reflow
            DOMElements.actionButton.classList.add('shake');

            // CEO Bonus for boss
            if (gameState.ceoActive) {
                let bonusDamage = Math.floor(getEssencePerClick() / 50) + 1;
                bossState.hp -= bonusDamage;
                showClickFeedback(`+${bonusDamage} (CEO Bonus)`, 'text-yellow-400');
                const bossFlavorTexts = [
                    "The CEO called in artillery strikes on the boss!",
                    "With a hostile takeover bid, the CEO weakened the foe.",
                    "The CEO's board meeting decided the boss's fate.",
                    "Corporate synergy amplified your attack!",
                    "The CEO leveraged the boss's weaknesses for maximum damage."
                ];
                const randomFlavor = bossFlavorTexts[Math.floor(Math.random() * bossFlavorTexts.length)];
                logMessage(`CEO of Money helped you deal ${bonusDamage} extra damage! "${randomFlavor}"`, "system-ok");
            }

            const bossHpElement = document.getElementById('bossHp');
            if (bossHpElement) bossHpElement.textContent = `${formatNumber(bossState.hp)} / ${formatNumber(bossState.maxHp)}`;

            if (bossState.hp <= 0) {
                winBossFight();
            }
        }

        function toggleBankMode() {
            if (bossState.active) {
                DOMElements.bankModeToggle.checked = false;
                logMessage("Cannot access bank mode during boss fight.", "system-warn");
                return;
            }
            gameState.isBankMode = DOMElements.bankModeToggle.checked;
            if (gameState.isBankMode) {
                gameState.originalZoneName = DOMElements.zoneName.textContent;
                gameState.originalActionPrompt = DOMElements.actionPrompt.textContent;
                DOMElements.zoneName.textContent = "Bank";
                DOMElements.actionPrompt.textContent = "Store clicks in your bank.";
            } else {
                if (gameState.originalZoneName) {
                    DOMElements.zoneName.textContent = gameState.originalZoneName;
                }
                if (gameState.originalActionPrompt) {
                    DOMElements.actionPrompt.textContent = gameState.originalActionPrompt;
                }
            }
            // Animate container swap
            const zoneEl = document.getElementById('zoneObjectivesContainer');
            const bankEl = document.getElementById('bankContainer');
            if (gameState.isBankMode) {
                zoneEl.parentNode.insertBefore(bankEl, zoneEl);
                logMessage("Bank mode activated. Clicks are now stored.", "system-ok");
            } else {
                zoneEl.parentNode.insertBefore(zoneEl, bankEl);
                logMessage("Bank mode deactivated. Clicks now generate Essence.", "system");
            }
            updateUI();
        }


        function useBankBoost() {
            if (gameState.bankedClicks < 50 || gameState.passiveBoostActive) return;
            gameState.bankedClicks -= 50;
            gameState.passiveBoostActive = true;
            gameState.passiveBoostEndTime = Date.now() + 60000;
            logMessage("Bank Boost activated! Passive income doubled for 60 seconds.", "system-ok");
            updateUI();
            DOMElements.bankBoostButton.classList.add('success-click');
            setTimeout(() => DOMElements.bankBoostButton.classList.remove('success-click'), 500);
        }

        function hireCEO() {
            if (gameState.bankedClicks < 100 || gameState.ceoActive) return;
            gameState.bankedClicks -= 100;
            gameState.ceoActive = true;
            gameState.ceoEndTime = Date.now() + 150000; // 2.5 minutes
            gameState.activeEvents.push({
                id: 'ceo_active',
                name: 'CEO of Money',
                description: 'Bonus clicks on every manual click',
                startTime: Date.now(),
                endTime: Date.now() + 150000
            });
            logMessage("Hired CEO of Money! Bonus clicks activated for 2.5 minutes.", "system-ok");
            updateUI();
            DOMElements.hireCEOButton.classList.add('success-click');
            setTimeout(() => DOMElements.hireCEOButton.classList.remove('success-click'), 500);
        }

        function useBankInvestment() {
            if (gameState.bankedClicks < 100 || gameState.investmentActive) return;
            gameState.bankedClicks -= 100;
            gameState.investmentActive = true;
            gameState.investmentEndTime = Date.now() + 30000; // 30 seconds
            logMessage("Risky investment activated! Passive income doubled for 30 seconds. Beware of interruptions!", "system-ok");
            updateUI();
            DOMElements.bankInvestmentButton.classList.add('success-click');
            setTimeout(() => DOMElements.bankInvestmentButton.classList.remove('success-click'), 500);
        }

        function convertClicksToEssence() {
            if (gameState.bankedClicks < 1) return;
            const clicksUsed = gameState.bankedClicks;
            const essenceGained = clicksUsed * 2;
            gameState.essence += essenceGained;
            gameState.bankedClicks = 0;
            logMessage(`Converted ${formatNumber(clicksUsed)} banked clicks to ${formatNumber(essenceGained)} essence!`, "system-ok");
            updateUI();
            DOMElements.convertClicksButton.classList.add('success-click');
            setTimeout(() => DOMElements.convertClicksButton.classList.remove('success-click'), 500);
        }

        function toggleAutoClicker() {
            gameState.isAutoClickerActive = !gameState.isAutoClickerActive;
            if (gameState.isAutoClickerActive) {
                logMessage("Auto-clicker activated.", "system-ok");
            } else {
                logMessage("Auto-clicker deactivated.", "system");
            }
            updateUI();
        }

        function checkQuestCompletion(allowBossTrigger = true) {
            if (gameState.currentZoneIndex >= gameState.zones.length) return;
            const zone = gameState.zones[gameState.currentZoneIndex];
            let allCompleted = true;

            zone.challenges.forEach(challenge => {
                if (challenge.completed) return;

                let isCompleted = false;
                switch (challenge.type) {
                    case 'essence':
                        if (gameState.essence >= challenge.requirement) isCompleted = true;
                        break;
                    case 'clicks':
                        if (gameState.totalClicks >= challenge.requirement) isCompleted = true;
                        break;
                    case 'level':
                           if (gameState.level >= challenge.requirement) isCompleted = true;
                        break;
                    case 'passive':
                        if (gameState.totalPassiveGained >= challenge.requirement) isCompleted = true;
                        break;
                }

                if (isCompleted) {
                    challenge.completed = true;
                    logMessage(`Objective Complete: ${challenge.description}`, "quest");
                }
            });

            zone.challenges.forEach(c => {
                if (!c.completed) allCompleted = false;
            });

            // Boss fight is now manual via button

            updateQuestList();
        }

        function startBossFight() {
            const zone = gameState.zones[gameState.currentZoneIndex];
            const boss = zone.boss;
            bossState.active = true;
            bossState.hp = boss.hp;
            bossState.maxHp = boss.hp;
            bossState.timeLeft = boss.timer;
            bossState.isMiniBoss = false;

            logMessage(`A powerful foe appears! The ${boss.name} blocks your path!`, "danger");
            
            // Clear any existing embers
            const existingEmbers = DOMElements.bossContainer.querySelectorAll('.ember');
            existingEmbers.forEach(e => e.remove());

            DOMElements.bossContainer.innerHTML = `
                <div class="fade-in w-full">
                    <h3 class="font-cinzel text-4xl font-bold text-orange-300 drop-shadow-lg">${boss.name}</h3>
                    <p class="text-orange-200 mt-2 mb-4">${boss.flavorText}</p>
                    <p id="bossHp" class="text-2xl font-bold text-white">${formatNumber(bossState.hp)} / ${formatNumber(bossState.maxHp)}</p>
                    <div class="w-full bg-gray-700 rounded-full h-4 mt-4 border-2 border-black/50">
                        <div id="bossTimerBar" class="bg-yellow-400 h-full rounded-full" style="width: 100%"></div>
                    </div>
                    <p id="bossTimeLeft" class="text-lg font-bold mt-2">${bossState.timeLeft}s remaining</p>
                </div>
            `;

            // --- Script for infernal embers effect ---
            const embersContainer = DOMElements.bossContainer;
            if (embersContainer) {
                for (let i = 0; i < 10; i++) {
                    const ember = document.createElement('div');
                    ember.classList.add('ember');

                    const size = Math.random() * 4 + 2; // 2px to 6px
                    ember.style.width = `${size}px`;
                    ember.style.height = `${size}px`;
                    ember.style.left = `${Math.random() * 100}%`;
                    ember.style.animationDelay = `${Math.random() * 8}s`;
                    ember.style.animationDuration = `${Math.random() * 4 + 6}s`; // 6s to 10s

                    embersContainer.appendChild(ember);
                }
            }
            DOMElements.bossContainer.classList.remove('hidden', 'absolute', 'inset-0');
            DOMElements.bossContainer.classList.add('flex');
            DOMElements.zoneName.style.display = 'none';
            DOMElements.actionPrompt.style.display = 'none';

            gameState.isBankMode = false;
            DOMElements.bankModeToggle.checked = false;
            // Check investment risk
            if (gameState.investmentActive) {
                const loss = Math.floor(gameState.bankedClicks * 0.2);
                gameState.bankedClicks -= loss;
                gameState.investmentActive = false;
                logMessage(`Investment interrupted! Lost ${formatNumber(loss)} banked clicks.`, "system-warn");
            }
            DOMElements.actionButton.className = 'btn action-btn attack-mode';

            bossState.timer = setInterval(() => {
                if (!gameState.bossFrozen) {
                    bossState.timeLeft--;
                }
                const timerBar = document.getElementById('bossTimerBar');
                const timeLeftDisplay = document.getElementById('bossTimeLeft');

                if (timerBar) timerBar.style.width = `${(bossState.timeLeft / boss.timer) * 100}%`;
                if (timeLeftDisplay) timeLeftDisplay.textContent = `${bossState.timeLeft}s remaining`;

                if (bossState.timeLeft <= 0) {
                    loseBossFight();
                }
            }, 1000);
        }

        function winBossFight() {
            clearInterval(bossState.timer);
            bossState.active = false;
            const zone = gameState.zones[gameState.currentZoneIndex];
            const boss = zone.boss;
            
            logMessage(`The ${boss.name} has been vanquished! The path forward is clear.`, "victory");
            
            const xpGained = boss.hp * 2;
            gainXP(xpGained);
            logMessage(`You gained ${formatNumber(xpGained)} XP for your victory!`, 'system-ok');

            // Loot drop
            const performance = bossState.timeLeft / boss.timer; // 0 to 1
            let dropChance = 0.1 + performance * 0.4; // 10% to 50%
            let forceRare = false;
            if (gameState.guaranteeRareDrop) {
                dropChance = 1; // Guarantee drop
                forceRare = true;
                gameState.guaranteeRareDrop = false; // Reset
            }
            if (Math.random() < dropChance) {
                let relicPool = RELICS;
                if (forceRare) {
                    relicPool = RELICS.filter(r => ['Rare', 'Epic', 'Legendary'].includes(r.rarity));
                }
                const relic = relicPool[Math.floor(Math.random() * relicPool.length)];
                if (!gameState.relics.some(r => r.id === relic.id)) {
                    gameState.relics.push(relic);
                    logMessage(`You found a relic: ${relic.name} - ${relic.description}!`, 'victory');
                } else {
                    logMessage(`You found a duplicate relic: ${relic.name}. It's already in your collection.`, 'system-ok');
                }
            }

            DOMElements.bossContainer.classList.add('hidden');
            DOMElements.bossContainer.classList.remove('flex');
            DOMElements.zoneName.style.display = '';
            DOMElements.actionPrompt.style.display = '';

            DOMElements.actionButton.className = 'btn action-btn gather-mode';

            if (!bossState.isMiniBoss) {
                gameState.currentZoneIndex++;

                if (gameState.currentZoneIndex >= ZONES.length) {
                    if (!gameState.infiniteMode) {
                        gameState.infiniteMode = true;
                        logMessage("You have entered the Infinite Realms! Endless challenges await.", "victory");
                    }
                    generateInfiniteZone(gameState.currentZoneIndex);
                    loadZone();
                } else {
                    loadZone();
                }
            } else {
                logMessage("The mini-boss has been defeated! The storm clears.", "victory");
            }
           
            updateUI();
        }

        function loseBossFight() {
            clearInterval(bossState.timer);
            bossState.active = false;
            const zone = gameState.zones[gameState.currentZoneIndex];
            const boss = zone.boss;
            
            logMessage(`You were overwhelmed by the ${boss.name}. Regroup and try again.`, "danger");

            DOMElements.bossContainer.classList.add('hidden');
            DOMElements.bossContainer.classList.remove('flex');
            DOMElements.zoneName.style.display = '';
            DOMElements.actionPrompt.style.display = '';

            // Keep challenges completed, just reset button to Gather
            DOMElements.actionButton.className = 'btn action-btn gather-mode';

            logMessage("Your failure has reset the zone's challenge.", "system-warn");
            
            updateUI();
        }


        // --- Player Progression ---
        function gainXP(amount) {
            gameState.xp += Math.floor(amount * gameState.xpMultiplier);
            while (gameState.xp >= gameState.xpToNextLevel) {
                levelUp();
            }
        }
        
        function levelUp() {
            gameState.level++;
            gameState.xp -= gameState.xpToNextLevel;
            gameState.xpToNextLevel = Math.floor(gameState.xpToNextLevel * 1.5);
            logMessage(`You have reached Level ${gameState.level}!`, "levelup");
            updateUI();
            checkQuestCompletion();
        }
        
        function getUpgradeColor(level) {
            if (level < 10) return '#808080'; // gray
            if (level < 20) return '#2ecc71'; // green
            if (level < 30) return '#3498db'; // blue
            if (level < 40) return '#8e44ad'; // purple
            if (level < 50) return '#f39c12'; // gold
            if (level < 60) return '#e74c3c'; // crimson
            if (level < 70) return '#d35400'; // burnt orange
            if (level < 80) return '#ffffff'; // white
            if (level < 90) return '#00ffff'; // cyan
            return '#ff00ff'; // magenta
        }

        function getRarityColor(rarity) {
            switch(rarity) {
                case 'Common': return '#808080';
                case 'Uncommon': return '#2ecc71';
                case 'Rare': return '#3498db';
                case 'Epic': return '#8e44ad';
                case 'Legendary': return '#f39c12';
                default: return '#ffffff';
            }
        }

        // --- UI Updates ---
        function updateUI() {
            // Stats
            const currentTitle = getPlayerTitle();
            DOMElements.playerTitle.textContent = currentTitle;
            document.title = currentTitle + " - Gilded Syntax";
            DOMElements.playerLevel.textContent = gameState.level;
            const xpProgress = Math.min((gameState.xp / gameState.xpToNextLevel) * 100, 100);
            document.getElementById('xpBar').style.width = `${xpProgress}%`;
            document.getElementById('xpText').textContent = `${formatNumber(gameState.xp)} / ${formatNumber(gameState.xpToNextLevel)}`;
            DOMElements.playerEssence.textContent = showFullEssence ? gameState.essence.toLocaleString() : formatNumber(gameState.essence);
            DOMElements.headerEssence.textContent = gameState.essence.toLocaleString();
            DOMElements.essencePerClick.textContent = formatNumber(getEssencePerClick());
            DOMElements.playerAttack.textContent = showFullAttack ? getAttackDamage().toFixed(2) : Math.floor(getAttackDamage());
            DOMElements.passiveIncome.textContent = formatNumber(gameState.passiveIncomeRate);
            DOMElements.playerCritChance.textContent = (gameState.critChance * 100).toFixed(1) + '%';
            DOMElements.playerCritMult.textContent = gameState.critMultiplier.toFixed(1) + 'x';

            DOMElements.playerStreak.textContent = gameState.streak > 0 ? gameState.streak : '';

            // Bank
            DOMElements.bankedClicks.textContent = showFullBankedClicks ? gameState.bankedClicks.toLocaleString() : formatNumber(gameState.bankedClicks);
            DOMElements.bankSize.textContent = formatNumber(getBankSize());
            const interestRate = 0.001 * (1 + gameState.bankUpgradeLevel * 0.1);
            document.getElementById('interestRate').textContent = (gameState.bankedClicks * interestRate).toFixed(2);
            document.getElementById('accumulatedInterest').textContent = formatNumber(gameState.totalBankInterestEarned);
            // Update bank mode UI
            if (bossState.active) {
                DOMElements.actionButton.className = 'btn action-btn attack-mode';
            } else {
                // Check if boss is ready
                let bossReady = false;
                if (gameState.currentZoneIndex < gameState.zones.length) {
                    const zone = gameState.zones[gameState.currentZoneIndex];
                    bossReady = zone.challenges.every(c => c.completed);
                }
                if (gameState.isBankMode) {
                    DOMElements.actionButton.className = 'btn action-btn store-mode';
                } else if (bossReady) {
                    DOMElements.actionButton.className = 'btn action-btn boss-mode';
                } else {
                    DOMElements.actionButton.className = 'btn action-btn gather-mode';
                }
                // Hide action prompt when boss is ready and not in bank mode
                if (bossReady && !gameState.isBankMode) {
                    DOMElements.actionPrompt.style.display = 'none';
                } else {
                    DOMElements.actionPrompt.style.display = '';
                }
            }
            DOMElements.bankModeToggle.checked = gameState.isBankMode;
            if (gameState.isBankMode) {
                DOMElements.zoneName.textContent = "Bank" + (gameState.bankedClicks >= getBankSize() ? " (Full)" : "");
                DOMElements.actionPrompt.textContent = "Store clicks in your bank.";
            }
            DOMElements.autoClickButton.textContent = gameState.isAutoClickerActive ? "Auto-Clicker: On" : "Auto-Clicker: Off";
            DOMElements.autoClickRate.textContent = getAutoClickRate();
            // Removed title to prevent duplicate tooltips with custom data-tooltip
            DOMElements.bankBoostButton.disabled = gameState.passiveBoostActive || gameState.bankedClicks < 50;
            DOMElements.hireCEOButton.disabled = gameState.ceoActive || gameState.bankedClicks < 100;
            DOMElements.bankInvestmentButton.disabled = gameState.investmentActive || gameState.bankedClicks < 100;
            DOMElements.convertClicksButton.disabled = gameState.bankedClicks < 1;

            // Determine current button mode
            let bossReady = false;
            if (gameState.currentZoneIndex < gameState.zones.length) {
                const zone = gameState.zones[gameState.currentZoneIndex];
                bossReady = zone.challenges.every(c => c.completed);
            }
            let currentMode = 'gather-mode';
            if (bossState.active) {
                currentMode = 'attack-mode';
            } else if (gameState.isBankMode) {
                currentMode = 'store-mode';
            } else if (bossReady) {
                currentMode = 'boss-mode';
            }

            // Clear effects on button state change
            if (previousButtonMode !== currentMode) {
                clearAllParticles();
                previousButtonMode = currentMode;
            }

            DOMElements.actionButton.className = 'btn action-btn ' + currentMode;

            // Disable button if bank is full in store mode
            if (gameState.isBankMode && gameState.bankedClicks >= getBankSize()) {
                DOMElements.actionButton.classList.add('disabled');
            } else {
                DOMElements.actionButton.classList.remove('disabled');
            }

            // Update multipliers with diminishing returns after Lv.50
            const softCap = 50;
            gameState.clickMultiplier = Math.pow(1.1, Math.min(gameState.clickUpgradeLevel, softCap)) * Math.pow(1.05, Math.max(gameState.clickUpgradeLevel - softCap, 0));
            gameState.passiveMultiplier = Math.pow(1.1, Math.min(gameState.passiveUpgradeLevel, softCap)) * Math.pow(1.05, Math.max(gameState.passiveUpgradeLevel - softCap, 0));
            gameState.bankMultiplier = Math.pow(1.1, Math.min(gameState.bankUpgradeLevel, softCap)) * Math.pow(1.05, Math.max(gameState.bankUpgradeLevel - softCap, 0));
            gameState.autoClickMultiplier = Math.pow(1.1, Math.min(gameState.autoClickUpgradeLevel, softCap)) * Math.pow(1.05, Math.max(gameState.autoClickUpgradeLevel - softCap, 0));
            gameState.luckMultiplier = Math.pow(1.05, Math.min(gameState.luckUpgradeLevel, softCap)) * Math.pow(1.02, Math.max(gameState.luckUpgradeLevel - softCap, 0));
            gameState.efficiencyMultiplier = Math.pow(0.95, Math.min(gameState.efficiencyUpgradeLevel, softCap)) * Math.pow(0.98, Math.max(gameState.efficiencyUpgradeLevel - softCap, 0));
            gameState.regenerationMultiplier = Math.pow(1.1, Math.min(gameState.regenerationUpgradeLevel, softCap)) * Math.pow(1.05, Math.max(gameState.regenerationUpgradeLevel - softCap, 0));
            gameState.critChance = Math.min(0.5, (0.05 * gameState.critChanceUpgradeLevel) * gameState.luckMultiplier);
            gameState.critMultiplier = 2 + 0.5 * gameState.critMultUpgradeLevel;

            // Reset multipliers that are affected by relics before applying effects
            gameState.attackMultiplier = 1;
            gameState.xpMultiplier = 1;

            // Apply companion, relic, and active event effects
            gameState.companions.forEach(companion => {
                applyCompanionEffect(companion);
            });
            gameState.relics.forEach(relic => {
                applyRelicEffect(relic);
            });
            gameState.activeEvents.forEach(event => {
                applyEventEffect(event);
            });

            // Update upgrade labels with rarity colors
            DOMElements.clickLabel.textContent = `Click Power (Lv.${gameState.clickUpgradeLevel})`;
            DOMElements.clickLabel.style.color = getUpgradeColor(gameState.clickUpgradeLevel);
            DOMElements.upgradeClick.textContent = `Upgrade (${formatNumber(getClickUpgradeCost())} Ess)`;
            DOMElements.passiveLabel.textContent = `Passive Income (Lv.${gameState.passiveUpgradeLevel})`;
            DOMElements.passiveLabel.style.color = getUpgradeColor(gameState.passiveUpgradeLevel);
            DOMElements.upgradePassive.textContent = `Upgrade (${formatNumber(getPassiveUpgradeCost())} Ess)`;
            DOMElements.bankLabel.textContent = `Bank Capacity (Lv.${gameState.bankUpgradeLevel})`;
            DOMElements.bankLabel.style.color = getUpgradeColor(gameState.bankUpgradeLevel);
            DOMElements.upgradeBank.textContent = `Upgrade (${formatNumber(getBankUpgradeCost())} Ess)`;
            DOMElements.autoLabel.textContent = `Auto-Clicker (Lv.${gameState.autoClickUpgradeLevel})`;
            DOMElements.autoLabel.style.color = getUpgradeColor(gameState.autoClickUpgradeLevel);
            DOMElements.upgradeAutoClick.textContent = `Upgrade (${formatNumber(getAutoClickUpgradeCost())} Ess)`;
            DOMElements.critChanceLabel.textContent = `Critical Chance (Lv.${gameState.critChanceUpgradeLevel})`;
            DOMElements.critChanceLabel.style.color = getUpgradeColor(gameState.critChanceUpgradeLevel);
            DOMElements.upgradeCritChance.textContent = `Upgrade (${formatNumber(getCritChanceUpgradeCost())} Ess)`;
            DOMElements.critMultLabel.textContent = `Critical Multiplier (Lv.${gameState.critMultUpgradeLevel})`;
            DOMElements.critMultLabel.style.color = getUpgradeColor(gameState.critMultUpgradeLevel);
            DOMElements.upgradeCritMult.textContent = `Upgrade (${formatNumber(getCritMultUpgradeCost())} Ess)`;
            DOMElements.luckLabel.textContent = `Luck (Lv.${gameState.luckUpgradeLevel})`;
            DOMElements.luckLabel.style.color = getUpgradeColor(gameState.luckUpgradeLevel);
            DOMElements.upgradeLuck.textContent = `Upgrade (${formatNumber(getLuckUpgradeCost())} Ess)`;
            DOMElements.efficiencyLabel.textContent = `Efficiency (Lv.${gameState.efficiencyUpgradeLevel})`;
            DOMElements.efficiencyLabel.style.color = getUpgradeColor(gameState.efficiencyUpgradeLevel);
            DOMElements.upgradeEfficiency.textContent = `Upgrade (${formatNumber(getEfficiencyUpgradeCost())} Ess)`;
            DOMElements.regenerationLabel.textContent = `Regeneration (Lv.${gameState.regenerationUpgradeLevel})`;
            DOMElements.regenerationLabel.style.color = getUpgradeColor(gameState.regenerationUpgradeLevel);
            DOMElements.upgradeRegeneration.textContent = `Upgrade (${formatNumber(getRegenerationUpgradeCost())} Ess)`;
            DOMElements.timeCrystalLabel.textContent = `Time Crystal (Lv.${gameState.timeCrystalUpgradeLevel})`;
            DOMElements.timeCrystalLabel.style.color = getUpgradeColor(gameState.timeCrystalUpgradeLevel);
            DOMElements.upgradeTimeCrystal.textContent = `Upgrade (${formatNumber(getTimeCrystalUpgradeCost())} Ess)`;

            // Prestige
            DOMElements.prestigePoints.textContent = formatNumber(gameState.prestigePoints);
            DOMElements.prestigeButton.disabled = gameState.level < 50;

            // Dynamic tooltips
            if (bossState.active) {
                DOMElements.actionButton.setAttribute('data-tooltip', "Attack the boss to deal damage and defeat it");
                } else if (gameState.isBankMode) {
                    DOMElements.actionButton.setAttribute('data-tooltip', "Store this click in your bank for later use");
                } else {
                    DOMElements.actionButton.setAttribute('data-tooltip', "Click to gather essence from this zone");
                }

            updateChronicleCollapse();
            checkAchievements();
            updateAchievementsList();
            updateCompanionsList();
            updateRelicsList();
            updateSpecialMechanicDisplay();

            // Update event flavor text
            const flavorEl = document.getElementById('eventFlavorText');
            if (gameState.activeEvents.length > 0) {
                flavorEl.textContent = '';
            } else if (gameState.eventBufferCountdown > 0) {
                flavorEl.textContent = `Event Incoming in: ${gameState.eventBufferCountdown}s`;
            } else {
                flavorEl.textContent = '';
            }

            // Update music icon color
            if (gameState.musicEnabled) {
                DOMElements.musicIconButton.classList.remove('text-gray-500');
                DOMElements.musicIconButton.classList.add('text-white');
            } else {
                DOMElements.musicIconButton.classList.remove('text-white');
                DOMElements.musicIconButton.classList.add('text-gray-500');
            }

            saveGame();
        }
        
        function updateQuestList() {
                DOMElements.questList.classList.add('relative');
                if (gameState.currentZoneIndex >= gameState.zones.length) {
                  DOMElements.questList.innerHTML = `<p class="text-green-400">All syntax realms mastered!</p>`;
                  document.getElementById('zoneFlavorText').textContent = '';
                  return;
                }
              const zone = gameState.zones[gameState.currentZoneIndex];
              const existing = DOMElements.questList.children;
              let allCompleted = true;
             zone.challenges.forEach((challenge, index) => {
                 if (!challenge.completed) allCompleted = false;
                 let questEl;
                 if (existing[index]) {
                     questEl = existing[index];
                 } else {
                     questEl = document.createElement('div');
                     questEl.className = 'space-y-1 tooltip';
                     DOMElements.questList.appendChild(questEl);
                 }
                 questEl.setAttribute('data-tooltip', challenge.description);
                 let progress = 0;
                 let current = 0;
                 switch (challenge.type) {
                     case 'essence': current = gameState.essence; break;
                     case 'clicks': current = gameState.totalClicks; break;
                     case 'level': current = gameState.level; break;
                     case 'passive': current = gameState.totalPassiveGained; break;
                 }
                 progress = Math.min((current / challenge.requirement) * 100, 100);
                 if (challenge.completed) {
                     questEl.innerHTML = `<div class="flex justify-between"><span class="text-gray-500 line-through">${challenge.description}</span><span class="text-green-500 font-bold">✓</span></div>`;
                 } else {
                     questEl.innerHTML = `
                         <div>${challenge.description}</div>
                         <div class="w-full bg-gray-700 rounded-full h-2">
                             <div class="bg-blue-500 h-full rounded-full transition-all duration-300" style="width: ${progress}%"></div>
                         </div>
                         <div class="text-xs text-gray-400">${formatNumber(current)} / ${formatNumber(challenge.requirement)}</div>
                     `;
                 }
             });
             // Remove extra elements if fewer challenges
             while (existing.length > zone.challenges.length) {
                 DOMElements.questList.removeChild(existing[existing.length - 1]);
             }
             // Update flavor text
             let completedCount = 0;
             zone.challenges.forEach(c => { if (c.completed) completedCount++; });
             document.getElementById('zoneFlavorText').textContent = `${completedCount} / ${zone.challenges.length}`;
             // Blur objectives and add overlay if completed
             if (allCompleted) {
                 for (let child of DOMElements.questList.children) {
                     if (child.tagName === 'DIV') child.classList.add('module-blur');
                 }
                 const existingOverlay = DOMElements.questList.querySelector('.objectives-overlay');
                 if (existingOverlay) existingOverlay.remove();
                 const overlay = document.createElement('div');
                 overlay.className = 'objectives-overlay';
                 overlay.textContent = 'Challenge Boss To Proceed';
                 DOMElements.questList.appendChild(overlay);
             } else {
                 for (let child of DOMElements.questList.children) {
                     child.classList.remove('module-blur');
                 }
                 const existingOverlay = DOMElements.questList.querySelector('.objectives-overlay');
                 if (existingOverlay) existingOverlay.remove();
             }
         }

        function checkAchievements() {
            ACHIEVEMENTS.forEach(achievement => {
                if (!gameState.achievements.includes(achievement.id) && achievement.condition()) {
                    gameState.achievements.push(achievement.id);
                    logMessage(`Achievement Unlocked: ${achievement.name} - ${achievement.description}`, "victory");
                }
            });
        }

        function updateAchievementsList() {
            const existing = DOMElements.achievementsList.children;
            if (existing.length === ACHIEVEMENTS.length) {
                // Update existing elements to prevent tooltip flickering
                ACHIEVEMENTS.forEach((achievement, index) => {
                    const achEl = existing[index];
                    achEl.setAttribute('data-tooltip', achievement.description);
                    achEl.classList.remove('above', 'below');
                    achEl.classList.add('below');
                });
            } else {
                // Recreate if list changed
                DOMElements.achievementsList.innerHTML = '';
                ACHIEVEMENTS.forEach((achievement, index) => {
                    const achEl = document.createElement('div');
                    achEl.className = 'flex justify-between items-center text-xs tooltip';
                    achEl.classList.add('below');
                    achEl.setAttribute('data-tooltip', achievement.description);
                    if (gameState.achievements.includes(achievement.id)) {
                        achEl.innerHTML = `<span class="text-yellow-400 font-bold">${achievement.name}</span><span class="text-green-500">✓</span>`;
                    } else {
                        achEl.innerHTML = `<span class="text-gray-500">${achievement.name}</span><span class="text-gray-500">Locked</span>`;
                    }
                    DOMElements.achievementsList.appendChild(achEl);
                });
            }
        }

        function loadZone() {
            if (gameState.currentZoneIndex >= gameState.zones.length && !gameState.infiniteMode) return;
            if (gameState.infiniteMode && gameState.currentZoneIndex >= gameState.zones.length) {
                generateInfiniteZone(gameState.currentZoneIndex);
            }
            const zone = gameState.zones[gameState.currentZoneIndex];
            DOMElements.zoneName.textContent = zone.name;
            DOMElements.actionPrompt.textContent = zone.actionPrompt;
            logMessage(`You have entered the ${zone.name}.`, "zone");
            updateQuestList();
            // Initialize special mechanic
            if (zone.specialMechanic) {
                if (zone.specialMechanic.type === 'mana') {
                    gameState.mana = 0;
                    gameState.manaMax = zone.specialMechanic.maxMana;
                    gameState.manaBoostActive = false;
                }
            } else {
                gameState.mana = 0;
                gameState.manaMax = 0;
                gameState.manaBoostActive = false;
            }
            updateSpecialMechanicDisplay();
        }

        function generateInfiniteZone(zoneIndex) {
            const baseIndex = zoneIndex - ZONES.length + 1;
            const scale = Math.pow(1.5, baseIndex);
            const zoneNames = ["Eternal Abyss", "Void Citadel", "Cosmic Forge", "Nebula Spire", "Quantum Rift", "Astral Domain", "Dimensional Nexus", "Temporal Vault"];
            const prompts = ["Harness the infinite power.", "Conquer the endless void.", "Shape reality itself.", "Navigate the cosmic currents.", "Pierce the quantum veil.", "Command the astral forces.", "Bridge the dimensions.", "Unlock the temporal secrets."];
            const bossNames = ["Infinite Guardian", "Void Overlord", "Cosmic Behemoth", "Nebula Colossus", "Quantum Leviathan", "Astral Titan", "Dimensional Horror", "Temporal Emperor"];
            const flavors = ["A being of pure infinity, growing stronger with each defeat.", "The ruler of nothingness, devouring all in its path.", "A cosmic entity that warps space and time.", "A swirling mass of stellar energy and fury.", "A creature that exists in multiple quantum states.", "A radiant figure commanding celestial armies.", "A horror that spans countless realities.", "A master of time, bending ages to its will."];

            const zone = {
                name: `${zoneNames[baseIndex % zoneNames.length]} ${baseIndex}`,
                actionPrompt: prompts[baseIndex % prompts.length],
                challenges: [
                    { id: `infinite_gather_${baseIndex}`, description: `Gather ${formatNumber(100000000000 * scale)} Essence`, type: 'essence', requirement: 100000000000 * scale, completed: false },
                    { id: `infinite_clicks_${baseIndex}`, description: `Perform ${formatNumber(1000000000 * scale)} clicks`, type: 'clicks', requirement: 1000000000 * scale, completed: false },
                    { id: `infinite_level_${baseIndex}`, description: `Reach Level ${50 + baseIndex * 10}`, type: 'level', requirement: 50 + baseIndex * 10, completed: false }
                ],
                boss: {
                    name: `${bossNames[baseIndex % bossNames.length]} ${baseIndex}`,
                    hp: 1000000000 * Math.pow(1.2, baseIndex),
                    timer: 100 + baseIndex * 5,
                    flavorText: flavors[baseIndex % flavors.length]
                }
            };
            // Random special mechanic
            if (Math.random() < 0.5) {
                if (Math.random() < 0.5) {
                    zone.specialMechanic = {
                        type: "debuff",
                        name: "Infinite Mist",
                        description: `${Math.floor(10 + baseIndex)}% chance per click to halve essence gain for ${Math.floor(3 + baseIndex / 2)} seconds`,
                        chance: 0.1 + baseIndex * 0.01,
                        duration: 3000 + baseIndex * 500,
                        effect: "half_click"
                    };
                } else {
                    zone.specialMechanic = {
                        type: "mana",
                        name: "Infinite Mana",
                        description: "Build mana with clicks for a zone-wide boost",
                        maxMana: 50 + baseIndex * 10,
                        manaPerClick: 1,
                        boostMultiplier: 1.5 + baseIndex * 0.1,
                        boostDuration: 5000 + baseIndex * 500
                    };
                }
            }
            gameState.zones.push(zone);
        }

        function logMessage(message, type = "normal") {
            const msgEl = document.createElement('div');
            msgEl.classList.add('fade-in', 'flex', 'flex-col');

            const timeEl = document.createElement('span');
            timeEl.textContent = new Date().toLocaleTimeString([], {hour: '2-digit', minute:'2-digit', second: '2-digit'});
            timeEl.className = 'text-white text-xs opacity-75';
            timeEl.style.fontSize = '0.6rem';

            const textEl = document.createElement('span');
            textEl.textContent = message;

            switch (type) {
                case "system": textEl.className += " text-gray-400 italic"; break;
                case "system-ok": textEl.className += " text-green-400 italic"; break;
                case "system-warn": textEl.className += " text-yellow-400 italic"; break;
                case "quest": textEl.className += " text-amber-300"; break;
                case "zone": textEl.className += " text-purple-400 font-bold"; break;
                case "levelup": textEl.className += " text-yellow-300 font-bold font-cinzel"; break;
                case "danger": textEl.className += " text-red-400 font-bold"; break;
                case "victory": textEl.className += " text-green-300 font-bold font-cinzel"; break;
                default: textEl.className += " text-gray-300"; break;
            }

            msgEl.appendChild(timeEl);
            msgEl.appendChild(textEl);

            // Check if user was at bottom before adding
            const wasAtBottom = DOMElements.chatLog.scrollTop + DOMElements.chatLog.clientHeight >= DOMElements.chatLog.scrollHeight;

            DOMElements.chatLog.appendChild(msgEl);

            // Remove old messages if exceeding limit, and adjust scroll if not at bottom
            let removedHeight = 0;
            while (DOMElements.chatLog.children.length > 20) {
                const removedEl = DOMElements.chatLog.firstChild;
                removedHeight += removedEl.offsetHeight;
                DOMElements.chatLog.removeChild(removedEl);
            }

            // Auto-scroll only if user was at bottom
            if (wasAtBottom) {
                DOMElements.chatLog.scrollTop = DOMElements.chatLog.scrollHeight;
            } else if (removedHeight > 0) {
                // Adjust scroll position to prevent view shifting when messages are removed from top
                DOMElements.chatLog.scrollTop -= removedHeight;
            }
        }
        
        function showClickFeedback(text, colorClass) {
            const feedback = document.createElement('div');
            feedback.textContent = text;
            feedback.className = `absolute font-bold text-xl pointer-events-none ${colorClass} opacity-100 transition-all duration-1000`;
            feedback.style.background = 'rgba(0, 0, 0, 0.7)';
            feedback.style.padding = '4px 8px';
            feedback.style.borderRadius = '4px';
            feedback.style.textShadow = '2px 2px 4px rgba(0, 0, 0, 0.8)';
            feedback.style.zIndex = '101';

            // Random position around the button
            const rect = DOMElements.actionButton.getBoundingClientRect();
            const containerRect = DOMElements.clickFeedbackContainer.getBoundingClientRect();

            const x = Math.random() * rect.width + (rect.left - containerRect.left);
            const y = Math.random() * rect.height + (rect.top - containerRect.top);

            feedback.style.left = `${x}px`;
            feedback.style.top = `${y}px`;

            DOMElements.clickFeedbackContainer.appendChild(feedback);

            setTimeout(() => {
                feedback.style.opacity = '0';
                feedback.style.transform = 'translateY(-50px)';
            }, 10);

            setTimeout(() => {
                feedback.remove();
            }, 1000);
        }

        // --- Utility Functions ---
        function getEssencePerClick() {
            return Math.floor((1 + Math.floor(gameState.level / 2)) * gameState.clickMultiplier * gameState.prestigeMultiplier);
        }

        function getAttackDamage() {
            return Math.floor((getEssencePerClick() / 50) + 1) * gameState.attackMultiplier;
        }

        function getBankSize() {
            return Math.floor((50 + (gameState.level * 10)) * gameState.bankMultiplier * gameState.prestigeMultiplier);
        }

        function getAutoClickRate() {
            return Math.floor((1 + Math.floor(gameState.level / 5)) * gameState.autoClickMultiplier * gameState.prestigeMultiplier);
        }

        function getPassiveIncomeRate() {
            return Math.floor((Math.floor(gameState.level / 10) + gameState.currentZoneIndex) * gameState.passiveMultiplier * gameState.prestigeMultiplier);
        }

        function updatePassiveIncome() {
            const now = Date.now();
            const today = new Date().toDateString();
            if (gameState.lastLoginDate !== today) {
                gameState.streak++;
                gameState.lastLoginDate = today;
                const bonus = gameState.streak * 1000;
                gameState.essence += bonus;
                logMessage(`Daily login bonus! Streak: ${gameState.streak} days. Gained ${formatNumber(bonus)} essence.`, "system-ok");
            }
            const timeDiff = (now - gameState.lastUpdateTime) / 1000; // seconds
            let passiveRate = gameState.passiveIncomeRate;
            if (gameState.passiveBoostActive && now < gameState.passiveBoostEndTime) {
                passiveRate *= 2;
            } else if (gameState.passiveBoostActive) {
                gameState.passiveBoostActive = false;
                updateUI();
            }
            if (gameState.investmentActive && now < gameState.investmentEndTime) {
                passiveRate *= 2;
            } else if (gameState.investmentActive) {
                gameState.investmentActive = false;
                logMessage("Risky investment completed successfully!", "system-ok");
                updateUI();
            }
            // Apply debuff to passive
            if (gameState.currentDebuff && now < gameState.debuffEndTime) {
                passiveRate = Math.floor(passiveRate / 2);
            } else if (gameState.currentDebuff) {
                gameState.currentDebuff = null;
                updateUI();
            }
            // Apply mana boost to passive
            const zone = gameState.zones[gameState.currentZoneIndex];
            if (zone && zone.specialMechanic && zone.specialMechanic.type === 'mana' && gameState.manaBoostActive && now < gameState.manaBoostEndTime) {
                passiveRate = Math.floor(passiveRate * zone.specialMechanic.boostMultiplier);
            } else if (gameState.manaBoostActive) {
                gameState.manaBoostActive = false;
                updateUI();
            }
            const passiveGained = Math.floor(timeDiff * passiveRate);
            if (passiveGained > 0) {
                gameState.essence += passiveGained;
                gameState.totalPassiveGained += passiveGained;
                gameState.accumulatedPassive += passiveGained;
                gainXP(Math.floor(passiveGained / 100));
                checkQuestCompletion(false);
            }

            // Bank interest (compound, scales with bank upgrades, per second)
            let interestThisTick = gameState.bankedClicks * (0.001 * (1 + gameState.bankUpgradeLevel * 0.1)) * timeDiff;
            if (gameState.activeEvents.some(e => e.effect === 'double_bank')) {
                interestThisTick *= 2;
            }
            gameState.fractionalBankInterest += interestThisTick;
            let wholeClicks = Math.floor(gameState.fractionalBankInterest);
            if (wholeClicks > 0) {
                gameState.bankedClicks += wholeClicks;
                gameState.accumulatedBankInterest += wholeClicks;
                gameState.totalBankInterestEarned += wholeClicks;
                gameState.fractionalBankInterest -= wholeClicks;
            }

            // Auto-clicker
            if (gameState.isAutoClickerActive) {
                if (gameState.bankedClicks >= gameState.autoClickCostPerSecond) {
                    gameState.bankedClicks -= gameState.autoClickCostPerSecond;
                    const essenceGained = getAutoClickRate();
                    gameState.essence += essenceGained;
                    gainXP(1);
                } else {
                    gameState.isAutoClickerActive = false;
                    logMessage("Auto-clicker deactivated: insufficient banked clicks.", "system-warn");
                }
            }

            gameState.lastUpdateTime = now;
            gameState.passiveIncomeRate = getPassiveIncomeRate();

            // Log accumulated passive every 10 seconds
            if (now - gameState.lastPassiveLogTime > 10000 && gameState.accumulatedPassive > 0) {
                logMessage(`You gained ${formatNumber(gameState.accumulatedPassive)} Essence from passive income.`, "system-ok");
                gameState.accumulatedPassive = 0;
                gameState.lastPassiveLogTime = now;
            }

            // Log bank interest every 10 seconds
            if (now - gameState.lastBankLogTime > 10000 && gameState.accumulatedBankInterest > 0) {
                logMessage(`Your bank has accrued ${formatNumber(gameState.accumulatedBankInterest)} interest clicks.`, "system-ok");
                gameState.accumulatedBankInterest = 0;
                gameState.lastBankLogTime = now;
            }

            // Random event trigger (5% chance every second)
            if (Math.random() < 0.05 && gameState.activeEvents.length === 0 && !gameState.pendingEvent && Date.now() > gameState.eventCooldownEndTime) {
                triggerRandomEvent();
                gameState.nextEventCountdown = 20; // Reset countdown on trigger
            }

            // Update event buffer
            if (gameState.eventBufferCountdown > 0) {
                gameState.eventBufferCountdown--;
                if (gameState.eventBufferCountdown <= 0) {
                    activatePendingEvent();
                }
            }

            // Update event countdown
            if (gameState.nextEventCountdown > 0) {
                gameState.nextEventCountdown--;
            }

            // Update active events
            updateActiveEvents();
        }

        function buyClickUpgrade() {
            const cost = getClickUpgradeCost();
            if (gameState.essence >= cost) {
                gameState.essence -= cost;
                gameState.clickUpgradeLevel++;
                logMessage("Click Power upgraded! Essence per click increased.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.clickLabel, DOMElements.upgradeClick);
            }
        }

        function buyPassiveUpgrade() {
            const cost = getPassiveUpgradeCost();
            if (gameState.essence >= cost) {
                gameState.essence -= cost;
                gameState.passiveUpgradeLevel++;
                logMessage("Passive Income upgraded! Passive income increased.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
                DOMElements.upgradePassive.classList.add('success-click');
                setTimeout(() => DOMElements.upgradePassive.classList.remove('success-click'), 500);
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.passiveLabel, DOMElements.upgradePassive);
            }
        }

        function buyBankUpgrade() {
            const cost = getBankUpgradeCost();
            if (gameState.essence >= cost) {
                gameState.essence -= cost;
                gameState.bankUpgradeLevel++;
                logMessage("Bank Capacity upgraded! Bank size increased.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
                DOMElements.upgradeBank.classList.add('success-click');
                setTimeout(() => DOMElements.upgradeBank.classList.remove('success-click'), 500);
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.bankLabel, DOMElements.upgradeBank);
            }
        }

        function buyAutoClickUpgrade() {
            const cost = getAutoClickUpgradeCost();
            if (gameState.essence >= cost) {
                gameState.essence -= cost;
                gameState.autoClickUpgradeLevel++;
                logMessage("Auto-Clicker upgraded! Auto-click rate increased.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
                DOMElements.upgradeAutoClick.classList.add('success-click');
                setTimeout(() => DOMElements.upgradeAutoClick.classList.remove('success-click'), 500);
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.autoLabel, DOMElements.upgradeAutoClick);
            }
        }

        function buyCritChanceUpgrade() {
            const cost = getCritChanceUpgradeCost();
            if (gameState.essence >= cost) {
                gameState.essence -= cost;
                gameState.critChanceUpgradeLevel++;
                logMessage("Critical Chance upgraded! Critical hit chance increased.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
                DOMElements.upgradeCritChance.classList.add('success-click');
                setTimeout(() => DOMElements.upgradeCritChance.classList.remove('success-click'), 500);
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.critChanceLabel, DOMElements.upgradeCritChance);
            }
        }

        function buyCritMultUpgrade() {
            const cost = getCritMultUpgradeCost();
            if (gameState.essence >= cost) {
                gameState.essence -= cost;
                gameState.critMultUpgradeLevel++;
                logMessage("Critical Multiplier upgraded! Critical damage increased.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
                DOMElements.upgradeCritMult.classList.add('success-click');
                setTimeout(() => DOMElements.upgradeCritMult.classList.remove('success-click'), 500);
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.critMultLabel, DOMElements.upgradeCritMult);
            }
        }

        function buyLuckUpgrade() {
            const cost = getLuckUpgradeCost();
            if (gameState.essence >= cost) {
                gameState.essence -= cost;
                gameState.luckUpgradeLevel++;
                logMessage("Luck upgraded! Critical hit chance increased.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
                DOMElements.upgradeLuck.classList.add('success-click');
                setTimeout(() => DOMElements.upgradeLuck.classList.remove('success-click'), 500);
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.luckLabel, DOMElements.upgradeLuck);
            }
        }

        function buyEfficiencyUpgrade() {
            const cost = getEfficiencyUpgradeCost();
            if (gameState.essence >= cost) {
                gameState.essence -= cost;
                gameState.efficiencyUpgradeLevel++;
                logMessage("Efficiency upgraded! Upgrade costs reduced.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
                DOMElements.upgradeEfficiency.classList.add('success-click');
                setTimeout(() => DOMElements.upgradeEfficiency.classList.remove('success-click'), 500);
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.efficiencyLabel, DOMElements.upgradeEfficiency);
            }
        }

        function buyRegenerationUpgrade() {
            const cost = getRegenerationUpgradeCost();
            if (gameState.essence >= cost) {
                gameState.essence -= cost;
                gameState.regenerationUpgradeLevel++;
                logMessage("Regeneration upgraded! Passive income increased.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
                DOMElements.upgradeRegeneration.classList.add('success-click');
                setTimeout(() => DOMElements.upgradeRegeneration.classList.remove('success-click'), 500);
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.regenerationLabel, DOMElements.upgradeRegeneration);
            }
        }

        function buyTimeCrystalUpgrade() {
            const cost = getTimeCrystalUpgradeCost();
            if (gameState.essence >= cost) {
                gameState.essence -= cost;
                gameState.timeCrystalUpgradeLevel++;
                logMessage("Time Crystal upgraded! Offline progress cap increased.", "system-ok");
                DOMElements.upgradeFlavor.textContent = "(Leveled up!)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                updateUI();
                DOMElements.upgradeTimeCrystal.classList.add('success-click');
                setTimeout(() => DOMElements.upgradeTimeCrystal.classList.remove('success-click'), 500);
            } else {
                logMessage("Not enough Essence for this upgrade.", "system-warn");
                DOMElements.upgradeFlavor.textContent = "(Not enough Essence)";
                setTimeout(() => DOMElements.upgradeFlavor.textContent = "", 2000);
                shakeElements(DOMElements.timeCrystalLabel, DOMElements.upgradeTimeCrystal);
            }
        }

        function prestige() {
            if (gameState.level < 50) return;
            const pointsGained = Math.floor(gameState.level / 10);
            gameState.prestigePoints += pointsGained;
            gameState.prestigeMultiplier = 1 + gameState.prestigePoints * 0.01;
            // Reset
            gameState.level = 1;
            gameState.xp = 0;
            gameState.xpToNextLevel = 100;
            gameState.essence = 0;
            gameState.totalClicks = 0;
            gameState.bankedClicks = 0;
            gameState.currentZoneIndex = 0;
            gameState.zones = JSON.parse(JSON.stringify(ZONES));
            gameState.passiveIncomeRate = 0;
            gameState.totalPassiveGained = 0;
            gameState.accumulatedPassive = 0;
            gameState.lastPassiveLogTime = Date.now();
            gameState.activeEvents = [];
            gameState.companions = [];
            logMessage(`You have prestiged! Gained ${pointsGained} prestige points. Multiplier increased to ${gameState.prestigeMultiplier.toFixed(2)}x`, "victory");
            loadZone();
            updateUI();
            DOMElements.prestigeButton.classList.add('success-click');
            setTimeout(() => DOMElements.prestigeButton.classList.remove('success-click'), 500);
        }

        function exportSave() {
            const saveData = btoa(JSON.stringify(gameState));
            navigator.clipboard.writeText(saveData).then(() => {
                logMessage("Save code copied to clipboard! Share this code to transfer your save.", "system-ok");
            }).catch(() => {
                logMessage("Failed to copy save code. Please check clipboard permissions.", "system-warn");
            });
        }

        function loadSave() {
            const code = DOMElements.loadSaveInput.value.trim();
            if (!code) {
                logMessage("Please enter a save code.", "system-warn");
                return;
            }
            try {
                const decoded = atob(code);
                const loadedState = JSON.parse(decoded);
                // Basic validation
                if (typeof loadedState !== 'object' || !loadedState.essence) {
                    throw new Error("Invalid save data");
                }
                // Merge the loaded state
                gameState = { ...gameState, ...loadedState };
                // Ensure new properties are initialized (same as loadGame)
                if (typeof gameState.accumulatedPassive === 'undefined') gameState.accumulatedPassive = 0;
                if (typeof gameState.lastPassiveLogTime === 'undefined') gameState.lastPassiveLogTime = Date.now();
                if (typeof gameState.clickUpgradeLevel === 'undefined') gameState.clickUpgradeLevel = 0;
                if (typeof gameState.passiveUpgradeLevel === 'undefined') gameState.passiveUpgradeLevel = 0;
                if (typeof gameState.bankUpgradeLevel === 'undefined') gameState.bankUpgradeLevel = 0;
                if (typeof gameState.autoClickUpgradeLevel === 'undefined') gameState.autoClickUpgradeLevel = 0;
                if (typeof gameState.critChanceUpgradeLevel === 'undefined') gameState.critChanceUpgradeLevel = 0;
                if (typeof gameState.critMultUpgradeLevel === 'undefined') gameState.critMultUpgradeLevel = 0;
                if (typeof gameState.luckUpgradeLevel === 'undefined') gameState.luckUpgradeLevel = 0;
                if (typeof gameState.efficiencyUpgradeLevel === 'undefined') gameState.efficiencyUpgradeLevel = 0;
                if (typeof gameState.regenerationUpgradeLevel === 'undefined') gameState.regenerationUpgradeLevel = 0;
                if (typeof gameState.critChance === 'undefined') gameState.critChance = 0;
                if (typeof gameState.critMultiplier === 'undefined') gameState.critMultiplier = 2;
                if (typeof gameState.prestigePoints === 'undefined') gameState.prestigePoints = 0;
                if (typeof gameState.prestigeMultiplier === 'undefined') gameState.prestigeMultiplier = 1;
                if (typeof gameState.accumulatedBankInterest === 'undefined') gameState.accumulatedBankInterest = 0;
                if (typeof gameState.lastBankLogTime === 'undefined') gameState.lastBankLogTime = Date.now();
                if (typeof gameState.totalBankInterestEarned === 'undefined') gameState.totalBankInterestEarned = 0;
                if (typeof gameState.passiveBoostActive === 'undefined') gameState.passiveBoostActive = false;
                if (typeof gameState.passiveBoostEndTime === 'undefined') gameState.passiveBoostEndTime = 0;
                if (typeof gameState.ceoActive === 'undefined') gameState.ceoActive = false;
                if (typeof gameState.ceoEndTime === 'undefined') gameState.ceoEndTime = 0;
                if (typeof gameState.lastCEOLogTime === 'undefined') gameState.lastCEOLogTime = Date.now();
                if (typeof gameState.xpMultiplier === 'undefined') gameState.xpMultiplier = 1;
                if (typeof gameState.isAutoClickerActive === 'undefined') gameState.isAutoClickerActive = false;
                if (typeof gameState.autoClickCostPerSecond === 'undefined') gameState.autoClickCostPerSecond = 1;
                // Restore CEO from active events
                gameState.activeEvents.forEach(event => {
                    if (event.id === 'ceo_active') {
                        gameState.ceoActive = true;
                        gameState.ceoEndTime = event.endTime;
                    }
                });
                if (typeof gameState.activeEvents === 'undefined') gameState.activeEvents = [];
                if (typeof gameState.companions === 'undefined') gameState.companions = [];
                if (typeof gameState.relics === 'undefined') gameState.relics = [];
                if (typeof gameState.currentDebuff === 'undefined') gameState.currentDebuff = null;
                if (typeof gameState.debuffEndTime === 'undefined') gameState.debuffEndTime = 0;
                if (typeof gameState.mana === 'undefined') gameState.mana = 0;
                if (typeof gameState.manaMax === 'undefined') gameState.manaMax = 0;
                if (typeof gameState.manaBoostActive === 'undefined') gameState.manaBoostActive = false;
                if (typeof gameState.manaBoostEndTime === 'undefined') gameState.manaBoostEndTime = 0;
                if (typeof gameState.investmentActive === 'undefined') gameState.investmentActive = false;
                if (typeof gameState.investmentEndTime === 'undefined') gameState.investmentEndTime = 0;
                if (typeof gameState.infiniteMode === 'undefined') gameState.infiniteMode = false;
                if (typeof gameState.startTime === 'undefined') gameState.startTime = Date.now();
                if (typeof gameState.streak === 'undefined') gameState.streak = 0;
                if (typeof gameState.lastLoginDate === 'undefined') gameState.lastLoginDate = new Date().toDateString();
                if (typeof gameState.timeCrystalUpgradeLevel === 'undefined') gameState.timeCrystalUpgradeLevel = 0;
                if (typeof gameState.nextEventCountdown === 'undefined') gameState.nextEventCountdown = 20;
                if (typeof gameState.pendingEvent === 'undefined') gameState.pendingEvent = null;
                if (typeof gameState.eventBufferCountdown === 'undefined') gameState.eventBufferCountdown = 0;
                if (typeof gameState.bossFrozen === 'undefined') gameState.bossFrozen = false;
                if (typeof gameState.guaranteeRareDrop === 'undefined') gameState.guaranteeRareDrop = false;
                if (typeof gameState.attackMultiplier === 'undefined') gameState.attackMultiplier = 1;
                if (typeof gameState.originalZoneName === 'undefined') gameState.originalZoneName = null;
                if (typeof gameState.fractionalBankInterest === 'undefined') gameState.fractionalBankInterest = 0;
                if (typeof gameState.musicEnabled === 'undefined') gameState.musicEnabled = false;
                if (typeof gameState.chronicleCollapsed === 'undefined') gameState.chronicleCollapsed = false;
                if (typeof gameState.eventCooldownEndTime === 'undefined') gameState.eventCooldownEndTime = 0;
                // Clear any active events on load to prevent them from continuing
                gameState.activeEvents = [];
                gameState.pendingEvent = null;
                gameState.eventBufferCountdown = 0;
                gameState.nextEventCountdown = 20;
                // Deep copy zones from master list but keep completed status
                const masterZones = JSON.parse(JSON.stringify(ZONES));
                gameState.zones = masterZones.map((zone, index) => {
                    if (loadedState.zones && loadedState.zones[index]) {
                        zone.challenges.forEach((challenge, cIndex) => {
                            if(loadedState.zones[index].challenges[cIndex]){
                                challenge.completed = loadedState.zones[index].challenges[cIndex].completed;
                            }
                        });
                    }
                    return zone;
                });
                // Reset bank mode on load
                gameState.isBankMode = false;
                // Recheck quest completion
                checkQuestCompletion(false);
                // Skip offline passive and daily login for manual load
                gameState.lastUpdateTime = Date.now();
                logMessage("Save loaded successfully!", "system-ok");
                loadZone();
                updateUI();
            } catch (e) {
                logMessage("Failed to load save: Invalid code or corrupted data.", "system-warn");
            }
        }

        function triggerRandomEvent() {
            // Rarity weights: Common 40%, Uncommon 30%, Rare 20%, Epic 7%, Legendary 3%
            const rarityWeights = {
                'Common': 0.4,
                'Uncommon': 0.3,
                'Rare': 0.2,
                'Epic': 0.07,
                'Legendary': 0.03
            };
            const rand = Math.random();
            let cumulative = 0;
            let selectedRarity = 'Common';
            for (const [rarity, weight] of Object.entries(rarityWeights)) {
                cumulative += weight;
                if (rand < cumulative) {
                    selectedRarity = rarity;
                    break;
                }
            }
            // Get events of selected rarity
            const rarityEvents = EVENTS.filter(e => e.rarity === selectedRarity);
            const event = rarityEvents[Math.floor(Math.random() * rarityEvents.length)];
            gameState.pendingEvent = event;
            gameState.eventBufferCountdown = 11;
            const incomingMessages = [
                "The veil between realms thins... An event stirs in the ether!",
                "Whispers of power echo through the syntax... Something approaches!",
                "The gilded threads of fate weave a new pattern... Brace yourself!",
                "Ancient energies coalesce... A random event manifests soon!",
                "The code of destiny rewrites itself... An event is imminent!"
            ];
            const randomMessage = incomingMessages[Math.floor(Math.random() * incomingMessages.length)];
            logMessage(`Event Incoming: ${randomMessage}`, "system-ok");
        }

        function activatePendingEvent() {
            const event = gameState.pendingEvent;
            if (!event) return;
            gameState.activeEvents.push({
                ...event,
                startTime: Date.now(),
                endTime: Date.now() + event.duration
            });
            const msgType = event.type === 'negative' ? "system-warn" : "system-ok";
            logMessage(`Event Activated: (${event.rarity}) ${event.name}`, msgType);
            // Add effect description
            let effectDesc = "";
            switch (event.effect) {
                case 'double_click': effectDesc = "Doubles essence gained from clicks"; break;
                case 'half_click': effectDesc = "Halves essence gained from clicks"; break;
                case 'quarter_click': effectDesc = "Reduces click power by 25%"; break;
                case 'triple_passive': effectDesc = "Triples passive income"; break;
                case 'half_passive': effectDesc = "Halves passive income"; break;
                case 'max_crit': effectDesc = "Grants 100% critical hit chance"; break;
                case 'half_costs': effectDesc = "Halves upgrade costs"; break;
                case 'double_bank': effectDesc = "Doubles bank interest rate"; break;
                case 'quad_passive': effectDesc = "Quadruples passive income"; break;
                case 'super_crit': effectDesc = "150% crit chance with 2x multiplier"; break;
                case 'quintuple_click': effectDesc = "Quintuples essence from clicks"; break;
                case 'infinite_crit': effectDesc = "100% crit chance with 3x multiplier"; break;
                case 'decuple_passive': effectDesc = "Decuples passive income"; break;
                case 'legendary_boost': effectDesc = "Sextuples clicks and passive income"; break;
                case 'freeze_boss': effectDesc = "Freezes boss timer for 30 seconds"; break;
                case 'guarantee_rare': effectDesc = "Guarantees rare+ boss drops"; break;
                case 'luck_boost': effectDesc = "Increases luck by 10%"; break;
                default: effectDesc = event.description;
            }
            logMessage(`Effect: ${effectDesc} for ${event.duration / 1000} seconds`, "system");
            applyEventEffect(event);
            gameState.pendingEvent = null;
            // Handle chained events
            if (event.chain === 'mini_boss') {
                setTimeout(() => {
                    if (!bossState.active) {
                        logMessage("The Essence Storm has attracted a Mini-Boss!", "danger");
                        // Simple mini-boss: small HP, short timer
                        bossState.active = true;
                        bossState.hp = 100;
                        bossState.maxHp = 100;
                        bossState.timeLeft = 10;
                        bossState.isMiniBoss = true;
                        DOMElements.bossContainer.innerHTML = `
                            <div class="fade-in w-full">
                                <h3 class="font-cinzel text-2xl font-bold text-red-300 drop-shadow-lg">Mini-Boss: Storm Elemental</h3>
                                <p class="text-red-200 mt-2 mb-4">A small but fierce foe drawn by the storm!</p>
                                <p id="bossHp" class="text-xl font-bold text-white">100 / 100</p>
                                <div class="w-full bg-gray-700 rounded-full h-4 mt-4 border-2 border-black/50">
                                    <div id="bossTimerBar" class="bg-yellow-400 h-full rounded-full" style="width: 100%"></div>
                                </div>
                                <p id="bossTimeLeft" class="text-lg font-bold mt-2">10s remaining</p>
                            </div>
                        `;
                        DOMElements.bossContainer.classList.remove('hidden', 'absolute', 'inset-0');
                        DOMElements.bossContainer.classList.add('flex');
                        DOMElements.zoneName.style.display = 'none';
                        DOMElements.actionPrompt.style.display = 'none';
                        DOMElements.actionButton.className = 'btn action-btn attack-mode';
                        bossState.timer = setInterval(() => {
                            bossState.timeLeft--;
                            const timerBar = document.getElementById('bossTimerBar');
                            const timeLeftDisplay = document.getElementById('bossTimeLeft');
                            if (timerBar) timerBar.style.width = `${(bossState.timeLeft / 10) * 100}%`;
                            if (timeLeftDisplay) timeLeftDisplay.textContent = `${bossState.timeLeft}s remaining`;
                            if (bossState.timeLeft <= 0) {
                                loseBossFight();
                            }
                        }, 1000);
                    }
                }, 10000); // 10 seconds delay
            }
        }

        function applyEventEffect(event) {
            switch (event.effect) {
                case 'double_click':
                    gameState.clickMultiplier *= 2;
                    break;
                case 'triple_passive':
                    gameState.passiveMultiplier *= 3;
                    break;
                case 'max_crit':
                    gameState.critChance = 1;
                    break;
                case 'half_costs':
                    gameState.efficiencyMultiplier *= 0.5;
                    break;
                case 'half_passive':
                    gameState.passiveMultiplier *= 0.5;
                    break;
                case 'quarter_click':
                    gameState.clickMultiplier *= 0.75;
                    break;
                case 'luck_boost':
                    gameState.luckMultiplier *= 1.1;
                    break;
                case 'double_bank':
                    // Handled in updatePassiveIncome
                    break;
                case 'quad_passive':
                    gameState.passiveMultiplier *= 4;
                    break;
                case 'super_crit':
                    gameState.critChance = 1.5;
                    gameState.critMultiplier = 4; // 2x base
                    break;
                case 'quintuple_click':
                    gameState.clickMultiplier *= 5;
                    break;
                case 'infinite_crit':
                    gameState.critChance = 1;
                    gameState.critMultiplier = 6; // 3x base
                    break;
                case 'decuple_passive':
                    gameState.passiveMultiplier *= 10;
                    break;
                case 'legendary_boost':
                    gameState.clickMultiplier *= 6;
                    gameState.passiveMultiplier *= 6;
                    break;
                case 'freeze_boss':
                    gameState.bossFrozen = true;
                    break;
                case 'guarantee_rare':
                    gameState.guaranteeRareDrop = true;
                    break;
            }
        }

        function updateActiveEvents() {
            const now = Date.now();
            gameState.activeEvents = gameState.activeEvents.filter(event => {
                if (now >= event.endTime) {
                    removeEventEffect(event);
                    if (event.id === 'ceo_active') {
                        gameState.ceoActive = false;
                        logMessage("CEO of Money's contract has expired.", "system");
                    } else {
                        logMessage(`Event ended: ${event.name}`, "system");
                    }
                    return false;
                }
                return true;
            });
            updateActiveEventsList();
        }

        function removeEventEffect(event) {
            switch (event.effect) {
                case 'double_click':
                    gameState.clickMultiplier /= 2;
                    break;
                case 'triple_passive':
                    gameState.passiveMultiplier /= 3;
                    break;
                case 'max_crit':
                    gameState.critChance = Math.min(0.5, (0.05 * gameState.critChanceUpgradeLevel) * gameState.luckMultiplier);
                    break;
                case 'half_costs':
                    gameState.efficiencyMultiplier /= 0.5;
                    break;
                case 'half_passive':
                    gameState.passiveMultiplier /= 0.5;
                    break;
                case 'quarter_click':
                    gameState.clickMultiplier /= 0.75;
                    break;
                case 'luck_boost':
                    gameState.luckMultiplier /= 1.1;
                    break;
                case 'double_bank':
                    // Handled in updatePassiveIncome
                    break;
                case 'quad_passive':
                    gameState.passiveMultiplier /= 4;
                    break;
                case 'super_crit':
                    gameState.critChance = Math.min(0.5, (0.05 * gameState.critChanceUpgradeLevel) * gameState.luckMultiplier);
                    gameState.critMultiplier = 2 + 0.5 * gameState.critMultUpgradeLevel;
                    break;
                case 'quintuple_click':
                    gameState.clickMultiplier /= 5;
                    break;
                case 'infinite_crit':
                    gameState.critChance = Math.min(0.5, (0.05 * gameState.critChanceUpgradeLevel) * gameState.luckMultiplier);
                    gameState.critMultiplier = 2 + 0.5 * gameState.critMultUpgradeLevel;
                    break;
                case 'decuple_passive':
                    gameState.passiveMultiplier /= 10;
                    break;
                case 'legendary_boost':
                    gameState.clickMultiplier /= 6;
                    gameState.passiveMultiplier /= 6;
                    break;
                case 'freeze_boss':
                    gameState.bossFrozen = false;
                    break;
                case 'guarantee_rare':
                    gameState.guaranteeRareDrop = false;
                    break;
            }
        }


        function updateActiveEventsList() {
            DOMElements.activeEventsList.innerHTML = '';
            if (gameState.activeEvents.length === 0) {
                DOMElements.activeEventsList.innerHTML = '<div class="text-gray-500 text-sm">No active events</div>';
                return;
            }
            gameState.activeEvents.forEach(event => {
                const timeLeft = Math.ceil((event.endTime - Date.now()) / 1000);
                const eventEl = document.createElement('div');
                eventEl.className = 'flex justify-between items-center text-sm';
                const rarityClass = event.rarity.toLowerCase();
                eventEl.innerHTML = `<span><span class="rarity-prefix ${rarityClass}"><span>(${event.rarity})</span></span>${event.name}</span><span class="text-gray-400">${timeLeft}s</span>`;
                DOMElements.activeEventsList.appendChild(eventEl);
            });
        }

        function getInitialGameState() {
            return {
                essence: 0,
                level: 1,
                xp: 0,
                xpToNextLevel: 100,
                totalClicks: 0,
                bankedClicks: 0,
                isBankMode: false,
                isAutoClickerActive: false,
                autoClickCostPerSecond: 1,
                currentZoneIndex: 0,
                zones: JSON.parse(JSON.stringify(ZONES)), // Deep copy
                passiveIncomeRate: 0,
                lastUpdateTime: Date.now(),
                clickMultiplier: 1,
                passiveMultiplier: 1,
                totalPassiveGained: 0,
                accumulatedPassive: 0,
                lastPassiveLogTime: Date.now(),
                clickUpgradeLevel: 0,
                passiveUpgradeLevel: 0,
                bankUpgradeLevel: 0,
                autoClickUpgradeLevel: 0,
                critChanceUpgradeLevel: 0,
                critMultUpgradeLevel: 0,
                luckUpgradeLevel: 0,
                efficiencyUpgradeLevel: 0,
                regenerationUpgradeLevel: 0,
                critChance: 0,
                critMultiplier: 2,
                prestigePoints: 0,
                prestigeMultiplier: 1,
                luckMultiplier: 1,
                efficiencyMultiplier: 1,
                regenerationMultiplier: 1,
                xpMultiplier: 1,
                accumulatedBankInterest: 0,
                lastBankLogTime: Date.now(),
                passiveBoostActive: false,
                passiveBoostEndTime: 0,
                ceoActive: false,
                ceoEndTime: 0,
                lastCEOLogTime: Date.now(),
                activeEvents: [],
                companions: [],
                relics: [],
                currentDebuff: null,
                debuffEndTime: 0,
                mana: 0,
                manaMax: 0,
                manaBoostActive: false,
                manaBoostEndTime: 0,
                investmentActive: false,
                investmentEndTime: 0,
                infiniteMode: false,
                startTime: Date.now(),
                streak: 0,
                lastLoginDate: new Date().toDateString(),
                timeCrystalUpgradeLevel: 0,
                bossFrozen: false,
                guaranteeRareDrop: false,
                attackMultiplier: 1,
                nextEventCountdown: 20,
                pendingEvent: null,
                eventBufferCountdown: 0,
                bankMultiplier: 1,
                autoClickMultiplier: 1,
                originalZoneName: null,
                originalActionPrompt: null,
                achievements: [],
                fractionalBankInterest: 0,
                musicEnabled: false,
                eventCooldownEndTime: 0
            };
        }

        function resetProfile() {
            if (confirm("Are you sure you want to reset your progress? This will delete all saved data and cannot be undone.")) {
                gameState = getInitialGameState();
                localStorage.removeItem('gildedSyntaxSave');
                loadZone();
                updateUI();
                logMessage("Profile reset complete. All progress has been cleared.", "system");
                window.location.reload();
            }
        }

        function debugToggle() {
            gameState.essence = 20000000;
            logMessage("Debug: Set essence to 20,000,000", "system");
            if (gameState.relics.length === 0) {
                const relic = RELICS[Math.floor(Math.random() * RELICS.length)];
                gameState.relics.push(relic);
                logMessage(`Debug: Added relic ${relic.name}`, "system");
            } else {
                gameState.relics = [];
                logMessage("Debug: Removed all relics", "system");
            }
            updateUI();
        }

        function updateCompanionsList() {
            DOMElements.companionsList.innerHTML = '';
            if (gameState.companions.length === 0) {
                DOMElements.companionsList.innerHTML = '<div class="text-gray-500 text-sm">No companions summoned</div>';
                return;
            }
            gameState.companions.forEach(companion => {
                const companionEl = document.createElement('div');
                companionEl.className = 'flex justify-between items-center text-sm';
                companionEl.innerHTML = `<span class="text-white">${companion.name}</span><span class="text-green-400">${companion.description}</span>`;
                DOMElements.companionsList.appendChild(companionEl);
            });
            // Update button states
            COMPANIONS.forEach(companion => {
                const buttonEl = DOMElements['summon' + companion.id.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('')];
                const isSummoned = gameState.companions.some(c => c.id === companion.id);
                // Reset to original colors based on companion
                const colors = {
                    fire_sprite: 'bg-red-700 hover:bg-red-600',
                    water_nymph: 'bg-blue-700 hover:bg-blue-600',
                    earth_golem: 'bg-green-700 hover:bg-green-600',
                    air_spirit: 'bg-gray-700 hover:bg-gray-600',
                    shadow_imp: 'bg-purple-700 hover:bg-purple-600'
                };
                if (isSummoned) {
                    buttonEl.disabled = true;
                    buttonEl.textContent = "Summoned";
                    buttonEl.classList.remove('bg-red-700', 'hover:bg-red-600', 'bg-blue-700', 'hover:bg-blue-600', 'bg-green-700', 'hover:bg-green-600', 'bg-gray-700', 'hover:bg-gray-600', 'bg-purple-700', 'hover:bg-purple-600', 'bg-green-600', 'cursor-not-allowed', 'opacity-50');
                    buttonEl.classList.add(...colors[companion.id].split(' '), 'cursor-not-allowed', 'opacity-50');
                } else {
                    buttonEl.disabled = false;
                    buttonEl.textContent = "Summon";
                    buttonEl.classList.remove('bg-red-700', 'hover:bg-red-600', 'bg-blue-700', 'hover:bg-blue-600', 'bg-green-700', 'hover:bg-green-600', 'bg-gray-700', 'hover:bg-gray-600', 'bg-purple-700', 'hover:bg-purple-600', 'bg-green-600', 'cursor-not-allowed', 'opacity-50');
                    buttonEl.classList.add(...colors[companion.id].split(' '));
                }
            });
        }

        function updateRelicsList() {
            DOMElements.relicsList.innerHTML = '';
            if (gameState.relics.length === 0) {
                DOMElements.relicsList.innerHTML = '<div class="text-gray-500 text-sm">No relics collected</div>';
                return;
            }
            gameState.relics.forEach(relic => {
                const relicEl = document.createElement('div');
                relicEl.className = 'flex justify-between items-center text-sm glow-static';
                relicEl.style.color = getRarityColor(relic.rarity);
                relicEl.innerHTML = `<span>${relic.name}</span><span class="text-green-400">${relic.description}</span>`;
                DOMElements.relicsList.appendChild(relicEl);
            });
        }

        function updateSpecialMechanicDisplay() {
            const zone = gameState.zones[gameState.currentZoneIndex];
            if (!zone || !zone.specialMechanic) {
                DOMElements.specialMechanicDisplay.innerHTML = '';
                return;
            }
            // Hide if boss is ready or bank mode is active
            if (gameState.currentZoneIndex < gameState.zones.length) {
                const bossReady = zone.challenges.every(c => c.completed);
                if (bossReady || gameState.isBankMode) {
                    DOMElements.specialMechanicDisplay.innerHTML = '';
                    return;
                }
            }
            const mechanic = zone.specialMechanic;
            if (mechanic.type === 'debuff') {
                if (gameState.currentDebuff) {
                    const timeLeft = Math.ceil((gameState.debuffEndTime - Date.now()) / 1000);
                    DOMElements.specialMechanicDisplay.innerHTML = `<div class="text-red-400 text-sm">${mechanic.name}: Essence halved for ${timeLeft}s</div>`;
                } else {
                    DOMElements.specialMechanicDisplay.innerHTML = `<div class="text-gray-500 text-sm">${mechanic.description}</div>`;
                }
            } else if (mechanic.type === 'mana') {
                const manaPercent = (gameState.mana / gameState.manaMax) * 100;
                const boostText = gameState.manaBoostActive ? ` (Boost Active: ${Math.ceil((gameState.manaBoostEndTime - Date.now()) / 1000)}s)` : '';
                DOMElements.specialMechanicDisplay.innerHTML = `
                    <div class="text-blue-400 text-sm mb-2">${mechanic.name}: ${mechanic.description}</div>
                    <div class="w-full bg-gray-700 rounded-full h-4">
                        <div class="bg-blue-500 h-full rounded-full transition-all duration-300" style="width: ${manaPercent}%"></div>
                    </div>
                    <div class="text-sm text-gray-300 mt-1">${gameState.mana}/${gameState.manaMax}${boostText}</div>
                `;
            }
        }

        function summonCompanion(companionId) {
            const companion = COMPANIONS.find(c => c.id === companionId);
            const buttonEl = DOMElements['summon' + companionId.split('_').map(w => w.charAt(0).toUpperCase() + w.slice(1)).join('')];
            if (!companion) return;
            if (gameState.companions.some(c => c.id === companionId)) {
                DOMElements.companionFlavor.textContent = "(Already summoned)";
                setTimeout(() => DOMElements.companionFlavor.textContent = "", 2000);
                shakeElements(buttonEl.previousElementSibling, buttonEl);
                return;
            }
            const missingLevel = gameState.level < companion.unlockReq.level;
            const missingEssence = gameState.essence < companion.cost;
            if (missingLevel || missingEssence) {
                let message = "(You need ";
                if (missingLevel && missingEssence) {
                    message += "required level and essence)";
                } else if (missingLevel) {
                    message += "required level)";
                } else {
                    message += "essence)";
                }
                DOMElements.companionFlavor.textContent = message;
                setTimeout(() => DOMElements.companionFlavor.textContent = "", 2000);
                shakeElements(buttonEl.previousElementSibling, buttonEl);
                return;
            }

            gameState.essence -= companion.cost;
            gameState.companions.push(companion);
            applyCompanionEffect(companion);
            logMessage(`Summoned ${companion.name}! ${companion.description}`, "system-ok");
            DOMElements.companionFlavor.textContent = "(Summoned!)";
            setTimeout(() => DOMElements.companionFlavor.textContent = "", 2000);
            updateUI();
            buttonEl.classList.add('success-click');
            setTimeout(() => buttonEl.classList.remove('success-click'), 500);
        }

        function applyCompanionEffect(companion) {
            switch (companion.effect) {
                case 'click_mult':
                    gameState.clickMultiplier *= companion.value;
                    break;
                case 'passive_mult':
                    gameState.passiveMultiplier *= companion.value;
                    break;
                case 'bank_mult':
                    gameState.bankMultiplier *= companion.value;
                    break;
                case 'auto_mult':
                    gameState.autoClickMultiplier *= companion.value;
                    break;
                case 'crit_chance_add':
                    gameState.critChance += companion.value;
                    break;
            }
        }

        function applyRelicEffect(relic) {
            switch (relic.effect) {
                case 'crit_chance_add':
                    gameState.critChance += relic.value;
                    break;
                case 'click_mult':
                    gameState.clickMultiplier *= relic.value;
                    break;
                case 'passive_mult':
                    gameState.passiveMultiplier *= relic.value;
                    break;
                case 'luck_mult':
                    gameState.luckMultiplier *= relic.value;
                    break;
                case 'efficiency_mult':
                    gameState.efficiencyMultiplier *= relic.value;
                    break;
                case 'attack_mult':
                    // Assuming attack damage multiplier, but since attack is calculated, maybe add a multiplier
                    gameState.attackMultiplier = (gameState.attackMultiplier || 1) * relic.value;
                    break;
                case 'xp_mult':
                    gameState.xpMultiplier *= relic.value;
                    break;
            }
        }
        
        function getPlayerTitle() {
            let currentTitle = "Neophyte";
            for (const title of TITLES) {
                if (gameState.level >= title.level) {
                    currentTitle = title.name;
                }
            }
            return currentTitle;
        }
        
        function formatNumber(num) {
            if (num < 1000) return num.toString();
            if (num < 1000000) return (num / 1000).toFixed(1) + 'K';
            if (num < 1000000000) return (num / 1000000).toFixed(1) + 'M';
            if (num < 1000000000000) return (num / 1000000000).toFixed(1) + 'B';
            if (num < 1000000000000000) return (num / 1000000000000).toFixed(1) + 'T';
            return (num / 1000000000000000).toFixed(1) + 'Q';
        }

        function toggleChronicleCollapse() {
            gameState.chronicleCollapsed = !gameState.chronicleCollapsed;
            updateChronicleCollapse();
        }

        function updateChronicleCollapse() {
            const button = DOMElements.chronicleCollapseButton;
            const log = DOMElements.chatLog;
            if (gameState.chronicleCollapsed) {
                log.classList.add('collapsed');
                button.innerHTML = '<span style="font-family: monospace;">▶</span> Expand';
            } else {
                log.classList.remove('collapsed');
                log.style.height = '';
                button.innerHTML = '<span style="font-family: monospace;">▼</span> Collapse';
            }
        }

        function fadeInAudio(audio, targetVolume, duration) {
            const startVolume = audio.volume;
            const volumeStep = (targetVolume - startVolume) / (duration / 100);
            const fadeInterval = setInterval(() => {
                audio.volume += volumeStep;
                if (audio.volume >= targetVolume) {
                    audio.volume = targetVolume;
                    clearInterval(fadeInterval);
                }
            }, 100);
        }

        function toggleMusic() {
            gameState.musicEnabled = !gameState.musicEnabled;
            const audio = document.getElementById('backgroundMusic');
            if (gameState.musicEnabled) {
                audio.volume = 0.3;
                audio.play().catch(e => console.log('Audio play failed:', e));
            } else {
                audio.pause();
            }
            updateUI();
        }

        function getClickUpgradeCost() { return Math.floor(100 * Math.pow(1.5, gameState.clickUpgradeLevel) * gameState.efficiencyMultiplier); }
        function getPassiveUpgradeCost() { return Math.floor(200 * Math.pow(1.5, gameState.passiveUpgradeLevel) * gameState.efficiencyMultiplier); }
        function getBankUpgradeCost() { return Math.floor(150 * Math.pow(1.5, gameState.bankUpgradeLevel) * gameState.efficiencyMultiplier); }
        function getAutoClickUpgradeCost() { return Math.floor(250 * Math.pow(1.5, gameState.autoClickUpgradeLevel) * gameState.efficiencyMultiplier); }
        function getCritChanceUpgradeCost() { return Math.floor(300 * Math.pow(1.5, gameState.critChanceUpgradeLevel) * gameState.efficiencyMultiplier); }
        function getCritMultUpgradeCost() { return Math.floor(400 * Math.pow(1.5, gameState.critMultUpgradeLevel) * gameState.efficiencyMultiplier); }
        function getLuckUpgradeCost() { return Math.floor(500 * Math.pow(1.5, gameState.luckUpgradeLevel) * gameState.efficiencyMultiplier); }
        function getEfficiencyUpgradeCost() { return Math.floor(600 * Math.pow(1.5, gameState.efficiencyUpgradeLevel) * gameState.efficiencyMultiplier); }
        function getRegenerationUpgradeCost() { return Math.floor(700 * Math.pow(1.5, gameState.regenerationUpgradeLevel) * gameState.efficiencyMultiplier); }
        function getTimeCrystalUpgradeCost() { return Math.floor(1000 * Math.pow(1.5, gameState.timeCrystalUpgradeLevel) * gameState.efficiencyMultiplier); }

        // --- Save/Load ---
        function saveGame() {
            localStorage.setItem('gildedSyntaxSave', JSON.stringify(gameState));
        }

        function loadGame() {
            const savedGame = localStorage.getItem('gildedSyntaxSave');
            if (savedGame) {
                const loadedState = JSON.parse(savedGame);
                // Basic validation and merging
                gameState = { ...gameState, ...loadedState };
                // Ensure new properties are initialized
                if (typeof gameState.accumulatedPassive === 'undefined') gameState.accumulatedPassive = 0;
                if (typeof gameState.lastPassiveLogTime === 'undefined') gameState.lastPassiveLogTime = Date.now();
                if (typeof gameState.clickUpgradeLevel === 'undefined') gameState.clickUpgradeLevel = 0;
                if (typeof gameState.passiveUpgradeLevel === 'undefined') gameState.passiveUpgradeLevel = 0;
                if (typeof gameState.bankUpgradeLevel === 'undefined') gameState.bankUpgradeLevel = 0;
                if (typeof gameState.autoClickUpgradeLevel === 'undefined') gameState.autoClickUpgradeLevel = 0;
                if (typeof gameState.critChanceUpgradeLevel === 'undefined') gameState.critChanceUpgradeLevel = 0;
                if (typeof gameState.critMultUpgradeLevel === 'undefined') gameState.critMultUpgradeLevel = 0;
                if (typeof gameState.luckUpgradeLevel === 'undefined') gameState.luckUpgradeLevel = 0;
                if (typeof gameState.efficiencyUpgradeLevel === 'undefined') gameState.efficiencyUpgradeLevel = 0;
                if (typeof gameState.regenerationUpgradeLevel === 'undefined') gameState.regenerationUpgradeLevel = 0;
                if (typeof gameState.critChance === 'undefined') gameState.critChance = 0;
                if (typeof gameState.critMultiplier === 'undefined') gameState.critMultiplier = 2;
                if (typeof gameState.prestigePoints === 'undefined') gameState.prestigePoints = 0;
                if (typeof gameState.prestigeMultiplier === 'undefined') gameState.prestigeMultiplier = 1;
                if (typeof gameState.accumulatedBankInterest === 'undefined') gameState.accumulatedBankInterest = 0;
                if (typeof gameState.lastBankLogTime === 'undefined') gameState.lastBankLogTime = Date.now();
                if (typeof gameState.totalBankInterestEarned === 'undefined') gameState.totalBankInterestEarned = 0;
                if (typeof gameState.passiveBoostActive === 'undefined') gameState.passiveBoostActive = false;
                if (typeof gameState.passiveBoostEndTime === 'undefined') gameState.passiveBoostEndTime = 0;
                if (typeof gameState.ceoActive === 'undefined') gameState.ceoActive = false;
                if (typeof gameState.ceoEndTime === 'undefined') gameState.ceoEndTime = 0;
                if (typeof gameState.lastCEOLogTime === 'undefined') gameState.lastCEOLogTime = Date.now();
                if (typeof gameState.xpMultiplier === 'undefined') gameState.xpMultiplier = 1;
                if (typeof gameState.isAutoClickerActive === 'undefined') gameState.isAutoClickerActive = false;
                if (typeof gameState.autoClickCostPerSecond === 'undefined') gameState.autoClickCostPerSecond = 1;
                // Restore CEO from active events
                gameState.activeEvents.forEach(event => {
                    if (event.id === 'ceo_active') {
                        gameState.ceoActive = true;
                        gameState.ceoEndTime = event.endTime;
                    }
                });
                if (typeof gameState.activeEvents === 'undefined') gameState.activeEvents = [];
                if (typeof gameState.companions === 'undefined') gameState.companions = [];
                if (typeof gameState.relics === 'undefined') gameState.relics = [];
                if (typeof gameState.currentDebuff === 'undefined') gameState.currentDebuff = null;
                if (typeof gameState.debuffEndTime === 'undefined') gameState.debuffEndTime = 0;
                if (typeof gameState.mana === 'undefined') gameState.mana = 0;
                if (typeof gameState.manaMax === 'undefined') gameState.manaMax = 0;
                if (typeof gameState.manaBoostActive === 'undefined') gameState.manaBoostActive = false;
                if (typeof gameState.manaBoostEndTime === 'undefined') gameState.manaBoostEndTime = 0;
                if (typeof gameState.investmentActive === 'undefined') gameState.investmentActive = false;
                if (typeof gameState.investmentEndTime === 'undefined') gameState.investmentEndTime = 0;
                if (typeof gameState.infiniteMode === 'undefined') gameState.infiniteMode = false;
                if (typeof gameState.startTime === 'undefined') gameState.startTime = Date.now();
                if (typeof gameState.streak === 'undefined') gameState.streak = 0;
                if (typeof gameState.lastLoginDate === 'undefined') gameState.lastLoginDate = new Date().toDateString();
                if (typeof gameState.timeCrystalUpgradeLevel === 'undefined') gameState.timeCrystalUpgradeLevel = 0;
                if (typeof gameState.nextEventCountdown === 'undefined') gameState.nextEventCountdown = 20;
                if (typeof gameState.pendingEvent === 'undefined') gameState.pendingEvent = null;
                if (typeof gameState.eventBufferCountdown === 'undefined') gameState.eventBufferCountdown = 0;
                if (typeof gameState.bossFrozen === 'undefined') gameState.bossFrozen = false;
                if (typeof gameState.guaranteeRareDrop === 'undefined') gameState.guaranteeRareDrop = false;
                if (typeof gameState.attackMultiplier === 'undefined') gameState.attackMultiplier = 1;
                if (typeof gameState.originalZoneName === 'undefined') gameState.originalZoneName = null;
                if (typeof gameState.fractionalBankInterest === 'undefined') gameState.fractionalBankInterest = 0;
                if (typeof gameState.musicEnabled === 'undefined') gameState.musicEnabled = true;
                if (typeof gameState.chronicleCollapsed === 'undefined') gameState.chronicleCollapsed = false;
                if (typeof gameState.eventCooldownEndTime === 'undefined') gameState.eventCooldownEndTime = 0;
                // Clear any active events on load to prevent them from continuing
                gameState.activeEvents = [];
                gameState.pendingEvent = null;
                gameState.eventBufferCountdown = 0;
                gameState.nextEventCountdown = 20;
                  // Deep copy zones from master list but keep completed status
                  const masterZones = JSON.parse(JSON.stringify(ZONES));
                  gameState.zones = masterZones.map((zone, index) => {
                      if (loadedState.zones && loadedState.zones[index]) {
                          zone.challenges.forEach((challenge, cIndex) => {
                                if(loadedState.zones[index].challenges[cIndex]){
                                  challenge.completed = loadedState.zones[index].challenges[cIndex].completed;
                                }
                          });
                      }
                      return zone;
                  });
                  // Reset bank mode on load
                  gameState.isBankMode = false;
                  // Recheck quest completion
                  checkQuestCompletion(false);
                  // Calculate offline passive income
                const now = Date.now();
                const timeDiff = (now - gameState.lastUpdateTime) / 1000;
                const maxOfflineTime = 3600000 + gameState.timeCrystalUpgradeLevel * 1800000; // 1h + 30min per level
                const cappedTimeDiff = Math.min(timeDiff, maxOfflineTime);
                const passiveGained = Math.floor(cappedTimeDiff * gameState.passiveIncomeRate);
                if (passiveGained > 0) {
                    gameState.essence += passiveGained;
                    gainXP(Math.floor(passiveGained / 100));
                    const timeStr = timeDiff > maxOfflineTime ? ` (capped at ${Math.floor(maxOfflineTime / 3600)}h)` : '';
                    logMessage(`While you were away from Gilded Syntax, you gained ${formatNumber(passiveGained)} Essence from passive income${timeStr}.`, "system-ok");
                }
                gameState.lastUpdateTime = now;
                // Check daily login
                const today = new Date().toDateString();
                if (gameState.lastLoginDate !== today) {
                    gameState.streak++;
                    gameState.lastLoginDate = today;
                    const bonus = gameState.streak * 1000; // 1K essence per streak day
                    gameState.essence += bonus;
                    logMessage(`Daily login bonus! Streak: ${gameState.streak} days. Gained ${formatNumber(bonus)} essence.`, "system-ok");
                }
                logMessage("Welcome back to Gilded Syntax, your progress has been restored.", "system-ok");
            } else {
                logMessage("Welcome to Gilded Syntax. Begin your ascent through the gilded realms.", "system");
            }
        }

        // --- Initialization ---
        function init() {
            // Action button
            DOMElements.actionButton.addEventListener('click', (e) => handleActionClick(e));
            DOMElements.actionButton.addEventListener('mousedown', () => DOMElements.actionButton.classList.add('pressed'));
            DOMElements.actionButton.addEventListener('mouseup', () => DOMElements.actionButton.classList.remove('pressed'));
            DOMElements.actionButton.addEventListener('mouseleave', () => DOMElements.actionButton.classList.remove('pressed'));

            DOMElements.bankModeToggle.addEventListener('change', toggleBankMode);
            DOMElements.autoClickButton.addEventListener('click', toggleAutoClicker);
            DOMElements.autoClickButton.addEventListener('mousedown', () => DOMElements.autoClickButton.classList.add('pressed'));
            DOMElements.autoClickButton.addEventListener('mouseup', () => DOMElements.autoClickButton.classList.remove('pressed'));
            DOMElements.autoClickButton.addEventListener('mouseleave', () => DOMElements.autoClickButton.classList.remove('pressed'));

            // Upgrade buttons
            const upgradeButtons = [
                DOMElements.upgradeClick, DOMElements.upgradePassive, DOMElements.upgradeBank, DOMElements.upgradeAutoClick,
                DOMElements.upgradeCritChance, DOMElements.upgradeCritMult, DOMElements.upgradeLuck,
                DOMElements.upgradeEfficiency, DOMElements.upgradeRegeneration, DOMElements.upgradeTimeCrystal
            ];
            upgradeButtons.forEach(button => {
                button.addEventListener('mousedown', () => button.classList.add('pressed'));
                button.addEventListener('mouseup', () => button.classList.remove('pressed'));
                button.addEventListener('mouseleave', () => button.classList.remove('pressed'));
            });

            DOMElements.upgradeClick.addEventListener('click', buyClickUpgrade);
            DOMElements.upgradePassive.addEventListener('click', buyPassiveUpgrade);
            DOMElements.upgradeBank.addEventListener('click', buyBankUpgrade);
            DOMElements.upgradeAutoClick.addEventListener('click', buyAutoClickUpgrade);
            DOMElements.upgradeCritChance.addEventListener('click', buyCritChanceUpgrade);
            DOMElements.upgradeCritMult.addEventListener('click', buyCritMultUpgrade);
            DOMElements.upgradeLuck.addEventListener('click', buyLuckUpgrade);
            DOMElements.upgradeEfficiency.addEventListener('click', buyEfficiencyUpgrade);
            DOMElements.upgradeRegeneration.addEventListener('click', buyRegenerationUpgrade);
            DOMElements.upgradeTimeCrystal.addEventListener('click', buyTimeCrystalUpgrade);
            // Add glow effects for upgrade labels on button hover
            DOMElements.upgradeClick.addEventListener('mouseenter', () => DOMElements.clickLabel.classList.add('glow'));
            DOMElements.upgradeClick.addEventListener('mouseleave', () => DOMElements.clickLabel.classList.remove('glow'));
            DOMElements.upgradePassive.addEventListener('mouseenter', () => DOMElements.passiveLabel.classList.add('glow'));
            DOMElements.upgradePassive.addEventListener('mouseleave', () => DOMElements.passiveLabel.classList.remove('glow'));
            DOMElements.upgradeBank.addEventListener('mouseenter', () => DOMElements.bankLabel.classList.add('glow'));
            DOMElements.upgradeBank.addEventListener('mouseleave', () => DOMElements.bankLabel.classList.remove('glow'));
            DOMElements.upgradeAutoClick.addEventListener('mouseenter', () => DOMElements.autoLabel.classList.add('glow'));
            DOMElements.upgradeAutoClick.addEventListener('mouseleave', () => DOMElements.autoLabel.classList.remove('glow'));
            DOMElements.upgradeCritChance.addEventListener('mouseenter', () => DOMElements.critChanceLabel.classList.add('glow'));
            DOMElements.upgradeCritChance.addEventListener('mouseleave', () => DOMElements.critChanceLabel.classList.remove('glow'));
            DOMElements.upgradeCritMult.addEventListener('mouseenter', () => DOMElements.critMultLabel.classList.add('glow'));
            DOMElements.upgradeCritMult.addEventListener('mouseleave', () => DOMElements.critMultLabel.classList.remove('glow'));
            DOMElements.upgradeLuck.addEventListener('mouseenter', () => DOMElements.luckLabel.classList.add('glow'));
            DOMElements.upgradeLuck.addEventListener('mouseleave', () => DOMElements.luckLabel.classList.remove('glow'));
            DOMElements.upgradeEfficiency.addEventListener('mouseenter', () => DOMElements.efficiencyLabel.classList.add('glow'));
            DOMElements.upgradeEfficiency.addEventListener('mouseleave', () => DOMElements.efficiencyLabel.classList.remove('glow'));
            DOMElements.upgradeRegeneration.addEventListener('mouseenter', () => DOMElements.regenerationLabel.classList.add('glow'));
            DOMElements.upgradeRegeneration.addEventListener('mouseleave', () => DOMElements.regenerationLabel.classList.remove('glow'));
            DOMElements.upgradeTimeCrystal.addEventListener('mouseenter', () => DOMElements.timeCrystalLabel.classList.add('glow'));
            DOMElements.upgradeTimeCrystal.addEventListener('mouseleave', () => DOMElements.timeCrystalLabel.classList.remove('glow'));
            // Companion buttons
            const companionButtons = [
                DOMElements.summonFireSprite, DOMElements.summonWaterNymph, DOMElements.summonEarthGolem,
                DOMElements.summonAirSpirit, DOMElements.summonShadowImp
            ];
            companionButtons.forEach(button => {
                button.addEventListener('mousedown', () => button.classList.add('pressed'));
                button.addEventListener('mouseup', () => button.classList.remove('pressed'));
                button.addEventListener('mouseleave', () => button.classList.remove('pressed'));
            });

            DOMElements.summonFireSprite.addEventListener('click', () => summonCompanion('fire_sprite'));
            DOMElements.summonWaterNymph.addEventListener('click', () => summonCompanion('water_nymph'));
            DOMElements.summonEarthGolem.addEventListener('click', () => summonCompanion('earth_golem'));
            DOMElements.summonAirSpirit.addEventListener('click', () => summonCompanion('air_spirit'));
            DOMElements.summonShadowImp.addEventListener('click', () => summonCompanion('shadow_imp'));
            // Add glow effects for companion names on button hover
            DOMElements.summonFireSprite.addEventListener('mouseenter', () => DOMElements.summonFireSprite.previousElementSibling.classList.add('glow'));
            DOMElements.summonFireSprite.addEventListener('mouseleave', () => DOMElements.summonFireSprite.previousElementSibling.classList.remove('glow'));
            DOMElements.summonWaterNymph.addEventListener('mouseenter', () => DOMElements.summonWaterNymph.previousElementSibling.classList.add('glow'));
            DOMElements.summonWaterNymph.addEventListener('mouseleave', () => DOMElements.summonWaterNymph.previousElementSibling.classList.remove('glow'));
            DOMElements.summonEarthGolem.addEventListener('mouseenter', () => DOMElements.summonEarthGolem.previousElementSibling.classList.add('glow'));
            DOMElements.summonEarthGolem.addEventListener('mouseleave', () => DOMElements.summonEarthGolem.previousElementSibling.classList.remove('glow'));
            DOMElements.summonAirSpirit.addEventListener('mouseenter', () => DOMElements.summonAirSpirit.previousElementSibling.classList.add('glow'));
            DOMElements.summonAirSpirit.addEventListener('mouseleave', () => DOMElements.summonAirSpirit.previousElementSibling.classList.remove('glow'));
            DOMElements.summonShadowImp.addEventListener('mouseenter', () => DOMElements.summonShadowImp.previousElementSibling.classList.add('glow'));
            DOMElements.summonShadowImp.addEventListener('mouseleave', () => DOMElements.summonShadowImp.previousElementSibling.classList.remove('glow'));
            // Bank buttons
            const bankButtons = [
                DOMElements.bankBoostButton, DOMElements.hireCEOButton, DOMElements.bankInvestmentButton, DOMElements.convertClicksButton
            ];
            bankButtons.forEach(button => {
                button.addEventListener('mousedown', () => button.classList.add('pressed'));
                button.addEventListener('mouseup', () => button.classList.remove('pressed'));
                button.addEventListener('mouseleave', () => button.classList.remove('pressed'));
            });

            DOMElements.bankBoostButton.addEventListener('click', useBankBoost);
            DOMElements.hireCEOButton.addEventListener('click', hireCEO);
            DOMElements.bankInvestmentButton.addEventListener('click', useBankInvestment);
            DOMElements.convertClicksButton.addEventListener('click', convertClicksToEssence);

            // Prestige button
            DOMElements.prestigeButton.addEventListener('mousedown', () => DOMElements.prestigeButton.classList.add('pressed'));
            DOMElements.prestigeButton.addEventListener('mouseup', () => DOMElements.prestigeButton.classList.remove('pressed'));
            DOMElements.prestigeButton.addEventListener('mouseleave', () => DOMElements.prestigeButton.classList.remove('pressed'));
            DOMElements.prestigeButton.addEventListener('click', prestige);
            DOMElements.exportSaveButton.addEventListener('click', exportSave);
            DOMElements.loadSaveButton.addEventListener('click', loadSave);
            DOMElements.loadSaveButton.addEventListener('mousedown', () => DOMElements.loadSaveButton.classList.add('pressed'));
            DOMElements.loadSaveButton.addEventListener('mouseup', () => DOMElements.loadSaveButton.classList.remove('pressed'));
            DOMElements.loadSaveButton.addEventListener('mouseleave', () => DOMElements.loadSaveButton.classList.remove('pressed'));
            document.getElementById('resetProfile').addEventListener('click', resetProfile);
            document.getElementById('debugButton').addEventListener('click', debugToggle);
            DOMElements.playerEssence.addEventListener('click', () => { showFullEssence = !showFullEssence; updateUI(); });
            DOMElements.playerAttack.addEventListener('click', () => { showFullAttack = !showFullAttack; updateUI(); });
            DOMElements.bankedClicks.addEventListener('click', () => { showFullBankedClicks = !showFullBankedClicks; updateUI(); });

            // Music icon button
            DOMElements.musicIconButton.addEventListener('mousedown', () => DOMElements.musicIconButton.classList.add('pressed'));
            DOMElements.musicIconButton.addEventListener('mouseup', () => DOMElements.musicIconButton.classList.remove('pressed'));
            DOMElements.musicIconButton.addEventListener('mouseleave', () => DOMElements.musicIconButton.classList.remove('pressed'));
            DOMElements.musicIconButton.addEventListener('click', toggleMusic);

            // Chronicle collapse button
            DOMElements.chronicleCollapseButton.addEventListener('click', toggleChronicleCollapse);

            loadGame();
            // Initialize viewer counter - unique per user
            if (!localStorage.getItem('hasVisited')) {
                localStorage.setItem('hasVisited', 'true');
                document.getElementById('viewerCounter').textContent = 'Unique Viewers: 1';
            } else {
                document.getElementById('viewerCounter').textContent = 'Unique Viewers: 1';
            }
            gameState.eventCooldownEndTime = Date.now() + 10000; // Prevent events for 10 seconds on page load
            loadZone();
            updateUI();
            setCursor();

            // Initialize background particles
            const styles = ['combined', 'overlay', 'style3'];
            backgroundCurrentStyle = styles[Math.floor(Math.random() * styles.length)];
            setCanvasSize();
            initBackgroundParticles();
            animateBackgroundParticles();

            // Background particle event listeners
            window.addEventListener('resize', () => {
                setCanvasSize();
                initBackgroundParticles();
            });

            window.addEventListener('mousemove', (event) => {
                backgroundMouse.x = event.x;
                backgroundMouse.y = event.y;
            });

            window.addEventListener('mouseout', () => {
                backgroundMouse.x = null;
                backgroundMouse.y = null;
            });

            // Passive income every second
            setInterval(() => {
                updatePassiveIncome();
                updateUI();
            }, 1000);


            // Ensure loading screen shows for at least 1 second to allow UI to settle
            setTimeout(() => {
                document.getElementById('loading-screen').style.display = 'none';
                document.getElementById('main-game-container').style.display = 'flex';
            }, 1000);

            // Play background music on first interaction
            document.addEventListener('click', () => {
                const audio = document.getElementById('backgroundMusic');
                if (audio && audio.paused && gameState.musicEnabled) {
                    audio.volume = 0;
                    audio.play().then(() => {
                        fadeInAudio(audio, 0.3, 2000); // fade to 0.3 over 2 seconds
                    }).catch(e => console.log('Audio play failed:', e));
                }
            }, { once: true });

            // Effect Canvas Setup
            canvas = document.getElementById('effect-canvas');
            ctx = canvas.getContext('2d');
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });

            animateParticles();

            // FPS Counter Update
            setInterval(() => {
                fps = frameCount;
                frameCount = 0;
                const fpsEl = document.getElementById('fps-counter');
                if (fpsEl) fpsEl.textContent = `FPS: ${fps}`;
            }, 1000);
        }

        // --- Effect Functions ---

        // Mana Wisps (Gather Effect)
        function manaWisps(e, consecutiveClicks = 1) {
            const baseFloatingWisps = 30; // Original floating wisps
            const attractedWisps = Math.min(consecutiveClicks * 2, 20); // Up to 20 attracted wisps (reduced)

            // Create original floating wisps (old behavior)
            for (let i = 0; i < baseFloatingWisps; i++) {
                createParticle(e.clientX, e.clientY + window.scrollY, {
                    type: 'wisp',
                    mouseAttraction: false // Original floating behavior
                });
            }

            // Create attracted wisps (new clumping behavior) - always create some when consecutive
            for (let i = 0; i < attractedWisps; i++) {
                createParticle(e.clientX, e.clientY + window.scrollY, {
                    type: 'wisp',
                    consecutiveClicks: consecutiveClicks,
                    mouseAttraction: true, // New mouse clumping behavior
                    duration: 1500, // Faster fade away (1.5 seconds vs 2.5 seconds for floating wisps)
                    sizeMultiplier: 1.3 // Make enhanced wisps 30% bigger
                });
            }
        }

        // Force Wave (Store Effect)
        function forceWave(e) {
            // Get button center for attraction
            const buttonRect = DOMElements.actionButton.getBoundingClientRect();
            const buttonCenterX = buttonRect.left + buttonRect.width / 2;
            const buttonCenterY = buttonRect.top + buttonRect.height / 2 + window.scrollY;

            // Main wave ring - MORE VISIBLE
            const wave = {
                x: e.clientX,
                y: e.clientY + window.scrollY,
                radius: 0,
                life: 35, // Increased duration for better visibility
                update() {
                    this.radius += 8.0; // Faster expansion for more prominent effect
                    this.life--;
                },
                draw(ctx) {
                    const screenY = this.y - window.scrollY;

                    // Subtle white wave
                    ctx.strokeStyle = `rgba(255, 255, 255, ${Math.min(this.life / 35 * 0.7, 0.6)})`;
                    ctx.lineWidth = 6 * (this.life / 35); // Reduced thickness
                    ctx.globalAlpha = Math.min(this.life / 35 * 0.8, 0.7); // Reduced opacity
                    ctx.shadowColor = 'rgba(255, 255, 255, 0.4)';
                    ctx.shadowBlur = 4 * (this.life / 35); // Reduced shadow
                    ctx.beginPath();
                    ctx.arc(this.x, screenY, this.radius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Remove shadow for next elements
                    ctx.shadowBlur = 0;

                    // Subtle white inner highlight ring
                    ctx.strokeStyle = `rgba(255, 255, 255, ${Math.min((this.life / 35) * 0.6, 0.5)})`;
                    ctx.lineWidth = 2 * (this.life / 35); // Reduced thickness
                    ctx.globalAlpha = Math.min((this.life / 35) * 0.8, 0.6);
                    ctx.beginPath();
                    ctx.arc(this.x, screenY, this.radius * 0.25, 0, Math.PI * 2);
                    ctx.stroke();

                    // Remove second inner ring for subtlety
                }
            };
            particles.push(wave);

            // Secondary ripple rings - also more visible
            for (let i = 1; i <= 3; i++) {
                setTimeout(() => {
                    const ripple = {
                        x: e.clientX,
                        y: e.clientY + window.scrollY,
                        radius: 0,
                        delay: i * 4, // Tighter stagger
                        life: 28 - i * 2, // Longer life for each ring
                        ringIndex: i,
                        update() {
                            if (this.delay > 0) {
                                this.delay--;
                                return;
                            }
                            this.radius += 9.5 - this.ringIndex * 1.2; // Faster expansion
                            this.life--;
                        },
                        draw(ctx) {
                            if (this.delay > 0) return;

                            const screenY = this.y - window.scrollY;
                            const alpha = Math.min((this.life / (28 - this.ringIndex * 2)) * (1.0 - this.ringIndex * 0.1), 1);

                            // Subtle white rings
                            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.5})`; // Reduced opacity
                            ctx.lineWidth = (3 - this.ringIndex * 0.6) * alpha; // Thinner lines
                            ctx.globalAlpha = alpha * 0.6; // Reduced overall alpha
                            ctx.shadowColor = 'rgba(255, 255, 255, 0.3)';
                            ctx.shadowBlur = 2 * alpha; // Reduced shadow
                            ctx.beginPath();
                            ctx.arc(this.x, screenY, this.radius, 0, Math.PI * 2);
                            ctx.stroke();
                            ctx.shadowBlur = 0;
                        }
                    };
                    particles.push(ripple);
                }, i * 60); // Tighter delay between ripples
            }

            // Add visible button-attracting sparkles (spawn away and get sucked in, gradually increasing)
            let sparkleCount = 0;
            const maxSparkles = 12;
            const batchSizes = [1, 2, 3, 3, 3]; // Gradually increase batch size
            let batchIndex = 0;

            const sparkleInterval = setInterval(() => {
                if (sparkleCount >= maxSparkles || batchIndex >= batchSizes.length) {
                    clearInterval(sparkleInterval);
                    return;
                }

                const batchSize = batchSizes[batchIndex];
                for (let i = 0; i < batchSize && sparkleCount < maxSparkles; i++) {
                    // Spawn at random distance and angle away from button center
                    const angle = Math.random() * Math.PI * 2;
                    const distance = 150 + Math.random() * 100; // 150-250 pixels away
                    const sparkle = {
                        x: buttonCenterX + Math.cos(angle) * distance,
                        y: buttonCenterY + Math.sin(angle) * distance,
                        vx: (Math.random() - 0.5) * 0.5, // Gentler initial movement
                        vy: (Math.random() - 0.5) * 0.5,
                        life: 90, // Longer life for sustained effect
                        maxLife: 90,
                        buttonAttraction: true,
                        buttonCenterX: buttonCenterX,
                        buttonCenterY: buttonCenterY,
                        update() {
                            this.life--;

                            if (this.buttonAttraction && this.life > 0) {
                                // Attract towards button center
                                const dx = this.buttonCenterX - this.x;
                                const dy = this.buttonCenterY - this.y;
                                const distance = Math.sqrt(dx * dx + dy * dy);

                                if (distance > 0) {
                                    const attractionStrength = 0.08; // Stronger attraction to suck in
                                    const attraction = Math.min(attractionStrength, distance * 0.02);
                                    this.vx += (dx / distance) * attraction;
                                    this.vy += (dy / distance) * attraction;
                                }
                            }

                            this.x += this.vx;
                            this.y += this.vy;

                            if (this.buttonAttraction) {
                                this.vx *= 0.98; // Less drag for stronger pull
                                this.vy *= 0.98;
                            }
                        },
                        draw(ctx) {
                            const screenY = this.y - window.scrollY;
                            const alpha = this.life / this.maxLife;

                            // More visible white sparkles
                            ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.9})`; // Increased opacity
                            ctx.globalAlpha = alpha * 1.0; // Full opacity

                            const size = (3 + Math.random() * 2) * alpha; // Larger size
                            ctx.beginPath();
                            ctx.arc(this.x, screenY, size, 0, Math.PI * 2);
                            ctx.fill();

                            // More visible sparkle effect
                            ctx.strokeStyle = `rgba(255, 255, 255, ${alpha * 0.8})`;
                            ctx.lineWidth = 1.2; // Thicker lines
                            const sparkleSize = 6 * alpha; // Larger sparkle
                            ctx.beginPath();
                            ctx.moveTo(this.x - sparkleSize, screenY);
                            ctx.lineTo(this.x + sparkleSize, screenY);
                            ctx.moveTo(this.x, screenY - sparkleSize);
                            ctx.lineTo(this.x, screenY + sparkleSize);
                            ctx.stroke();

                            // More visible glow effect (for brighter sparkles)
                            if (alpha > 0.6) {
                                ctx.globalAlpha = alpha * 0.4; // Increased glow intensity
                                ctx.fillStyle = `rgba(255, 255, 255, ${alpha * 0.6})`;
                                ctx.beginPath();
                                ctx.arc(this.x, screenY, size * 2, 0, Math.PI * 2); // Larger glow
                                ctx.fill();
                            }
                        }
                    };
                    particles.push(sparkle);
                    sparkleCount++;
                }
                batchIndex++;
            }, 150); // Add batches every 150ms
        }

        // Boss Strike (Attack Effect)
        function bossStrike(e) {
            // Create multiple slash marks
            for (let i = 0; i < 4; i++) {
                const slash = {
                    x: e.clientX,
                    y: e.clientY + window.scrollY,
                    width: 0,
                    maxWidth: 150,
                    height: 3,
                    rotation: Math.random() * 180,
                    life: 15, // 250ms / 16.67 ~15 frames
                    delay: Math.floor(Math.random() * 6), // delay in frames
                    update() {
                        if (this.delay > 0) {
                            this.delay--;
                            return;
                        }
                        if (this.width < this.maxWidth) {
                            this.width += 10; // grow
                        } else {
                            this.width -= 10; // shrink
                        }
                        this.life--;
                    },
                    draw(ctx) {
                        const screenY = this.y - window.scrollY;
                        ctx.save();
                        ctx.translate(this.x, screenY);
                        ctx.rotate(this.rotation * Math.PI / 180);
                        ctx.strokeStyle = 'white';
                        ctx.lineWidth = this.height;
                        ctx.globalAlpha = this.life / 15;
                        ctx.beginPath();
                        ctx.moveTo(-this.width / 2, 0);
                        ctx.lineTo(this.width / 2, 0);
                        ctx.stroke();
                        ctx.restore();
                    }
                };
                particles.push(slash);
            }

            // Create impact particles
            for (let i = 0; i < 30; i++) {
                createParticle(e.clientX, e.clientY + window.scrollY, {
                    type: 'spark',
                    gravity: true,
                    speedMultiplier: 1.0,
                    duration: Math.random() * 500 + 400
                });
            }
        }

        // Core logic for simple particles
        function createParticle(x, y, options = {}) {
            const { type, duration = 2500, speedMultiplier = 0.3, gravity = false, consecutiveClicks = 1, mouseAttraction = false, sizeMultiplier = 1.0 } = options;

            const particle = {
                x, y,
                vx: 0, vy: 0,
                life: Math.ceil(duration / 16.67), // assuming ~60fps
                maxLife: Math.ceil(duration / 16.67),
                size: type === 'spark' ? Math.random() * 4 + 1 : type === 'wisp' ? (Math.random() * 8 + 3) * sizeMultiplier : Math.random() * 10 + 5,
                color: type === 'wisp' ? '#00ffff' : type === 'spark' ? `hsl(${Math.random() * 20 + 35}, 100%, 60%)` : '#fff',
                gravity,
                mouseAttraction,
                consecutiveClicks,
                originalX: x,
                originalY: y,
                update() {
                    this.life--;

                    if (this.mouseAttraction && this.life > 0) {
                        // Calculate attraction to mouse position
                        const dx = mousePosition.x - this.x;
                        const dy = mousePosition.y - this.y;
                        const distance = Math.sqrt(dx * dx + dy * dy);

                        if (distance > 0) {
                            // Stronger attraction with more consecutive clicks
                            const attractionStrength = (this.consecutiveClicks * 0.5 + 1) * 0.02;
                            const maxDistance = 200; // Maximum attraction distance

                            if (distance < maxDistance) {
                                const attraction = Math.min(attractionStrength * (1 - distance / maxDistance), 0.1);
                                this.vx += (dx / distance) * attraction;
                                this.vy += (dy / distance) * attraction;
                            }
                        }
                    }

                    this.x += this.vx;
                    this.y += this.vy;

                    if (this.gravity) {
                        this.vy += 0.2; // Gravity effect
                    } else if (!this.mouseAttraction) { // Original wisp behavior for non-attracted wisps
                        this.vx += (Math.random() - 0.5) * 0.1; // Gentle sway
                        this.vy *= 0.98;
                    } else {
                        // Apply some drag to mouse-attracted wisps
                        this.vx *= 0.98;
                        this.vy *= 0.98;

                        // Keep wisps somewhat contained around the original click area
                        const dx = this.x - this.originalX;
                        const dy = this.y - this.originalY;
                        const containmentDistance = Math.sqrt(dx * dx + dy * dy);

                        if (containmentDistance > 150) {
                            const containmentStrength = 0.01;
                            this.vx -= (dx / containmentDistance) * containmentStrength;
                            this.vy -= (dy / containmentDistance) * containmentStrength;
                        }
                    }
                },
                draw(ctx) {
                    const screenY = this.y - window.scrollY;
                    ctx.fillStyle = this.color;

                    // Enhanced alpha based on mouse attraction and consecutive clicks
                    let baseAlpha = this.life / this.maxLife;
                    if (this.mouseAttraction) {
                        // Make wisps more visible when attracted to mouse
                        baseAlpha = Math.min(baseAlpha * (1 + this.consecutiveClicks * 0.2), 1);
                    }

                    ctx.globalAlpha = baseAlpha;
                    ctx.beginPath();
                    ctx.arc(this.x, screenY, this.size, 0, Math.PI * 2);
                    ctx.fill();

                    // Add a subtle glow effect for mouse-attracted wisps
                    if (this.mouseAttraction && this.consecutiveClicks > 3) {
                        ctx.globalAlpha = baseAlpha * 0.3;
                        ctx.fillStyle = '#ffffff';
                        ctx.beginPath();
                        ctx.arc(this.x, screenY, this.size * 1.5, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }
            };

            const angle = Math.random() * Math.PI * 2;
            const speed = (Math.random() * 5 + 2) * speedMultiplier;
            particle.vx = Math.cos(angle) * speed;
            particle.vy = Math.sin(angle) * speed;

            particles.push(particle);
        }


        function clearAllParticles() {
            particles = [];
        }

        // Mouse move for cursor positioning
        document.addEventListener('mousemove', e => {
            if (customCursor.style.display === 'none') {
                customCursor.style.display = 'block';
            }
            // Hotspot for the up-left rotated crystal tip
            const hotspotX = 9;
            const hotspotY = 9;
            const x = e.clientX - hotspotX;
            const y = e.clientY - hotspotY;
            customCursor.style.transform = `translate3d(${x}px, ${y}px, 0)`;

            // Track mouse position for wisp attraction
            mousePosition.x = e.clientX;
            mousePosition.y = e.clientY + window.scrollY;
        });

        // Clicking animation
        document.addEventListener('mousedown', () => {
            if (customCursor.style.display !== 'none') {
                customCursor.classList.add('clicking');
            }
        });
        document.addEventListener('mouseup', () => {
            customCursor.classList.remove('clicking');
        });

        window.onload = init;

    </script>
</body>
</html>
